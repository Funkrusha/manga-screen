
Webserver.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000256  00800100  00008090  00008124  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00008090  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000a60  00800356  00800356  0000837a  2**0
                  ALLOC
  3 .stab         00002ae4  00000000  00000000  0000837c  2**2
                  CONTENTS, READONLY, DEBUGGING
  4 .stabstr      00001004  00000000  00000000  0000ae60  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_aranges 00000e80  00000000  00000000  0000be64  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_pubnames 000022d0  00000000  00000000  0000cce4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_info   0001bc57  00000000  00000000  0000efb4  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 00005ba2  00000000  00000000  0002ac0b  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_line   00014346  00000000  00000000  000307ad  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_frame  00001700  00000000  00000000  00044af4  2**2
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_str    00007ec0  00000000  00000000  000461f4  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_loc    0000e05c  00000000  00000000  0004e0b4  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_pubtypes 00003817  00000000  00000000  0005c110  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 000013a8  00000000  00000000  0005f927  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
       0:	07 c2       	rjmp	.+1038   	; 0x410 <__ctors_end>
       2:	00 00       	nop
       4:	23 c2       	rjmp	.+1094   	; 0x44c <__bad_interrupt>
       6:	00 00       	nop
       8:	21 c2       	rjmp	.+1090   	; 0x44c <__bad_interrupt>
       a:	00 00       	nop
       c:	1f c2       	rjmp	.+1086   	; 0x44c <__bad_interrupt>
       e:	00 00       	nop
      10:	1d c2       	rjmp	.+1082   	; 0x44c <__bad_interrupt>
      12:	00 00       	nop
      14:	1b c2       	rjmp	.+1078   	; 0x44c <__bad_interrupt>
      16:	00 00       	nop
      18:	19 c2       	rjmp	.+1074   	; 0x44c <__bad_interrupt>
      1a:	00 00       	nop
      1c:	17 c2       	rjmp	.+1070   	; 0x44c <__bad_interrupt>
      1e:	00 00       	nop
      20:	15 c2       	rjmp	.+1066   	; 0x44c <__bad_interrupt>
      22:	00 00       	nop
      24:	13 c2       	rjmp	.+1062   	; 0x44c <__bad_interrupt>
      26:	00 00       	nop
      28:	0c 94 b8 2d 	jmp	0x5b70	; 0x5b70 <__vector_10>
      2c:	0c 94 15 2f 	jmp	0x5e2a	; 0x5e2a <__vector_11>
      30:	0d c2       	rjmp	.+1050   	; 0x44c <__bad_interrupt>
      32:	00 00       	nop
      34:	0b c2       	rjmp	.+1046   	; 0x44c <__bad_interrupt>
      36:	00 00       	nop
      38:	09 c2       	rjmp	.+1042   	; 0x44c <__bad_interrupt>
      3a:	00 00       	nop
      3c:	07 c2       	rjmp	.+1038   	; 0x44c <__bad_interrupt>
      3e:	00 00       	nop
      40:	05 c2       	rjmp	.+1034   	; 0x44c <__bad_interrupt>
      42:	00 00       	nop
      44:	0c 94 34 1c 	jmp	0x3868	; 0x3868 <__vector_17>
      48:	01 c2       	rjmp	.+1026   	; 0x44c <__bad_interrupt>
      4a:	00 00       	nop
      4c:	ff c1       	rjmp	.+1022   	; 0x44c <__bad_interrupt>
      4e:	00 00       	nop
      50:	fd c1       	rjmp	.+1018   	; 0x44c <__bad_interrupt>
      52:	00 00       	nop
      54:	fb c1       	rjmp	.+1014   	; 0x44c <__bad_interrupt>
      56:	00 00       	nop
      58:	f9 c1       	rjmp	.+1010   	; 0x44c <__bad_interrupt>
      5a:	00 00       	nop
      5c:	f7 c1       	rjmp	.+1006   	; 0x44c <__bad_interrupt>
      5e:	00 00       	nop
      60:	f5 c1       	rjmp	.+1002   	; 0x44c <__bad_interrupt>
      62:	00 00       	nop
      64:	f3 c1       	rjmp	.+998    	; 0x44c <__bad_interrupt>
      66:	00 00       	nop
      68:	f1 c1       	rjmp	.+994    	; 0x44c <__bad_interrupt>
      6a:	00 00       	nop
      6c:	ef c1       	rjmp	.+990    	; 0x44c <__bad_interrupt>
      6e:	00 00       	nop
      70:	ed c1       	rjmp	.+986    	; 0x44c <__bad_interrupt>
      72:	00 00       	nop
      74:	eb c1       	rjmp	.+982    	; 0x44c <__bad_interrupt>
      76:	00 00       	nop
      78:	e9 c1       	rjmp	.+978    	; 0x44c <__bad_interrupt>
      7a:	00 00       	nop
      7c:	e7 c1       	rjmp	.+974    	; 0x44c <__bad_interrupt>
      7e:	00 00       	nop
      80:	e5 c1       	rjmp	.+970    	; 0x44c <__bad_interrupt>
      82:	00 00       	nop
      84:	e3 c1       	rjmp	.+966    	; 0x44c <__bad_interrupt>
      86:	00 00       	nop
      88:	e1 c1       	rjmp	.+962    	; 0x44c <__bad_interrupt>
      8a:	00 00       	nop
      8c:	df c1       	rjmp	.+958    	; 0x44c <__bad_interrupt>
      8e:	00 00       	nop
      90:	dd c1       	rjmp	.+954    	; 0x44c <__bad_interrupt>
      92:	00 00       	nop
      94:	db c1       	rjmp	.+950    	; 0x44c <__bad_interrupt>
      96:	00 00       	nop

00000098 <DeviceDescriptor>:
      98:	12 01 10 01 ef 02 01 08 eb 03 69 20 01 00 01 02     ..........i ....
      a8:	dc 01                                               ..

000000aa <ConfigurationDescriptor>:
      aa:	09 02 5d 00 03 01 00 80 32 08 0b 00 02 02 02 ff     ..].....2.......
      ba:	00 09 04 00 00 01 02 02 ff 00 05 24 00 10 01 04     ...........$....
      ca:	24 02 00 05 24 06 00 01 07 05 85 03 08 00 ff 09     $...$...........
      da:	04 01 00 02 0a 00 00 00 07 05 02 02 40 00 05 07     ............@...
      ea:	05 81 02 40 00 05 09 04 02 00 02 08 06 50 00 07     ...@.........P..
      fa:	05 83 02 40 00 05 07 05 04 02 40 00 05              ...@......@..

00000107 <LanguageString>:
     107:	04 03 09 04                                         ....

0000010b <ManufacturerString>:
     10b:	18 03 44 00 65 00 61 00 6e 00 20 00 43 00 61 00     ..D.e.a.n. .C.a.
     11b:	6d 00 65 00 72 00 61 00 00 00                       m.e.r.a...

00000125 <ProductString>:
     125:	1e 03 4c 00 55 00 46 00 41 00 20 00 57 00 65 00     ..L.U.F.A. .W.e.
     135:	62 00 73 00 65 00 72 00 76 00 65 00 72 00 00 00     b.s.e.r.v.e.r...

00000145 <HTTP200Header>:
     145:	48 54 54 50 2f 31 2e 31 20 32 30 30 20 4f 4b 0d     HTTP/1.1 200 OK.
     155:	0a 53 65 72 76 65 72 3a 20 4c 55 46 41 20 31 33     .Server: LUFA 13
     165:	30 33 30 33 0d 0a 43 6f 6e 6e 65 63 74 69 6f 6e     0303..Connection
     175:	3a 20 63 6c 6f 73 65 0d 0a 4d 49 4d 45 2d 76 65     : close..MIME-ve
     185:	72 73 69 6f 6e 3a 20 31 2e 30 0d 0a 43 6f 6e 74     rsion: 1.0..Cont
     195:	65 6e 74 2d 54 79 70 65 3a 20 00                    ent-Type: .

000001a0 <HTTP404Header>:
     1a0:	48 54 54 50 2f 31 2e 31 20 34 30 34 20 4e 6f 74     HTTP/1.1 404 Not
     1b0:	20 46 6f 75 6e 64 0d 0a 53 65 72 76 65 72 3a 20      Found..Server: 
     1c0:	4c 55 46 41 20 31 33 30 33 30 33 0d 0a 43 6f 6e     LUFA 130303..Con
     1d0:	6e 65 63 74 69 6f 6e 3a 20 63 6c 6f 73 65 0d 0a     nection: close..
     1e0:	4d 49 4d 45 2d 76 65 72 73 69 6f 6e 3a 20 31 2e     MIME-version: 1.
     1f0:	30 0d 0a 43 6f 6e 74 65 6e 74 2d 54 79 70 65 3a     0..Content-Type:
     200:	20 74 65 78 74 2f 70 6c 61 69 6e 0d 0a 0d 0a 45      text/plain....E
     210:	72 72 6f 72 20 34 30 34 3a 20 46 69 6c 65 20 4e     rror 404: File N
     220:	6f 74 20 46 6f 75 6e 64 3a 20 2f 00                 ot Found: /.

0000022c <DefaultDirFileName>:
     22c:	69 6e 64 65 78 2e 68 74 6d 00                       index.htm.

00000236 <DefaultMIMEType>:
     236:	74 65 78 74 2f 70 6c 61 69 6e 00                    text/plain.

00000241 <__c.2052>:
     241:	47 45 54 00                                         GET.

00000245 <__c.2066>:
     245:	0d 0a 0d 0a 00                                      .....

0000024a <WelcomeHeader>:
     24a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     25a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     26a:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 2a 20     ************..* 
     27a:	20 20 20 20 20 20 4c 55 46 41 20 75 49 50 20 57           LUFA uIP W
     28a:	65 62 73 65 72 76 65 72 20 28 54 45 4c 4e 45 54     ebserver (TELNET
     29a:	29 20 20 20 20 20 20 20 20 2a 0d 0a 2a 2a 2a 2a     )        *..****
     2aa:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2ba:	2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a 2a     ****************
     2ca:	2a 2a 2a 2a 2a 2a 2a 2a 0d 0a 00                    ********...

000002d5 <TELNETMenu>:
     2d5:	0d 0a 20 20 3d 3d 20 41 76 61 69 6c 61 62 6c 65     ..  == Available
     2e5:	20 43 6f 6d 6d 61 6e 64 73 3a 20 3d 3d 0d 0a 20      Commands: ==.. 
     2f5:	20 20 20 20 63 29 20 4c 69 73 74 20 41 63 74 69         c) List Acti
     305:	76 65 20 54 43 50 20 43 6f 6e 6e 65 63 74 69 6f     ve TCP Connectio
     315:	6e 73 0d 0a 20 20 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d     ns..  ==========
     325:	3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 3d 0d     ===============.
     335:	0a 0d 0a 3e 00                                      ...>.

0000033a <CurrentConnectionsHeader>:
     33a:	0d 0a 2a 20 43 75 72 72 65 6e 74 20 54 43 50 20     ..* Current TCP 
     34a:	43 6f 6e 6e 65 63 74 69 6f 6e 73 3a 20 2a 0d 0a     Connections: *..
     35a:	00                                                  .

0000035b <__c.2192>:
     35b:	49 6e 76 61 6c 69 64 20 43 6f 6d 6d 61 6e 64 2e     Invalid Command.
     36b:	0d 0a 00                                            ...

0000036e <__c.2202>:
     36e:	25 75 29 20 25 64 2e 25 64 2e 25 64 2e 25 64 20     %u) %d.%d.%d.%d 
     37e:	28 4c 6f 63 61 6c 20 50 6f 72 74 20 25 75 20 3c     (Local Port %u <
     38e:	3d 3e 20 52 65 6d 6f 74 65 20 50 6f 72 74 20 25     => Remote Port %
     39e:	75 29 0d 0a 00                                      u)...

000003a3 <AdapterSupportedOIDList>:
     3a3:	01 01 01 00 02 02 01 00 02 01 01 00 03 01 01 00     ................
     3b3:	04 01 01 00 06 01 01 00 11 01 01 00 07 01 01 00     ................
     3c3:	0a 01 01 00 0b 01 01 00 0c 01 01 00 0d 01 01 00     ................
     3d3:	0e 01 01 00 11 01 01 00 14 01 01 00 01 01 02 00     ................
     3e3:	02 01 02 00 03 01 02 00 04 01 02 00 05 01 02 00     ................
     3f3:	01 01 01 01 02 01 01 01 03 01 01 01 04 01 01 01     ................
     403:	01 01 02 01 02 01 02 01 03 01 02 01 00              .............

00000410 <__ctors_end>:
     410:	11 24       	eor	r1, r1
     412:	1f be       	out	0x3f, r1	; 63
     414:	cf ef       	ldi	r28, 0xFF	; 255
     416:	d0 e2       	ldi	r29, 0x20	; 32
     418:	de bf       	out	0x3e, r29	; 62
     41a:	cd bf       	out	0x3d, r28	; 61

0000041c <__do_copy_data>:
     41c:	13 e0       	ldi	r17, 0x03	; 3
     41e:	a0 e0       	ldi	r26, 0x00	; 0
     420:	b1 e0       	ldi	r27, 0x01	; 1
     422:	e0 e9       	ldi	r30, 0x90	; 144
     424:	f0 e8       	ldi	r31, 0x80	; 128
     426:	00 e0       	ldi	r16, 0x00	; 0
     428:	0b bf       	out	0x3b, r16	; 59
     42a:	02 c0       	rjmp	.+4      	; 0x430 <__do_copy_data+0x14>
     42c:	07 90       	elpm	r0, Z+
     42e:	0d 92       	st	X+, r0
     430:	a6 35       	cpi	r26, 0x56	; 86
     432:	b1 07       	cpc	r27, r17
     434:	d9 f7       	brne	.-10     	; 0x42c <__do_copy_data+0x10>

00000436 <__do_clear_bss>:
     436:	1d e0       	ldi	r17, 0x0D	; 13
     438:	a6 e5       	ldi	r26, 0x56	; 86
     43a:	b3 e0       	ldi	r27, 0x03	; 3
     43c:	01 c0       	rjmp	.+2      	; 0x440 <.do_clear_bss_start>

0000043e <.do_clear_bss_loop>:
     43e:	1d 92       	st	X+, r1

00000440 <.do_clear_bss_start>:
     440:	a6 3b       	cpi	r26, 0xB6	; 182
     442:	b1 07       	cpc	r27, r17
     444:	e1 f7       	brne	.-8      	; 0x43e <.do_clear_bss_loop>
     446:	33 d0       	rcall	.+102    	; 0x4ae <main>
     448:	0c 94 46 40 	jmp	0x808c	; 0x808c <_exit>

0000044c <__bad_interrupt>:
     44c:	d9 cd       	rjmp	.-1102   	; 0x0 <__vectors>

0000044e <SetupHardware>:

/** Configures the board hardware and chip peripherals for the demo's functionality. */
void SetupHardware(void)
{
	/* Disable watchdog if enabled by bootloader/fuses */
	MCUSR &= ~(1 << WDRF);
     44e:	84 b7       	in	r24, 0x34	; 52
     450:	87 7f       	andi	r24, 0xF7	; 247
     452:	84 bf       	out	0x34, r24	; 52
	wdt_disable();
     454:	88 e1       	ldi	r24, 0x18	; 24
     456:	0f b6       	in	r0, 0x3f	; 63
     458:	f8 94       	cli
     45a:	80 93 60 00 	sts	0x0060, r24
     45e:	10 92 60 00 	sts	0x0060, r1
     462:	0f be       	out	0x3f, r0	; 63
The type of x is clock_div_t.
*/
void clock_prescale_set(clock_div_t __x)
{
    uint8_t __tmp = _BV(CLKPCE);
    __asm__ __volatile__ (
     464:	90 e0       	ldi	r25, 0x00	; 0
     466:	80 e8       	ldi	r24, 0x80	; 128
     468:	0f b6       	in	r0, 0x3f	; 63
     46a:	f8 94       	cli
     46c:	80 93 61 00 	sts	0x0061, r24
     470:	90 93 61 00 	sts	0x0061, r25
     474:	0f be       	out	0x3f, r0	; 63
			 *                         \c SPI_SCK_*, \c SPI_SAMPLE_*, \c SPI_ORDER_* and \c SPI_MODE_* masks.
			 */
			static inline void SPI_Init(const uint8_t SPIOptions)
			{
				/* Prevent high rise times on PB.0 (/SS) from forcing a change to SPI slave mode */
				DDRB  |= (1 << 0);
     476:	20 9a       	sbi	0x04, 0	; 4
				PORTB |= (1 << 0);
     478:	28 9a       	sbi	0x05, 0	; 5

				DDRB  |=  ((1 << 1) | (1 << 2));
     47a:	84 b1       	in	r24, 0x04	; 4
     47c:	86 60       	ori	r24, 0x06	; 6
     47e:	84 b9       	out	0x04, r24	; 4
				DDRB  &= ~(1 << 3);
     480:	23 98       	cbi	0x04, 3	; 4
				PORTB |=  (1 << 3);
     482:	2b 9a       	sbi	0x05, 3	; 5

				if (SPIOptions & SPI_USE_DOUBLESPEED)
				  SPSR |= (1 << SPI2X);
     484:	8d b5       	in	r24, 0x2d	; 45
     486:	81 60       	ori	r24, 0x01	; 1
     488:	8d bd       	out	0x2d, r24	; 45
				else
				  SPSR &= ~(1 << SPI2X);

				/* Switch /SS to input mode after configuration to allow for forced mode changes */
				DDRB &= ~(1 << 0);
     48a:	20 98       	cbi	0x04, 0	; 4

				SPCR  = ((1 << SPE) | SPIOptions);
     48c:	8c e5       	ldi	r24, 0x5C	; 92
     48e:	8c bd       	out	0x2c, r24	; 44
			/** Initializes the dataflash driver so that commands and data may be sent to an attached dataflash IC.
			 *  The microcontroller's SPI driver MUST be initialized before any of the dataflash commands are used.
			 */
			static inline void Dataflash_Init(void)
			{
				DATAFLASH_CHIPCS_DDR  |= DATAFLASH_CHIPCS_MASK;
     490:	8d b1       	in	r24, 0x0d	; 13
     492:	83 60       	ori	r24, 0x03	; 3
     494:	8d b9       	out	0x0d, r24	; 13
				DATAFLASH_CHIPCS_PORT |= DATAFLASH_CHIPCS_MASK;
     496:	8e b1       	in	r24, 0x0e	; 14
     498:	83 60       	ori	r24, 0x03	; 3
     49a:	8e b9       	out	0x0e, r24	; 14

		/* Inline Functions: */
		#if !defined(__DOXYGEN__)
			static inline void LEDs_Init(void)
			{
				DDRD  |=  LEDS_ALL_LEDS;
     49c:	8a b1       	in	r24, 0x0a	; 10
     49e:	80 6f       	ori	r24, 0xF0	; 240
     4a0:	8a b9       	out	0x0a, r24	; 10
				PORTD &= ~LEDS_ALL_LEDS;
     4a2:	8b b1       	in	r24, 0x0b	; 11
     4a4:	8f 70       	andi	r24, 0x0F	; 15
     4a6:	8b b9       	out	0x0b, r24	; 11

	/* Hardware Initialization */
	SPI_Init(SPI_SPEED_FCPU_DIV_2 | SPI_SCK_LEAD_FALLING | SPI_SAMPLE_TRAILING | SPI_MODE_MASTER);
	Dataflash_Init();
	LEDs_Init();
	USB_Init(USB_MODE_UID);
     4a8:	83 e0       	ldi	r24, 0x03	; 3
     4aa:	0c 94 7a 2d 	jmp	0x5af4	; 0x5af4 <USB_Init>

000004ae <main>:
/** Main program entry point. This routine configures the hardware required by the application, then
 *  enters a loop to run the application tasks in sequence.
 */
int main(void)
{
	SetupHardware();
     4ae:	cf df       	rcall	.-98     	; 0x44e <SetupHardware>
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     4b0:	8b b1       	in	r24, 0x0b	; 11
     4b2:	8f 70       	andi	r24, 0x0F	; 15
     4b4:	80 61       	ori	r24, 0x10	; 16
     4b6:	8b b9       	out	0x0b, r24	; 11
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
     4b8:	78 94       	sei
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
	GlobalInterruptEnable();

	for (;;)
	{
		if (USB_CurrentMode == USB_MODE_Host)
     4ba:	80 91 d9 03 	lds	r24, 0x03D9
     4be:	82 30       	cpi	r24, 0x02	; 2
     4c0:	11 f4       	brne	.+4      	; 0x4c6 <main+0x18>
		  USBHostMode_USBTask();
     4c2:	7e d0       	rcall	.+252    	; 0x5c0 <USBHostMode_USBTask>
     4c4:	01 c0       	rjmp	.+2      	; 0x4c8 <main+0x1a>
		else
		  USBDeviceMode_USBTask();
     4c6:	35 d0       	rcall	.+106    	; 0x532 <USBDeviceMode_USBTask>

		USB_USBTask();
     4c8:	0e 94 a6 32 	call	0x654c	; 0x654c <USB_USBTask>
	}
     4cc:	f6 cf       	rjmp	.-20     	; 0x4ba <main+0xc>

000004ce <CALLBACK_USB_GetDescriptor>:
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
     4ce:	92 30       	cpi	r25, 0x02	; 2
     4d0:	29 f0       	breq	.+10     	; 0x4dc <CALLBACK_USB_GetDescriptor+0xe>
     4d2:	93 30       	cpi	r25, 0x03	; 3
     4d4:	41 f0       	breq	.+16     	; 0x4e6 <CALLBACK_USB_GetDescriptor+0x18>
     4d6:	91 30       	cpi	r25, 0x01	; 1
     4d8:	e9 f4       	brne	.+58     	; 0x514 <CALLBACK_USB_GetDescriptor+0x46>
     4da:	17 c0       	rjmp	.+46     	; 0x50a <CALLBACK_USB_GetDescriptor+0x3c>
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
			Size    = sizeof(USB_Descriptor_Configuration_t);
     4dc:	2d e5       	ldi	r18, 0x5D	; 93
     4de:	30 e0       	ldi	r19, 0x00	; 0
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
			break;
		case DTYPE_Configuration:
			Address = &ConfigurationDescriptor;
     4e0:	ea ea       	ldi	r30, 0xAA	; 170
     4e2:	f0 e0       	ldi	r31, 0x00	; 0
			Size    = sizeof(USB_Descriptor_Configuration_t);
			break;
     4e4:	1b c0       	rjmp	.+54     	; 0x51c <CALLBACK_USB_GetDescriptor+0x4e>
		case DTYPE_String:
			switch (DescriptorNumber)
     4e6:	81 30       	cpi	r24, 0x01	; 1
     4e8:	41 f0       	breq	.+16     	; 0x4fa <CALLBACK_USB_GetDescriptor+0x2c>
     4ea:	81 30       	cpi	r24, 0x01	; 1
     4ec:	18 f0       	brcs	.+6      	; 0x4f4 <CALLBACK_USB_GetDescriptor+0x26>
     4ee:	82 30       	cpi	r24, 0x02	; 2
     4f0:	89 f4       	brne	.+34     	; 0x514 <CALLBACK_USB_GetDescriptor+0x46>
     4f2:	06 c0       	rjmp	.+12     	; 0x500 <CALLBACK_USB_GetDescriptor+0x32>
			{
				case 0x00:
					Address = &LanguageString;
					Size    = pgm_read_byte(&LanguageString.Header.Size);
     4f4:	e7 e0       	ldi	r30, 0x07	; 7
     4f6:	f1 e0       	ldi	r31, 0x01	; 1
     4f8:	05 c0       	rjmp	.+10     	; 0x504 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x01:
					Address = &ManufacturerString;
					Size    = pgm_read_byte(&ManufacturerString.Header.Size);
     4fa:	eb e0       	ldi	r30, 0x0B	; 11
     4fc:	f1 e0       	ldi	r31, 0x01	; 1
     4fe:	02 c0       	rjmp	.+4      	; 0x504 <CALLBACK_USB_GetDescriptor+0x36>
					break;
				case 0x02:
					Address = &ProductString;
					Size    = pgm_read_byte(&ProductString.Header.Size);
     500:	e5 e2       	ldi	r30, 0x25	; 37
     502:	f1 e0       	ldi	r31, 0x01	; 1
     504:	24 91       	lpm	r18, Z+
     506:	30 e0       	ldi	r19, 0x00	; 0
					break;
     508:	09 c0       	rjmp	.+18     	; 0x51c <CALLBACK_USB_GetDescriptor+0x4e>

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
			Size    = sizeof(USB_Descriptor_Device_t);
     50a:	22 e1       	ldi	r18, 0x12	; 18
     50c:	30 e0       	ldi	r19, 0x00	; 0
	uint16_t    Size    = NO_DESCRIPTOR;

	switch (DescriptorType)
	{
		case DTYPE_Device:
			Address = &DeviceDescriptor;
     50e:	e8 e9       	ldi	r30, 0x98	; 152
     510:	f0 e0       	ldi	r31, 0x00	; 0
     512:	04 c0       	rjmp	.+8      	; 0x51c <CALLBACK_USB_GetDescriptor+0x4e>
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
	uint16_t    Size    = NO_DESCRIPTOR;
     514:	20 e0       	ldi	r18, 0x00	; 0
     516:	30 e0       	ldi	r19, 0x00	; 0
                                    const void** const DescriptorAddress)
{
	const uint8_t  DescriptorType   = (wValue >> 8);
	const uint8_t  DescriptorNumber = (wValue & 0xFF);

	const void* Address = NULL;
     518:	e0 e0       	ldi	r30, 0x00	; 0
     51a:	f0 e0       	ldi	r31, 0x00	; 0
			}

			break;
	}

	*DescriptorAddress = Address;
     51c:	da 01       	movw	r26, r20
     51e:	11 96       	adiw	r26, 0x01	; 1
     520:	fc 93       	st	X, r31
     522:	ee 93       	st	-X, r30
	return Size;
}
     524:	c9 01       	movw	r24, r18
     526:	08 95       	ret

00000528 <LEDs_SetAllLEDs>:
     528:	9b b1       	in	r25, 0x0b	; 11
     52a:	9f 70       	andi	r25, 0x0F	; 15
     52c:	98 2b       	or	r25, r24
     52e:	9b b9       	out	0x0b, r25	; 11
			}
     530:	08 95       	ret

00000532 <USBDeviceMode_USBTask>:
/** USB device mode management task. This function manages the Mass Storage Device class driver when the device is
 *  initialized in USB device mode.
 */
void USBDeviceMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Device)
     532:	80 91 d9 03 	lds	r24, 0x03D9
     536:	81 30       	cpi	r24, 0x01	; 1
     538:	49 f4       	brne	.+18     	; 0x54c <USBDeviceMode_USBTask+0x1a>
	  return;

	uIPManagement_ManageNetwork();
     53a:	fc d5       	rcall	.+3064   	; 0x1134 <uIPManagement_ManageNetwork>

	RNDIS_Device_USBTask(&Ethernet_RNDIS_Interface_Device);
     53c:	83 e1       	ldi	r24, 0x13	; 19
     53e:	91 e0       	ldi	r25, 0x01	; 1
     540:	0e 94 68 37 	call	0x6ed0	; 0x6ed0 <RNDIS_Device_USBTask>
	MS_Device_USBTask(&Disk_MS_Interface);
     544:	81 eb       	ldi	r24, 0xB1	; 177
     546:	91 e0       	ldi	r25, 0x01	; 1
     548:	0c 94 32 33 	jmp	0x6664	; 0x6664 <MS_Device_USBTask>
     54c:	08 95       	ret

0000054e <EVENT_USB_Device_Connect>:
}

/** Event handler for the library USB Connection event. */
void EVENT_USB_Device_Connect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     54e:	80 e3       	ldi	r24, 0x30	; 48
     550:	eb df       	rcall	.-42     	; 0x528 <LEDs_SetAllLEDs>

	uIPManagement_Init();
}
     552:	93 c5       	rjmp	.+2854   	; 0x107a <uIPManagement_Init>

00000554 <EVENT_USB_Device_Disconnect>:

/** Event handler for the library USB Disconnection event. */
void EVENT_USB_Device_Disconnect(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     554:	80 e1       	ldi	r24, 0x10	; 16
}
     556:	e8 cf       	rjmp	.-48     	; 0x528 <LEDs_SetAllLEDs>

00000558 <EVENT_USB_Device_ConfigurationChanged>:

/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
     558:	1f 93       	push	r17
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     55a:	83 e1       	ldi	r24, 0x13	; 19
     55c:	91 e0       	ldi	r25, 0x01	; 1
     55e:	0e 94 41 37 	call	0x6e82	; 0x6e82 <RNDIS_Device_ConfigureEndpoints>
     562:	18 2f       	mov	r17, r24
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     564:	81 eb       	ldi	r24, 0xB1	; 177
     566:	91 e0       	ldi	r25, 0x01	; 1
     568:	0e 94 14 33 	call	0x6628	; 0x6628 <MS_Device_ConfigureEndpoints>
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     56c:	21 2f       	mov	r18, r17
     56e:	30 e0       	ldi	r19, 0x00	; 0
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);
     570:	90 e0       	ldi	r25, 0x00	; 0
/** Event handler for the library USB Configuration Changed event. */
void EVENT_USB_Device_ConfigurationChanged(void)
{
	bool ConfigSuccess = true;

	ConfigSuccess &= RNDIS_Device_ConfigureEndpoints(&Ethernet_RNDIS_Interface_Device);
     572:	28 23       	and	r18, r24
     574:	39 23       	and	r19, r25
	ConfigSuccess &= MS_Device_ConfigureEndpoints(&Disk_MS_Interface);

	LEDs_SetAllLEDs(ConfigSuccess ? LEDMASK_USB_READY : LEDMASK_USB_ERROR);
     576:	20 ff       	sbrs	r18, 0
     578:	02 c0       	rjmp	.+4      	; 0x57e <EVENT_USB_Device_ConfigurationChanged+0x26>
     57a:	80 e2       	ldi	r24, 0x20	; 32
     57c:	01 c0       	rjmp	.+2      	; 0x580 <EVENT_USB_Device_ConfigurationChanged+0x28>
     57e:	80 e9       	ldi	r24, 0x90	; 144
     580:	d3 df       	rcall	.-90     	; 0x528 <LEDs_SetAllLEDs>
}
     582:	1f 91       	pop	r17
     584:	08 95       	ret

00000586 <EVENT_USB_Device_ControlRequest>:

/** Event handler for the library USB Control Request reception event. */
void EVENT_USB_Device_ControlRequest(void)
{
	RNDIS_Device_ProcessControlRequest(&Ethernet_RNDIS_Interface_Device);
     586:	83 e1       	ldi	r24, 0x13	; 19
     588:	91 e0       	ldi	r25, 0x01	; 1
     58a:	0e 94 65 34 	call	0x68ca	; 0x68ca <RNDIS_Device_ProcessControlRequest>
	MS_Device_ProcessControlRequest(&Disk_MS_Interface);
     58e:	81 eb       	ldi	r24, 0xB1	; 177
     590:	91 e0       	ldi	r25, 0x01	; 1
     592:	0c 94 d5 32 	jmp	0x65aa	; 0x65aa <MS_Device_ProcessControlRequest>

00000596 <CALLBACK_MS_Device_SCSICommandReceived>:
/** Mass Storage class driver callback function the reception of SCSI commands from the host, which must be processed.
 *
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface configuration structure being referenced
 */
bool CALLBACK_MS_Device_SCSICommandReceived(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     596:	1f 93       	push	r17
     598:	cf 93       	push	r28
     59a:	df 93       	push	r29
     59c:	ec 01       	movw	r28, r24
	bool CommandSuccess;

	LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
     59e:	80 ed       	ldi	r24, 0xD0	; 208
     5a0:	c3 df       	rcall	.-122    	; 0x528 <LEDs_SetAllLEDs>
	CommandSuccess = SCSI_DecodeSCSICommand(MSInterfaceInfo);
     5a2:	ce 01       	movw	r24, r28
     5a4:	ef d0       	rcall	.+478    	; 0x784 <SCSI_DecodeSCSICommand>
     5a6:	18 2f       	mov	r17, r24
	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     5a8:	80 e2       	ldi	r24, 0x20	; 32
     5aa:	be df       	rcall	.-132    	; 0x528 <LEDs_SetAllLEDs>

	return CommandSuccess;
}
     5ac:	81 2f       	mov	r24, r17
     5ae:	df 91       	pop	r29
     5b0:	cf 91       	pop	r28
     5b2:	1f 91       	pop	r17
     5b4:	08 95       	ret

000005b6 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
     5b6:	9b b1       	in	r25, 0x0b	; 11
     5b8:	9f 70       	andi	r25, 0x0F	; 15
     5ba:	98 2b       	or	r25, r24
     5bc:	9b b9       	out	0x0b, r25	; 11
			}
     5be:	08 95       	ret

000005c0 <USBHostMode_USBTask>:
/** USB host mode management task. This function manages the RNDIS Host class driver and uIP stack when the device is
 *  initialized in USB host mode.
 */
void USBHostMode_USBTask(void)
{
	if (USB_CurrentMode != USB_MODE_Host)
     5c0:	80 91 d9 03 	lds	r24, 0x03D9
     5c4:	82 30       	cpi	r24, 0x02	; 2
     5c6:	09 f4       	brne	.+2      	; 0x5ca <USBHostMode_USBTask+0xa>
	  return;

	uIPManagement_ManageNetwork();
     5c8:	b5 c5       	rjmp	.+2922   	; 0x1134 <uIPManagement_ManageNetwork>
     5ca:	08 95       	ret

000005cc <EVENT_USB_Host_DeviceAttached>:
/** Event handler for the USB_DeviceAttached event. This indicates that a device has been attached to the host, and
 *  starts the library USB task to begin the enumeration and USB management process.
 */
void EVENT_USB_Host_DeviceAttached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     5cc:	80 e3       	ldi	r24, 0x30	; 48
}
     5ce:	f3 cf       	rjmp	.-26     	; 0x5b6 <LEDs_SetAllLEDs>

000005d0 <EVENT_USB_Host_DeviceUnattached>:
/** Event handler for the USB_DeviceUnattached event. This indicates that a device has been removed from the host, and
 *  stops the library USB task management process.
 */
void EVENT_USB_Host_DeviceUnattached(void)
{
	LEDs_SetAllLEDs(LEDMASK_USB_NOTREADY);
     5d0:	80 e1       	ldi	r24, 0x10	; 16
}
     5d2:	f1 cf       	rjmp	.-30     	; 0x5b6 <LEDs_SetAllLEDs>

000005d4 <EVENT_USB_Host_DeviceEnumerationComplete>:

/** Event handler for the USB_DeviceEnumerationComplete event. This indicates that a device has been successfully
 *  enumerated by the host and is now ready to be used by the application.
 */
void EVENT_USB_Host_DeviceEnumerationComplete(void)
{
     5d4:	0f 93       	push	r16
     5d6:	1f 93       	push	r17
     5d8:	df 93       	push	r29
     5da:	cf 93       	push	r28
     5dc:	cd b7       	in	r28, 0x3d	; 61
     5de:	de b7       	in	r29, 0x3e	; 62
     5e0:	c6 50       	subi	r28, 0x06	; 6
     5e2:	d2 40       	sbci	r29, 0x02	; 2
     5e4:	0f b6       	in	r0, 0x3f	; 63
     5e6:	f8 94       	cli
     5e8:	de bf       	out	0x3e, r29	; 62
     5ea:	0f be       	out	0x3f, r0	; 63
     5ec:	cd bf       	out	0x3d, r28	; 61
	LEDs_SetAllLEDs(LEDMASK_USB_ENUMERATING);
     5ee:	80 e3       	ldi	r24, 0x30	; 48
     5f0:	e2 df       	rcall	.-60     	; 0x5b6 <LEDs_SetAllLEDs>

	uint16_t ConfigDescriptorSize;
	uint8_t  ConfigDescriptorData[512];

	if (USB_Host_GetDeviceConfigDescriptor(1, &ConfigDescriptorSize, ConfigDescriptorData,
     5f2:	8e 01       	movw	r16, r28
     5f4:	09 5f       	subi	r16, 0xF9	; 249
     5f6:	1f 4f       	sbci	r17, 0xFF	; 255
     5f8:	81 e0       	ldi	r24, 0x01	; 1
     5fa:	be 01       	movw	r22, r28
     5fc:	6f 5f       	subi	r22, 0xFF	; 255
     5fe:	7f 4f       	sbci	r23, 0xFF	; 255
     600:	a8 01       	movw	r20, r16
     602:	20 e0       	ldi	r18, 0x00	; 0
     604:	32 e0       	ldi	r19, 0x02	; 2
     606:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <USB_Host_GetDeviceConfigDescriptor>
     60a:	88 23       	and	r24, r24
     60c:	71 f4       	brne	.+28     	; 0x62a <EVENT_USB_Host_DeviceEnumerationComplete+0x56>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (RNDIS_Host_ConfigurePipes(&Ethernet_RNDIS_Interface_Host,
     60e:	69 81       	ldd	r22, Y+1	; 0x01
     610:	7a 81       	ldd	r23, Y+2	; 0x02
     612:	8a ee       	ldi	r24, 0xEA	; 234
     614:	91 e0       	ldi	r25, 0x01	; 1
     616:	a8 01       	movw	r20, r16
     618:	0e 94 f8 38 	call	0x71f0	; 0x71f0 <RNDIS_Host_ConfigurePipes>
     61c:	88 23       	and	r24, r24
     61e:	29 f4       	brne	.+10     	; 0x62a <EVENT_USB_Host_DeviceEnumerationComplete+0x56>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		return;
	}

	if (USB_Host_SetDeviceConfiguration(1) != HOST_SENDCONTROL_Successful)
     620:	81 e0       	ldi	r24, 0x01	; 1
     622:	0e 94 82 32 	call	0x6504	; 0x6504 <USB_Host_SetDeviceConfiguration>
     626:	88 23       	and	r24, r24
     628:	11 f0       	breq	.+4      	; 0x62e <EVENT_USB_Host_DeviceEnumerationComplete+0x5a>
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     62a:	80 e9       	ldi	r24, 0x90	; 144
     62c:	33 c0       	rjmp	.+102    	; 0x694 <EVENT_USB_Host_DeviceEnumerationComplete+0xc0>
		return;
	}

	if (RNDIS_Host_InitializeDevice(&Ethernet_RNDIS_Interface_Host) != HOST_SENDCONTROL_Successful)
     62e:	8a ee       	ldi	r24, 0xEA	; 234
     630:	91 e0       	ldi	r25, 0x01	; 1
     632:	0e 94 ce 39 	call	0x739c	; 0x739c <RNDIS_Host_InitializeDevice>
     636:	88 23       	and	r24, r24
     638:	29 f5       	brne	.+74     	; 0x684 <EVENT_USB_Host_DeviceEnumerationComplete+0xb0>
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	uint32_t PacketFilter = (REMOTE_NDIS_PACKET_DIRECTED | REMOTE_NDIS_PACKET_BROADCAST);
     63a:	89 e0       	ldi	r24, 0x09	; 9
     63c:	90 e0       	ldi	r25, 0x00	; 0
     63e:	a0 e0       	ldi	r26, 0x00	; 0
     640:	b0 e0       	ldi	r27, 0x00	; 0
     642:	8b 83       	std	Y+3, r24	; 0x03
     644:	9c 83       	std	Y+4, r25	; 0x04
     646:	ad 83       	std	Y+5, r26	; 0x05
     648:	be 83       	std	Y+6, r27	; 0x06
	if (RNDIS_Host_SetRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_GEN_CURRENT_PACKET_FILTER,
     64a:	8a ee       	ldi	r24, 0xEA	; 234
     64c:	91 e0       	ldi	r25, 0x01	; 1
     64e:	4e e0       	ldi	r20, 0x0E	; 14
     650:	51 e0       	ldi	r21, 0x01	; 1
     652:	61 e0       	ldi	r22, 0x01	; 1
     654:	70 e0       	ldi	r23, 0x00	; 0
     656:	9e 01       	movw	r18, r28
     658:	2d 5f       	subi	r18, 0xFD	; 253
     65a:	3f 4f       	sbci	r19, 0xFF	; 255
     65c:	04 e0       	ldi	r16, 0x04	; 4
     65e:	10 e0       	ldi	r17, 0x00	; 0
     660:	0e 94 44 3a 	call	0x7488	; 0x7488 <RNDIS_Host_SetRNDISProperty>
     664:	88 23       	and	r24, r24
     666:	71 f4       	brne	.+28     	; 0x684 <EVENT_USB_Host_DeviceEnumerationComplete+0xb0>
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
		USB_Host_SetDeviceConfiguration(0);
		return;
	}

	if (RNDIS_Host_QueryRNDISProperty(&Ethernet_RNDIS_Interface_Host, OID_802_3_CURRENT_ADDRESS,
     668:	8a ee       	ldi	r24, 0xEA	; 234
     66a:	91 e0       	ldi	r25, 0x01	; 1
     66c:	42 e0       	ldi	r20, 0x02	; 2
     66e:	51 e0       	ldi	r21, 0x01	; 1
     670:	61 e0       	ldi	r22, 0x01	; 1
     672:	71 e0       	ldi	r23, 0x01	; 1
     674:	2c ed       	ldi	r18, 0xDC	; 220
     676:	33 e0       	ldi	r19, 0x03	; 3
     678:	06 e0       	ldi	r16, 0x06	; 6
     67a:	10 e0       	ldi	r17, 0x00	; 0
     67c:	0e 94 e3 3a 	call	0x75c6	; 0x75c6 <RNDIS_Host_QueryRNDISProperty>
     680:	88 23       	and	r24, r24
     682:	31 f0       	breq	.+12     	; 0x690 <EVENT_USB_Host_DeviceEnumerationComplete+0xbc>
	                                  &MACAddress, sizeof(MACAddress)) != HOST_SENDCONTROL_Successful)
	{
		LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     684:	80 e9       	ldi	r24, 0x90	; 144
     686:	97 df       	rcall	.-210    	; 0x5b6 <LEDs_SetAllLEDs>
		USB_Host_SetDeviceConfiguration(0);
     688:	80 e0       	ldi	r24, 0x00	; 0
     68a:	0e 94 82 32 	call	0x6504	; 0x6504 <USB_Host_SetDeviceConfiguration>
		return;
     68e:	03 c0       	rjmp	.+6      	; 0x696 <EVENT_USB_Host_DeviceEnumerationComplete+0xc2>
	}

	/* Initialize uIP stack */
	uIPManagement_Init();
     690:	f4 d4       	rcall	.+2536   	; 0x107a <uIPManagement_Init>

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
     692:	80 e2       	ldi	r24, 0x20	; 32
     694:	90 df       	rcall	.-224    	; 0x5b6 <LEDs_SetAllLEDs>
}
     696:	ca 5f       	subi	r28, 0xFA	; 250
     698:	dd 4f       	sbci	r29, 0xFD	; 253
     69a:	0f b6       	in	r0, 0x3f	; 63
     69c:	f8 94       	cli
     69e:	de bf       	out	0x3e, r29	; 62
     6a0:	0f be       	out	0x3f, r0	; 63
     6a2:	cd bf       	out	0x3d, r28	; 61
     6a4:	cf 91       	pop	r28
     6a6:	df 91       	pop	r29
     6a8:	1f 91       	pop	r17
     6aa:	0f 91       	pop	r16
     6ac:	08 95       	ret

000006ae <EVENT_USB_Host_HostError>:

/** Event handler for the USB_HostError event. This indicates that a hardware error occurred while in host mode. */
void EVENT_USB_Host_HostError(const uint8_t ErrorCode)
{
	USB_Disable();
     6ae:	0e 94 d3 2c 	call	0x59a6	; 0x59a6 <USB_Disable>

	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     6b2:	80 e9       	ldi	r24, 0x90	; 144
     6b4:	80 df       	rcall	.-256    	; 0x5b6 <LEDs_SetAllLEDs>
     6b6:	ff cf       	rjmp	.-2      	; 0x6b6 <EVENT_USB_Host_HostError+0x8>

000006b8 <EVENT_USB_Host_DeviceEnumerationFailed>:
/** Event handler for the USB_DeviceEnumerationFailed event. This indicates that a problem occurred while
 *  enumerating an attached USB device.
 */
void EVENT_USB_Host_DeviceEnumerationFailed(const uint8_t ErrorCode, const uint8_t SubErrorCode)
{
	LEDs_SetAllLEDs(LEDMASK_USB_ERROR);
     6b8:	80 e9       	ldi	r24, 0x90	; 144
}
     6ba:	7d cf       	rjmp	.-262    	; 0x5b6 <LEDs_SetAllLEDs>

000006bc <SwapEndian_16>:
			 *
			 *  \return Input data with the individual bytes reversed.
			 */
			static inline uint16_t SwapEndian_16(const uint16_t Word) ATTR_WARN_UNUSED_RESULT ATTR_CONST;
			static inline uint16_t SwapEndian_16(const uint16_t Word)
			{
     6bc:	28 2f       	mov	r18, r24
				Temp = Data.Bytes[0];
				Data.Bytes[0] = Data.Bytes[1];
				Data.Bytes[1] = Temp;

				return Data.Word;
			}
     6be:	89 2f       	mov	r24, r25
     6c0:	92 2f       	mov	r25, r18
     6c2:	08 95       	ret

000006c4 <SCSI_Command_ReadWrite_10>:
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_ReadWrite_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                      const bool IsDataRead)
{
     6c4:	af 92       	push	r10
     6c6:	bf 92       	push	r11
     6c8:	cf 92       	push	r12
     6ca:	df 92       	push	r13
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
     6d2:	1f 93       	push	r17
     6d4:	df 93       	push	r29
     6d6:	cf 93       	push	r28
     6d8:	0f 92       	push	r0
     6da:	cd b7       	in	r28, 0x3d	; 61
     6dc:	de b7       	in	r29, 0x3e	; 62
     6de:	5c 01       	movw	r10, r24

		return false;
	}

	/* Load in the 32-bit block address (SCSI uses big-endian, so have to reverse the byte order) */
	BlockAddress = SwapEndian_32(*(uint32_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[2]);
     6e0:	fc 01       	movw	r30, r24
     6e2:	7b 96       	adiw	r30, 0x1b	; 27

				Temp = Data.Bytes[1];
				Data.Bytes[1] = Data.Bytes[2];
				Data.Bytes[2] = Temp;

				return Data.DWord;
     6e4:	e5 80       	ldd	r14, Z+5	; 0x05
     6e6:	f4 80       	ldd	r15, Z+4	; 0x04
     6e8:	03 81       	ldd	r16, Z+3	; 0x03
     6ea:	12 81       	ldd	r17, Z+2	; 0x02

	/* Load in the 16-bit total blocks (SCSI uses big-endian, so have to reverse the byte order) */
	TotalBlocks  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[7]);
     6ec:	87 81       	ldd	r24, Z+7	; 0x07
     6ee:	90 85       	ldd	r25, Z+8	; 0x08
     6f0:	69 83       	std	Y+1, r22	; 0x01
     6f2:	e4 df       	rcall	.-56     	; 0x6bc <SwapEndian_16>
     6f4:	6c 01       	movw	r12, r24

	/* Check if the block address is outside the maximum allowable value for the LUN */
	if (BlockAddress >= VIRTUAL_MEMORY_BLOCKS)
     6f6:	69 81       	ldd	r22, Y+1	; 0x01
     6f8:	80 e0       	ldi	r24, 0x00	; 0
     6fa:	e8 16       	cp	r14, r24
     6fc:	80 e8       	ldi	r24, 0x80	; 128
     6fe:	f8 06       	cpc	r15, r24
     700:	80 e0       	ldi	r24, 0x00	; 0
     702:	08 07       	cpc	r16, r24
     704:	80 e0       	ldi	r24, 0x00	; 0
     706:	18 07       	cpc	r17, r24
     708:	68 f0       	brcs	.+26     	; 0x724 <SCSI_Command_ReadWrite_10+0x60>
	{
		/* Block address is invalid, update SENSE key and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     70a:	80 91 0c 02 	lds	r24, 0x020C
     70e:	80 7f       	andi	r24, 0xF0	; 240
     710:	85 60       	ori	r24, 0x05	; 5
     712:	80 93 0c 02 	sts	0x020C, r24
     716:	81 e2       	ldi	r24, 0x21	; 33
     718:	80 93 16 02 	sts	0x0216, r24
     71c:	10 92 17 02 	sts	0x0217, r1
		               SCSI_ASENSE_LOGICAL_BLOCK_ADDRESS_OUT_OF_RANGE,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
     720:	80 e0       	ldi	r24, 0x00	; 0
     722:	24 c0       	rjmp	.+72     	; 0x76c <SCSI_Command_ReadWrite_10+0xa8>
	}

	/* Determine if the packet is a READ (10) or WRITE (10) command, call appropriate function */
	if (IsDataRead == DATA_READ)
     724:	66 23       	and	r22, r22
     726:	31 f0       	breq	.+12     	; 0x734 <SCSI_Command_ReadWrite_10+0x70>
	  DataflashManager_ReadBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     728:	c5 01       	movw	r24, r10
     72a:	b8 01       	movw	r22, r16
     72c:	a7 01       	movw	r20, r14
     72e:	96 01       	movw	r18, r12
     730:	d8 d2       	rcall	.+1456   	; 0xce2 <DataflashManager_ReadBlocks>
     732:	05 c0       	rjmp	.+10     	; 0x73e <SCSI_Command_ReadWrite_10+0x7a>
	else
	  DataflashManager_WriteBlocks(MSInterfaceInfo, BlockAddress, TotalBlocks);
     734:	c5 01       	movw	r24, r10
     736:	b8 01       	movw	r22, r16
     738:	a7 01       	movw	r20, r14
     73a:	96 01       	movw	r18, r12
     73c:	97 d1       	rcall	.+814    	; 0xa6c <DataflashManager_WriteBlocks>

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= ((uint32_t)TotalBlocks * VIRTUAL_MEMORY_BLOCK_SIZE);
     73e:	ee 24       	eor	r14, r14
     740:	ff 24       	eor	r15, r15
     742:	89 e0       	ldi	r24, 0x09	; 9
     744:	cc 0c       	add	r12, r12
     746:	dd 1c       	adc	r13, r13
     748:	ee 1c       	adc	r14, r14
     74a:	ff 1c       	adc	r15, r15
     74c:	8a 95       	dec	r24
     74e:	d1 f7       	brne	.-12     	; 0x744 <SCSI_Command_ReadWrite_10+0x80>
     750:	f5 01       	movw	r30, r10
     752:	84 89       	ldd	r24, Z+20	; 0x14
     754:	95 89       	ldd	r25, Z+21	; 0x15
     756:	a6 89       	ldd	r26, Z+22	; 0x16
     758:	b7 89       	ldd	r27, Z+23	; 0x17
     75a:	8c 19       	sub	r24, r12
     75c:	9d 09       	sbc	r25, r13
     75e:	ae 09       	sbc	r26, r14
     760:	bf 09       	sbc	r27, r15
     762:	84 8b       	std	Z+20, r24	; 0x14
     764:	95 8b       	std	Z+21, r25	; 0x15
     766:	a6 8b       	std	Z+22, r26	; 0x16
     768:	b7 8b       	std	Z+23, r27	; 0x17

	return true;
     76a:	81 e0       	ldi	r24, 0x01	; 1
}
     76c:	0f 90       	pop	r0
     76e:	cf 91       	pop	r28
     770:	df 91       	pop	r29
     772:	1f 91       	pop	r17
     774:	0f 91       	pop	r16
     776:	ff 90       	pop	r15
     778:	ef 90       	pop	r14
     77a:	df 90       	pop	r13
     77c:	cf 90       	pop	r12
     77e:	bf 90       	pop	r11
     780:	af 90       	pop	r10
     782:	08 95       	ret

00000784 <SCSI_DecodeSCSICommand>:
 *  \param[in] MSInterfaceInfo  Pointer to the Mass Storage class interface structure that the command is associated with
 *
 *  \return Boolean true if the command completed successfully, false otherwise
 */
bool SCSI_DecodeSCSICommand(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
     784:	cf 92       	push	r12
     786:	df 92       	push	r13
     788:	ef 92       	push	r14
     78a:	ff 92       	push	r15
     78c:	0f 93       	push	r16
     78e:	1f 93       	push	r17
     790:	df 93       	push	r29
     792:	cf 93       	push	r28
     794:	cd b7       	in	r28, 0x3d	; 61
     796:	de b7       	in	r29, 0x3e	; 62
     798:	28 97       	sbiw	r28, 0x08	; 8
     79a:	0f b6       	in	r0, 0x3f	; 63
     79c:	f8 94       	cli
     79e:	de bf       	out	0x3e, r29	; 62
     7a0:	0f be       	out	0x3f, r0	; 63
     7a2:	cd bf       	out	0x3d, r28	; 61
     7a4:	8c 01       	movw	r16, r24
	bool CommandSuccess = false;

	/* Run the appropriate SCSI command hander function based on the passed command */
	switch (MSInterfaceInfo->State.CommandBlock.SCSICommandData[0])
     7a6:	fc 01       	movw	r30, r24
     7a8:	83 8d       	ldd	r24, Z+27	; 0x1b
     7aa:	8d 31       	cpi	r24, 0x1D	; 29
     7ac:	09 f4       	brne	.+2      	; 0x7b0 <SCSI_DecodeSCSICommand+0x2c>
     7ae:	b2 c0       	rjmp	.+356    	; 0x914 <SCSI_DecodeSCSICommand+0x190>
     7b0:	8e 31       	cpi	r24, 0x1E	; 30
     7b2:	78 f4       	brcc	.+30     	; 0x7d2 <SCSI_DecodeSCSICommand+0x4e>
     7b4:	83 30       	cpi	r24, 0x03	; 3
     7b6:	09 f4       	brne	.+2      	; 0x7ba <SCSI_DecodeSCSICommand+0x36>
     7b8:	58 c0       	rjmp	.+176    	; 0x86a <SCSI_DecodeSCSICommand+0xe6>
     7ba:	84 30       	cpi	r24, 0x04	; 4
     7bc:	20 f4       	brcc	.+8      	; 0x7c6 <SCSI_DecodeSCSICommand+0x42>
     7be:	88 23       	and	r24, r24
     7c0:	09 f4       	brne	.+2      	; 0x7c4 <SCSI_DecodeSCSICommand+0x40>
     7c2:	e5 c0       	rjmp	.+458    	; 0x98e <SCSI_DecodeSCSICommand+0x20a>
     7c4:	ea c0       	rjmp	.+468    	; 0x99a <SCSI_DecodeSCSICommand+0x216>
     7c6:	82 31       	cpi	r24, 0x12	; 18
     7c8:	b9 f0       	breq	.+46     	; 0x7f8 <SCSI_DecodeSCSICommand+0x74>
     7ca:	8a 31       	cpi	r24, 0x1A	; 26
     7cc:	09 f0       	breq	.+2      	; 0x7d0 <SCSI_DecodeSCSICommand+0x4c>
     7ce:	e5 c0       	rjmp	.+458    	; 0x99a <SCSI_DecodeSCSICommand+0x216>
     7d0:	c4 c0       	rjmp	.+392    	; 0x95a <SCSI_DecodeSCSICommand+0x1d6>
     7d2:	88 32       	cpi	r24, 0x28	; 40
     7d4:	09 f4       	brne	.+2      	; 0x7d8 <SCSI_DecodeSCSICommand+0x54>
     7d6:	bb c0       	rjmp	.+374    	; 0x94e <SCSI_DecodeSCSICommand+0x1ca>
     7d8:	89 32       	cpi	r24, 0x29	; 41
     7da:	38 f4       	brcc	.+14     	; 0x7ea <SCSI_DecodeSCSICommand+0x66>
     7dc:	8e 31       	cpi	r24, 0x1E	; 30
     7de:	09 f4       	brne	.+2      	; 0x7e2 <SCSI_DecodeSCSICommand+0x5e>
     7e0:	d6 c0       	rjmp	.+428    	; 0x98e <SCSI_DecodeSCSICommand+0x20a>
     7e2:	85 32       	cpi	r24, 0x25	; 37
     7e4:	09 f0       	breq	.+2      	; 0x7e8 <SCSI_DecodeSCSICommand+0x64>
     7e6:	d9 c0       	rjmp	.+434    	; 0x99a <SCSI_DecodeSCSICommand+0x216>
     7e8:	67 c0       	rjmp	.+206    	; 0x8b8 <SCSI_DecodeSCSICommand+0x134>
     7ea:	8a 32       	cpi	r24, 0x2A	; 42
     7ec:	09 f4       	brne	.+2      	; 0x7f0 <SCSI_DecodeSCSICommand+0x6c>
     7ee:	ac c0       	rjmp	.+344    	; 0x948 <SCSI_DecodeSCSICommand+0x1c4>
     7f0:	8f 32       	cpi	r24, 0x2F	; 47
     7f2:	09 f0       	breq	.+2      	; 0x7f6 <SCSI_DecodeSCSICommand+0x72>
     7f4:	d2 c0       	rjmp	.+420    	; 0x99a <SCSI_DecodeSCSICommand+0x216>
     7f6:	cb c0       	rjmp	.+406    	; 0x98e <SCSI_DecodeSCSICommand+0x20a>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
     7f8:	f8 01       	movw	r30, r16
     7fa:	86 8d       	ldd	r24, Z+30	; 0x1e
     7fc:	97 8d       	ldd	r25, Z+31	; 0x1f
     7fe:	5e df       	rcall	.-324    	; 0x6bc <SwapEndian_16>
     800:	6c 01       	movw	r12, r24
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));

	/* Only the standard INQUIRY data is supported, check if any optional INQUIRY bits set */
	if ((MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & ((1 << 0) | (1 << 1))) ||
     802:	f8 01       	movw	r30, r16
     804:	84 8d       	ldd	r24, Z+28	; 0x1c
     806:	90 e0       	ldi	r25, 0x00	; 0
     808:	83 70       	andi	r24, 0x03	; 3
     80a:	90 70       	andi	r25, 0x00	; 0
     80c:	00 97       	sbiw	r24, 0x00	; 0
     80e:	09 f0       	breq	.+2      	; 0x812 <SCSI_DecodeSCSICommand+0x8e>
     810:	85 c0       	rjmp	.+266    	; 0x91c <SCSI_DecodeSCSICommand+0x198>
     812:	85 8d       	ldd	r24, Z+29	; 0x1d
     814:	88 23       	and	r24, r24
     816:	09 f0       	breq	.+2      	; 0x81a <SCSI_DecodeSCSICommand+0x96>
     818:	81 c0       	rjmp	.+258    	; 0x91c <SCSI_DecodeSCSICommand+0x198>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Inquiry(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint16_t AllocationLength  = SwapEndian_16(*(uint16_t*)&MSInterfaceInfo->State.CommandBlock.SCSICommandData[3]);
	uint16_t BytesTransferred  = MIN(AllocationLength, sizeof(InquiryData));
     81a:	76 01       	movw	r14, r12
     81c:	f5 e2       	ldi	r31, 0x25	; 37
     81e:	cf 16       	cp	r12, r31
     820:	d1 04       	cpc	r13, r1
     822:	18 f0       	brcs	.+6      	; 0x82a <SCSI_DecodeSCSICommand+0xa6>
     824:	24 e2       	ldi	r18, 0x24	; 36
     826:	e2 2e       	mov	r14, r18
     828:	f1 2c       	mov	r15, r1
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return false;
	}

	Endpoint_Write_Stream_LE(&InquiryData, BytesTransferred, NULL);
     82a:	8c e1       	ldi	r24, 0x1C	; 28
     82c:	92 e0       	ldi	r25, 0x02	; 2
     82e:	b7 01       	movw	r22, r14
     830:	40 e0       	ldi	r20, 0x00	; 0
     832:	50 e0       	ldi	r21, 0x00	; 0
     834:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>

	/* Pad out remaining bytes with 0x00 */
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     838:	c6 01       	movw	r24, r12
     83a:	8e 19       	sub	r24, r14
     83c:	9f 09       	sbc	r25, r15
     83e:	60 e0       	ldi	r22, 0x00	; 0
     840:	70 e0       	ldi	r23, 0x00	; 0
     842:	0e 94 e4 25 	call	0x4bc8	; 0x4bc8 <Endpoint_Null_Stream>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     846:	80 91 e8 00 	lds	r24, 0x00E8
     84a:	8e 77       	andi	r24, 0x7E	; 126
     84c:	80 93 e8 00 	sts	0x00E8, r24

	/* Finalize the stream transfer to send the last packet */
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     850:	97 01       	movw	r18, r14
     852:	40 e0       	ldi	r20, 0x00	; 0
     854:	50 e0       	ldi	r21, 0x00	; 0
     856:	f8 01       	movw	r30, r16
     858:	84 89       	ldd	r24, Z+20	; 0x14
     85a:	95 89       	ldd	r25, Z+21	; 0x15
     85c:	a6 89       	ldd	r26, Z+22	; 0x16
     85e:	b7 89       	ldd	r27, Z+23	; 0x17
     860:	82 1b       	sub	r24, r18
     862:	93 0b       	sbc	r25, r19
     864:	a4 0b       	sbc	r26, r20
     866:	b5 0b       	sbc	r27, r21
     868:	8d c0       	rjmp	.+282    	; 0x984 <SCSI_DecodeSCSICommand+0x200>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Request_Sense(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint8_t  AllocationLength = MSInterfaceInfo->State.CommandBlock.SCSICommandData[4];
     86a:	f8 01       	movw	r30, r16
     86c:	c7 8c       	ldd	r12, Z+31	; 0x1f
	uint8_t  BytesTransferred = MIN(AllocationLength, sizeof(SenseData));
     86e:	ec 2c       	mov	r14, r12
     870:	fc 2d       	mov	r31, r12
     872:	f3 31       	cpi	r31, 0x13	; 19
     874:	10 f0       	brcs	.+4      	; 0x87a <SCSI_DecodeSCSICommand+0xf6>
     876:	92 e1       	ldi	r25, 0x12	; 18
     878:	e9 2e       	mov	r14, r25

	Endpoint_Write_Stream_LE(&SenseData, BytesTransferred, NULL);
     87a:	8a e0       	ldi	r24, 0x0A	; 10
     87c:	92 e0       	ldi	r25, 0x02	; 2
     87e:	6e 2d       	mov	r22, r14
     880:	70 e0       	ldi	r23, 0x00	; 0
     882:	40 e0       	ldi	r20, 0x00	; 0
     884:	50 e0       	ldi	r21, 0x00	; 0
     886:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>
	Endpoint_Null_Stream((AllocationLength - BytesTransferred), NULL);
     88a:	8c 2d       	mov	r24, r12
     88c:	90 e0       	ldi	r25, 0x00	; 0
     88e:	8e 19       	sub	r24, r14
     890:	91 09       	sbc	r25, r1
     892:	60 e0       	ldi	r22, 0x00	; 0
     894:	70 e0       	ldi	r23, 0x00	; 0
     896:	0e 94 e4 25 	call	0x4bc8	; 0x4bc8 <Endpoint_Null_Stream>
     89a:	80 91 e8 00 	lds	r24, 0x00E8
     89e:	8e 77       	andi	r24, 0x7E	; 126
     8a0:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= BytesTransferred;
     8a4:	f8 01       	movw	r30, r16
     8a6:	84 89       	ldd	r24, Z+20	; 0x14
     8a8:	95 89       	ldd	r25, Z+21	; 0x15
     8aa:	a6 89       	ldd	r26, Z+22	; 0x16
     8ac:	b7 89       	ldd	r27, Z+23	; 0x17
     8ae:	8e 19       	sub	r24, r14
     8b0:	91 09       	sbc	r25, r1
     8b2:	a1 09       	sbc	r26, r1
     8b4:	b1 09       	sbc	r27, r1
     8b6:	66 c0       	rjmp	.+204    	; 0x984 <SCSI_DecodeSCSICommand+0x200>
 *
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Read_Capacity_10(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	uint32_t LastBlockAddressInLUN = (VIRTUAL_MEMORY_BLOCKS - 1);
     8b8:	8f ef       	ldi	r24, 0xFF	; 255
     8ba:	9f e7       	ldi	r25, 0x7F	; 127
     8bc:	a0 e0       	ldi	r26, 0x00	; 0
     8be:	b0 e0       	ldi	r27, 0x00	; 0
     8c0:	89 83       	std	Y+1, r24	; 0x01
     8c2:	9a 83       	std	Y+2, r25	; 0x02
     8c4:	ab 83       	std	Y+3, r26	; 0x03
     8c6:	bc 83       	std	Y+4, r27	; 0x04
	uint32_t MediaBlockSize        = VIRTUAL_MEMORY_BLOCK_SIZE;
     8c8:	80 e0       	ldi	r24, 0x00	; 0
     8ca:	92 e0       	ldi	r25, 0x02	; 2
     8cc:	a0 e0       	ldi	r26, 0x00	; 0
     8ce:	b0 e0       	ldi	r27, 0x00	; 0
     8d0:	8d 83       	std	Y+5, r24	; 0x05
     8d2:	9e 83       	std	Y+6, r25	; 0x06
     8d4:	af 83       	std	Y+7, r26	; 0x07
     8d6:	b8 87       	std	Y+8, r27	; 0x08

	Endpoint_Write_Stream_BE(&LastBlockAddressInLUN, sizeof(LastBlockAddressInLUN), NULL);
     8d8:	ce 01       	movw	r24, r28
     8da:	01 96       	adiw	r24, 0x01	; 1
     8dc:	64 e0       	ldi	r22, 0x04	; 4
     8de:	70 e0       	ldi	r23, 0x00	; 0
     8e0:	40 e0       	ldi	r20, 0x00	; 0
     8e2:	50 e0       	ldi	r21, 0x00	; 0
     8e4:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <Endpoint_Write_Stream_BE>
	Endpoint_Write_Stream_BE(&MediaBlockSize, sizeof(MediaBlockSize), NULL);
     8e8:	ce 01       	movw	r24, r28
     8ea:	05 96       	adiw	r24, 0x05	; 5
     8ec:	64 e0       	ldi	r22, 0x04	; 4
     8ee:	70 e0       	ldi	r23, 0x00	; 0
     8f0:	40 e0       	ldi	r20, 0x00	; 0
     8f2:	50 e0       	ldi	r21, 0x00	; 0
     8f4:	0e 94 86 26 	call	0x4d0c	; 0x4d0c <Endpoint_Write_Stream_BE>
     8f8:	80 91 e8 00 	lds	r24, 0x00E8
     8fc:	8e 77       	andi	r24, 0x7E	; 126
     8fe:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	/* Succeed the command and update the bytes transferred counter */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 8;
     902:	f8 01       	movw	r30, r16
     904:	84 89       	ldd	r24, Z+20	; 0x14
     906:	95 89       	ldd	r25, Z+21	; 0x15
     908:	a6 89       	ldd	r26, Z+22	; 0x16
     90a:	b7 89       	ldd	r27, Z+23	; 0x17
     90c:	08 97       	sbiw	r24, 0x08	; 8
     90e:	a1 09       	sbc	r26, r1
     910:	b1 09       	sbc	r27, r1
     912:	38 c0       	rjmp	.+112    	; 0x984 <SCSI_DecodeSCSICommand+0x200>
 *  \return Boolean true if the command completed successfully, false otherwise.
 */
static bool SCSI_Command_Send_Diagnostic(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	/* Check to see if the SELF TEST bit is not set */
	if (!(MSInterfaceInfo->State.CommandBlock.SCSICommandData[1] & (1 << 2)))
     914:	f8 01       	movw	r30, r16
     916:	84 8d       	ldd	r24, Z+28	; 0x1c
     918:	82 fd       	sbrc	r24, 2
     91a:	08 c0       	rjmp	.+16     	; 0x92c <SCSI_DecodeSCSICommand+0x1a8>
	{
		/* Only self-test supported - update SENSE key and fail the command */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     91c:	80 91 0c 02 	lds	r24, 0x020C
     920:	80 7f       	andi	r24, 0xF0	; 240
     922:	85 60       	ori	r24, 0x05	; 5
     924:	80 93 0c 02 	sts	0x020C, r24
     928:	84 e2       	ldi	r24, 0x24	; 36
     92a:	3e c0       	rjmp	.+124    	; 0x9a8 <SCSI_DecodeSCSICommand+0x224>

		return false;
	}

	/* Check to see if all attached Dataflash ICs are functional */
	if (!(DataflashManager_CheckDataflashOperation()))
     92c:	76 d3       	rcall	.+1772   	; 0x101a <DataflashManager_CheckDataflashOperation>
     92e:	88 23       	and	r24, r24
     930:	71 f5       	brne	.+92     	; 0x98e <SCSI_DecodeSCSICommand+0x20a>
	{
		/* Update SENSE key with a hardware error condition and return command fail */
		SCSI_SET_SENSE(SCSI_SENSE_KEY_HARDWARE_ERROR,
     932:	80 91 0c 02 	lds	r24, 0x020C
     936:	80 7f       	andi	r24, 0xF0	; 240
     938:	84 60       	ori	r24, 0x04	; 4
     93a:	80 93 0c 02 	sts	0x020C, r24
     93e:	10 92 16 02 	sts	0x0216, r1
     942:	10 92 17 02 	sts	0x0217, r1
     946:	3e c0       	rjmp	.+124    	; 0x9c4 <SCSI_DecodeSCSICommand+0x240>
			break;
		case SCSI_CMD_SEND_DIAGNOSTIC:
			CommandSuccess = SCSI_Command_Send_Diagnostic(MSInterfaceInfo);
			break;
		case SCSI_CMD_WRITE_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_WRITE);
     948:	c8 01       	movw	r24, r16
     94a:	60 e0       	ldi	r22, 0x00	; 0
     94c:	02 c0       	rjmp	.+4      	; 0x952 <SCSI_DecodeSCSICommand+0x1ce>
			break;
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
     94e:	c8 01       	movw	r24, r16
     950:	61 e0       	ldi	r22, 0x01	; 1
     952:	b8 de       	rcall	.-656    	; 0x6c4 <SCSI_Command_ReadWrite_10>
		                   SCSI_ASENSEQ_NO_QUALIFIER);
			break;
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
     954:	88 23       	and	r24, r24
     956:	b1 f1       	breq	.+108    	; 0x9c4 <SCSI_DecodeSCSICommand+0x240>
     958:	2a c0       	rjmp	.+84     	; 0x9ae <SCSI_DecodeSCSICommand+0x22a>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     95a:	10 92 f1 00 	sts	0x00F1, r1
     95e:	10 92 f1 00 	sts	0x00F1, r1
     962:	10 92 f1 00 	sts	0x00F1, r1
     966:	10 92 f1 00 	sts	0x00F1, r1
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     96a:	80 91 e8 00 	lds	r24, 0x00E8
     96e:	8e 77       	andi	r24, 0x7E	; 126
     970:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_Write_8(DISK_READ_ONLY ? 0x80 : 0x00);
	Endpoint_Write_8(0x00);
	Endpoint_ClearIN();

	/* Update the bytes transferred counter and succeed the command */
	MSInterfaceInfo->State.CommandBlock.DataTransferLength -= 4;
     974:	f8 01       	movw	r30, r16
     976:	84 89       	ldd	r24, Z+20	; 0x14
     978:	95 89       	ldd	r25, Z+21	; 0x15
     97a:	a6 89       	ldd	r26, Z+22	; 0x16
     97c:	b7 89       	ldd	r27, Z+23	; 0x17
     97e:	04 97       	sbiw	r24, 0x04	; 4
     980:	a1 09       	sbc	r26, r1
     982:	b1 09       	sbc	r27, r1
     984:	84 8b       	std	Z+20, r24	; 0x14
     986:	95 8b       	std	Z+21, r25	; 0x15
     988:	a6 8b       	std	Z+22, r26	; 0x16
     98a:	b7 8b       	std	Z+23, r27	; 0x17
		case SCSI_CMD_READ_10:
			CommandSuccess = SCSI_Command_ReadWrite_10(MSInterfaceInfo, DATA_READ);
			break;
		case SCSI_CMD_MODE_SENSE_6:
			CommandSuccess = SCSI_Command_ModeSense_6(MSInterfaceInfo);
			break;
     98c:	10 c0       	rjmp	.+32     	; 0x9ae <SCSI_DecodeSCSICommand+0x22a>
		case SCSI_CMD_TEST_UNIT_READY:
		case SCSI_CMD_PREVENT_ALLOW_MEDIUM_REMOVAL:
		case SCSI_CMD_VERIFY_10:
			/* These commands should just succeed, no handling required */
			CommandSuccess = true;
			MSInterfaceInfo->State.CommandBlock.DataTransferLength = 0;
     98e:	f8 01       	movw	r30, r16
     990:	14 8a       	std	Z+20, r1	; 0x14
     992:	15 8a       	std	Z+21, r1	; 0x15
     994:	16 8a       	std	Z+22, r1	; 0x16
     996:	17 8a       	std	Z+23, r1	; 0x17
     998:	0a c0       	rjmp	.+20     	; 0x9ae <SCSI_DecodeSCSICommand+0x22a>
			break;
		default:
			/* Update the SENSE key to reflect the invalid command */
			SCSI_SET_SENSE(SCSI_SENSE_KEY_ILLEGAL_REQUEST,
     99a:	80 91 0c 02 	lds	r24, 0x020C
     99e:	80 7f       	andi	r24, 0xF0	; 240
     9a0:	85 60       	ori	r24, 0x05	; 5
     9a2:	80 93 0c 02 	sts	0x020C, r24
     9a6:	80 e2       	ldi	r24, 0x20	; 32
     9a8:	80 93 16 02 	sts	0x0216, r24
     9ac:	ca cf       	rjmp	.-108    	; 0x942 <SCSI_DecodeSCSICommand+0x1be>
	}

	/* Check if command was successfully processed */
	if (CommandSuccess)
	{
		SCSI_SET_SENSE(SCSI_SENSE_KEY_GOOD,
     9ae:	80 91 0c 02 	lds	r24, 0x020C
     9b2:	80 7f       	andi	r24, 0xF0	; 240
     9b4:	80 93 0c 02 	sts	0x020C, r24
     9b8:	10 92 16 02 	sts	0x0216, r1
     9bc:	10 92 17 02 	sts	0x0217, r1
		               SCSI_ASENSE_NO_ADDITIONAL_INFORMATION,
		               SCSI_ASENSEQ_NO_QUALIFIER);

		return true;
     9c0:	81 e0       	ldi	r24, 0x01	; 1
     9c2:	01 c0       	rjmp	.+2      	; 0x9c6 <SCSI_DecodeSCSICommand+0x242>
	}

	return false;
     9c4:	80 e0       	ldi	r24, 0x00	; 0
}
     9c6:	28 96       	adiw	r28, 0x08	; 8
     9c8:	0f b6       	in	r0, 0x3f	; 63
     9ca:	f8 94       	cli
     9cc:	de bf       	out	0x3e, r29	; 62
     9ce:	0f be       	out	0x3f, r0	; 63
     9d0:	cd bf       	out	0x3d, r28	; 61
     9d2:	cf 91       	pop	r28
     9d4:	df 91       	pop	r29
     9d6:	1f 91       	pop	r17
     9d8:	0f 91       	pop	r16
     9da:	ff 90       	pop	r15
     9dc:	ef 90       	pop	r14
     9de:	df 90       	pop	r13
     9e0:	cf 90       	pop	r12
     9e2:	08 95       	ret

000009e4 <Dataflash_SelectChipFromPage>:
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     9e4:	2e b1       	in	r18, 0x0e	; 14
     9e6:	23 60       	ori	r18, 0x03	; 3
     9e8:	2e b9       	out	0x0e, r18	; 14
			 */
			static inline void Dataflash_SelectChipFromPage(const uint16_t PageAddress)
			{
				Dataflash_DeselectChip();

				if (PageAddress >= (DATAFLASH_PAGES * DATAFLASH_TOTALCHIPS))
     9ea:	20 e4       	ldi	r18, 0x40	; 64
     9ec:	80 30       	cpi	r24, 0x00	; 0
     9ee:	92 07       	cpc	r25, r18
     9f0:	58 f4       	brcc	.+22     	; 0xa08 <Dataflash_SelectChipFromPage+0x24>
				  return;

				#if (DATAFLASH_TOTALCHIPS == 2)
					if (PageAddress & 0x01)
     9f2:	80 ff       	sbrs	r24, 0
     9f4:	05 c0       	rjmp	.+10     	; 0xa00 <Dataflash_SelectChipFromPage+0x1c>
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     9f6:	8e b1       	in	r24, 0x0e	; 14
     9f8:	83 60       	ori	r24, 0x03	; 3
     9fa:	8d 7f       	andi	r24, 0xFD	; 253
     9fc:	8e b9       	out	0x0e, r24	; 14
     9fe:	08 95       	ret
     a00:	8e b1       	in	r24, 0x0e	; 14
     a02:	83 60       	ori	r24, 0x03	; 3
     a04:	8e 7f       	andi	r24, 0xFE	; 254
     a06:	8e b9       	out	0x0e, r24	; 14
     a08:	08 95       	ret

00000a0a <Dataflash_ToggleSelectedChipCS>:
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     a0a:	8e b1       	in	r24, 0x0e	; 14
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     a0c:	9e b1       	in	r25, 0x0e	; 14
     a0e:	93 60       	ori	r25, 0x03	; 3
     a10:	9e b9       	out	0x0e, r25	; 14
     a12:	9e b1       	in	r25, 0x0e	; 14
     a14:	8c 6f       	ori	r24, 0xFC	; 252
     a16:	93 60       	ori	r25, 0x03	; 3
     a18:	89 23       	and	r24, r25
     a1a:	8e b9       	out	0x0e, r24	; 14
			{
				uint8_t SelectedChipMask = Dataflash_GetSelectedChip();

				Dataflash_DeselectChip();
				Dataflash_SelectChip(SelectedChipMask);
			}
     a1c:	08 95       	ret

00000a1e <Dataflash_WaitWhileBusy>:
			/** Spin-loops while the currently selected dataflash is busy executing a command, such as a main
			 *  memory page program or main memory to buffer transfer.
			 */
			static inline void Dataflash_WaitWhileBusy(void)
			{
				Dataflash_ToggleSelectedChipCS();
     a1e:	f5 df       	rcall	.-22     	; 0xa0a <Dataflash_ToggleSelectedChipCS>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a20:	87 ed       	ldi	r24, 0xD7	; 215
     a22:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a24:	0d b4       	in	r0, 0x2d	; 45
     a26:	07 fe       	sbrs	r0, 7
     a28:	fd cf       	rjmp	.-6      	; 0xa24 <Dataflash_WaitWhileBusy+0x6>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     a2a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     a2c:	0d b4       	in	r0, 0x2d	; 45
     a2e:	07 fe       	sbrs	r0, 7
     a30:	fd cf       	rjmp	.-6      	; 0xa2c <Dataflash_WaitWhileBusy+0xe>
				Dataflash_SendByte(DF_CMD_GETSTATUS);
				while (!(Dataflash_ReceiveByte() & DF_STATUS_READY));
     a32:	0e b4       	in	r0, 0x2e	; 46
     a34:	07 fe       	sbrs	r0, 7
     a36:	f9 cf       	rjmp	.-14     	; 0xa2a <Dataflash_WaitWhileBusy+0xc>
				Dataflash_ToggleSelectedChipCS();
			}
     a38:	e8 cf       	rjmp	.-48     	; 0xa0a <Dataflash_ToggleSelectedChipCS>

00000a3a <Dataflash_SendAddressBytes>:
			 */
			static inline void Dataflash_SendAddressBytes(uint16_t PageAddress,
			                                              const uint16_t BufferByte)
			{
				#if (DATAFLASH_TOTALCHIPS == 2)
					PageAddress >>= 1;
     a3a:	9c 01       	movw	r18, r24
     a3c:	36 95       	lsr	r19
     a3e:	27 95       	ror	r18
				#endif
				
				Dataflash_SendByte(PageAddress >> 5);
     a40:	36 e0       	ldi	r19, 0x06	; 6
     a42:	96 95       	lsr	r25
     a44:	87 95       	ror	r24
     a46:	3a 95       	dec	r19
     a48:	e1 f7       	brne	.-8      	; 0xa42 <Dataflash_SendAddressBytes+0x8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a4a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     a4c:	0d b4       	in	r0, 0x2d	; 45
     a4e:	07 fe       	sbrs	r0, 7
     a50:	fd cf       	rjmp	.-6      	; 0xa4c <Dataflash_SendAddressBytes+0x12>
				Dataflash_SendByte((PageAddress << 3) | (BufferByte >> 8));
     a52:	22 0f       	add	r18, r18
     a54:	22 0f       	add	r18, r18
     a56:	22 0f       	add	r18, r18
     a58:	27 2b       	or	r18, r23
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a5a:	2e bd       	out	0x2e, r18	; 46
				while (!(SPSR & (1 << SPIF)));
     a5c:	0d b4       	in	r0, 0x2d	; 45
     a5e:	07 fe       	sbrs	r0, 7
     a60:	fd cf       	rjmp	.-6      	; 0xa5c <Dataflash_SendAddressBytes+0x22>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     a62:	6e bd       	out	0x2e, r22	; 46
				while (!(SPSR & (1 << SPIF)));
     a64:	0d b4       	in	r0, 0x2d	; 45
     a66:	07 fe       	sbrs	r0, 7
     a68:	fd cf       	rjmp	.-6      	; 0xa64 <Dataflash_SendAddressBytes+0x2a>
				Dataflash_SendByte(BufferByte);
			}
     a6a:	08 95       	ret

00000a6c <DataflashManager_WriteBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to write
 */
void DataflashManager_WriteBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
     a6c:	6f 92       	push	r6
     a6e:	7f 92       	push	r7
     a70:	9f 92       	push	r9
     a72:	af 92       	push	r10
     a74:	bf 92       	push	r11
     a76:	cf 92       	push	r12
     a78:	df 92       	push	r13
     a7a:	ef 92       	push	r14
     a7c:	ff 92       	push	r15
     a7e:	0f 93       	push	r16
     a80:	1f 93       	push	r17
     a82:	df 93       	push	r29
     a84:	cf 93       	push	r28
     a86:	0f 92       	push	r0
     a88:	cd b7       	in	r28, 0x3d	; 61
     a8a:	de b7       	in	r29, 0x3e	; 62
     a8c:	6c 01       	movw	r12, r24
     a8e:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     a90:	db 01       	movw	r26, r22
     a92:	ca 01       	movw	r24, r20
     a94:	19 e0       	ldi	r17, 0x09	; 9
     a96:	88 0f       	add	r24, r24
     a98:	99 1f       	adc	r25, r25
     a9a:	aa 1f       	adc	r26, r26
     a9c:	bb 1f       	adc	r27, r27
     a9e:	1a 95       	dec	r17
     aa0:	d1 f7       	brne	.-12     	; 0xa96 <DataflashManager_WriteBlocks+0x2a>
     aa2:	fa e0       	ldi	r31, 0x0A	; 10
     aa4:	b6 95       	lsr	r27
     aa6:	a7 95       	ror	r26
     aa8:	97 95       	ror	r25
     aaa:	87 95       	ror	r24
     aac:	fa 95       	dec	r31
     aae:	d1 f7       	brne	.-12     	; 0xaa4 <DataflashManager_WriteBlocks+0x38>
     ab0:	3c 01       	movw	r6, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     ab2:	8a 01       	movw	r16, r20
     ab4:	10 2f       	mov	r17, r16
     ab6:	00 27       	eor	r16, r16
     ab8:	11 0f       	add	r17, r17
     aba:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
	bool     UsingSecondBuffer   = false;

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     abc:	93 df       	rcall	.-218    	; 0x9e4 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     abe:	83 e5       	ldi	r24, 0x53	; 83
     ac0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ac2:	0d b4       	in	r0, 0x2d	; 45
     ac4:	07 fe       	sbrs	r0, 7
     ac6:	fd cf       	rjmp	.-6      	; 0xac2 <DataflashManager_WriteBlocks+0x56>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
	/* Copy selected dataflash's current page contents to the Dataflash buffer */
	Dataflash_SendByte(DF_CMD_MAINMEMTOBUFF1);
	Dataflash_SendAddressBytes(CurrDFPage, 0);
     ac8:	c3 01       	movw	r24, r6
     aca:	60 e0       	ldi	r22, 0x00	; 0
     acc:	70 e0       	ldi	r23, 0x00	; 0
     ace:	b5 df       	rcall	.-150    	; 0xa3a <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
     ad0:	a6 df       	rcall	.-180    	; 0xa1e <Dataflash_WaitWhileBusy>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ad2:	84 e8       	ldi	r24, 0x84	; 132
     ad4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     ad6:	0d b4       	in	r0, 0x2d	; 45
     ad8:	07 fe       	sbrs	r0, 7
     ada:	fd cf       	rjmp	.-6      	; 0xad6 <DataflashManager_WriteBlocks+0x6a>
#endif

	/* Send the Dataflash buffer write command */
	Dataflash_SendByte(DF_CMD_BUFF1WRITE);
	Dataflash_SendAddressBytes(0, CurrDFPageByte);
     adc:	80 e0       	ldi	r24, 0x00	; 0
     ade:	90 e0       	ldi	r25, 0x00	; 0
     ae0:	b8 01       	movw	r22, r16
     ae2:	ab df       	rcall	.-170    	; 0xa3a <Dataflash_SendAddressBytes>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     ae4:	0e 94 c8 28 	call	0x5190	; 0x5190 <Endpoint_WaitUntilReady>
     ae8:	88 23       	and	r24, r24
     aea:	09 f0       	breq	.+2      	; 0xaee <DataflashManager_WriteBlocks+0x82>
     aec:	eb c0       	rjmp	.+470    	; 0xcc4 <DataflashManager_WriteBlocks+0x258>
                                  const uint32_t BlockAddress,
                                  uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     aee:	74 e0       	ldi	r23, 0x04	; 4
     af0:	16 95       	lsr	r17
     af2:	07 95       	ror	r16
     af4:	7a 95       	dec	r23
     af6:	e1 f7       	brne	.-8      	; 0xaf0 <DataflashManager_WriteBlocks+0x84>
     af8:	90 2f       	mov	r25, r16
     afa:	87 01       	movw	r16, r14
     afc:	65 e0       	ldi	r22, 0x05	; 5
     afe:	00 0f       	add	r16, r16
     b00:	11 1f       	adc	r17, r17
     b02:	6a 95       	dec	r22
     b04:	e1 f7       	brne	.-8      	; 0xafe <DataflashManager_WriteBlocks+0x92>
     b06:	bb 24       	eor	r11, r11
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
				  UsingSecondBuffer = !(UsingSecondBuffer);
     b08:	99 24       	eor	r9, r9
     b0a:	93 94       	inc	r9
     b0c:	bc c0       	rjmp	.+376    	; 0xc86 <DataflashManager_WriteBlocks+0x21a>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     b0e:	50 e2       	ldi	r21, 0x20	; 32
     b10:	a5 2e       	mov	r10, r21
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     b12:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently empty */
			if (!(Endpoint_IsReadWriteAllowed()))
     b16:	85 fd       	sbrc	r24, 5
     b18:	0c c0       	rjmp	.+24     	; 0xb32 <DataflashManager_WriteBlocks+0xc6>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     b1a:	80 91 e8 00 	lds	r24, 0x00E8
     b1e:	8b 77       	andi	r24, 0x7B	; 123
     b20:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the current endpoint bank */
				Endpoint_ClearOUT();

				/* Wait until the host has sent another packet */
				if (Endpoint_WaitUntilReady())
     b24:	99 83       	std	Y+1, r25	; 0x01
     b26:	0e 94 c8 28 	call	0x5190	; 0x5190 <Endpoint_WaitUntilReady>
     b2a:	99 81       	ldd	r25, Y+1	; 0x01
     b2c:	88 23       	and	r24, r24
     b2e:	09 f0       	breq	.+2      	; 0xb32 <DataflashManager_WriteBlocks+0xc6>
     b30:	c9 c0       	rjmp	.+402    	; 0xcc4 <DataflashManager_WriteBlocks+0x258>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     b32:	90 34       	cpi	r25, 0x40	; 64
     b34:	09 f0       	breq	.+2      	; 0xb38 <DataflashManager_WriteBlocks+0xcc>
     b36:	3a c0       	rjmp	.+116    	; 0xbac <DataflashManager_WriteBlocks+0x140>
			{
				/* Write the Dataflash buffer contents back to the Dataflash page */
				Dataflash_WaitWhileBusy();
     b38:	72 df       	rcall	.-284    	; 0xa1e <Dataflash_WaitWhileBusy>
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     b3a:	bb 20       	and	r11, r11
     b3c:	11 f0       	breq	.+4      	; 0xb42 <DataflashManager_WriteBlocks+0xd6>
     b3e:	86 e8       	ldi	r24, 0x86	; 134
     b40:	01 c0       	rjmp	.+2      	; 0xb44 <DataflashManager_WriteBlocks+0xd8>
     b42:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b44:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b46:	0d b4       	in	r0, 0x2d	; 45
     b48:	07 fe       	sbrs	r0, 7
     b4a:	fd cf       	rjmp	.-6      	; 0xb46 <DataflashManager_WriteBlocks+0xda>
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     b4c:	c3 01       	movw	r24, r6
     b4e:	60 e0       	ldi	r22, 0x00	; 0
     b50:	70 e0       	ldi	r23, 0x00	; 0
     b52:	73 df       	rcall	.-282    	; 0xa3a <Dataflash_SendAddressBytes>

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     b54:	08 94       	sec
     b56:	61 1c       	adc	r6, r1
     b58:	71 1c       	adc	r7, r1
			 *          or a DATAFLASH_CHIPn mask (where n is the chip number).
			 */
			static inline uint8_t Dataflash_GetSelectedChip(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t Dataflash_GetSelectedChip(void)
			{
				return (~DATAFLASH_CHIPCS_PORT & DATAFLASH_CHIPCS_MASK);
     b5a:	8e b1       	in	r24, 0x0e	; 14
     b5c:	80 95       	com	r24
     b5e:	83 70       	andi	r24, 0x03	; 3

				/* Once all the Dataflash ICs have had their first buffers filled, switch buffers to maintain throughput */
				if (Dataflash_GetSelectedChip() == DATAFLASH_CHIP_MASK(DATAFLASH_TOTALCHIPS))
     b60:	82 30       	cpi	r24, 0x02	; 2
     b62:	09 f4       	brne	.+2      	; 0xb66 <DataflashManager_WriteBlocks+0xfa>
				  UsingSecondBuffer = !(UsingSecondBuffer);
     b64:	b9 24       	eor	r11, r9

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     b66:	c3 01       	movw	r24, r6
     b68:	3d df       	rcall	.-390    	; 0x9e4 <Dataflash_SelectChipFromPage>

#if (DATAFLASH_PAGE_SIZE > VIRTUAL_MEMORY_BLOCK_SIZE)
				/* If less than one Dataflash page remaining, copy over the existing page to preserve trailing data */
				if ((TotalBlocks * (VIRTUAL_MEMORY_BLOCK_SIZE >> 4)) < (DATAFLASH_PAGE_SIZE >> 4))
     b6a:	00 34       	cpi	r16, 0x40	; 64
     b6c:	11 05       	cpc	r17, r1
     b6e:	78 f4       	brcc	.+30     	; 0xb8e <DataflashManager_WriteBlocks+0x122>
				{
					/* Copy selected dataflash's current page contents to the Dataflash buffer */
					Dataflash_WaitWhileBusy();
     b70:	56 df       	rcall	.-340    	; 0xa1e <Dataflash_WaitWhileBusy>
					Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_MAINMEMTOBUFF2 : DF_CMD_MAINMEMTOBUFF1);
     b72:	bb 20       	and	r11, r11
     b74:	11 f0       	breq	.+4      	; 0xb7a <DataflashManager_WriteBlocks+0x10e>
     b76:	85 e5       	ldi	r24, 0x55	; 85
     b78:	01 c0       	rjmp	.+2      	; 0xb7c <DataflashManager_WriteBlocks+0x110>
     b7a:	83 e5       	ldi	r24, 0x53	; 83
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b7c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b7e:	0d b4       	in	r0, 0x2d	; 45
     b80:	07 fe       	sbrs	r0, 7
     b82:	fd cf       	rjmp	.-6      	; 0xb7e <DataflashManager_WriteBlocks+0x112>
					Dataflash_SendAddressBytes(CurrDFPage, 0);
     b84:	c3 01       	movw	r24, r6
     b86:	60 e0       	ldi	r22, 0x00	; 0
     b88:	70 e0       	ldi	r23, 0x00	; 0
     b8a:	57 df       	rcall	.-338    	; 0xa3a <Dataflash_SendAddressBytes>
					Dataflash_WaitWhileBusy();
     b8c:	48 df       	rcall	.-368    	; 0xa1e <Dataflash_WaitWhileBusy>
				}
#endif

				/* Send the Dataflash buffer write command */
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2WRITE : DF_CMD_BUFF1WRITE);
     b8e:	bb 20       	and	r11, r11
     b90:	11 f0       	breq	.+4      	; 0xb96 <DataflashManager_WriteBlocks+0x12a>
     b92:	87 e8       	ldi	r24, 0x87	; 135
     b94:	01 c0       	rjmp	.+2      	; 0xb98 <DataflashManager_WriteBlocks+0x12c>
     b96:	84 e8       	ldi	r24, 0x84	; 132
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     b98:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     b9a:	0d b4       	in	r0, 0x2d	; 45
     b9c:	07 fe       	sbrs	r0, 7
     b9e:	fd cf       	rjmp	.-6      	; 0xb9a <DataflashManager_WriteBlocks+0x12e>
				Dataflash_SendAddressBytes(0, 0);
     ba0:	80 e0       	ldi	r24, 0x00	; 0
     ba2:	90 e0       	ldi	r25, 0x00	; 0
     ba4:	60 e0       	ldi	r22, 0x00	; 0
     ba6:	70 e0       	ldi	r23, 0x00	; 0
     ba8:	48 df       	rcall	.-368    	; 0xa3a <Dataflash_SendAddressBytes>
				Dataflash_WaitWhileBusy();
				Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
				Dataflash_SendAddressBytes(CurrDFPage, 0);

				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     baa:	90 e0       	ldi	r25, 0x00	; 0
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
     bac:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bb0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bb2:	0d b4       	in	r0, 0x2d	; 45
     bb4:	07 fe       	sbrs	r0, 7
     bb6:	fd cf       	rjmp	.-6      	; 0xbb2 <DataflashManager_WriteBlocks+0x146>
     bb8:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bbc:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bbe:	0d b4       	in	r0, 0x2d	; 45
     bc0:	07 fe       	sbrs	r0, 7
     bc2:	fd cf       	rjmp	.-6      	; 0xbbe <DataflashManager_WriteBlocks+0x152>
     bc4:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bc8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bca:	0d b4       	in	r0, 0x2d	; 45
     bcc:	07 fe       	sbrs	r0, 7
     bce:	fd cf       	rjmp	.-6      	; 0xbca <DataflashManager_WriteBlocks+0x15e>
     bd0:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bd4:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bd6:	0d b4       	in	r0, 0x2d	; 45
     bd8:	07 fe       	sbrs	r0, 7
     bda:	fd cf       	rjmp	.-6      	; 0xbd6 <DataflashManager_WriteBlocks+0x16a>
     bdc:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     be0:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     be2:	0d b4       	in	r0, 0x2d	; 45
     be4:	07 fe       	sbrs	r0, 7
     be6:	fd cf       	rjmp	.-6      	; 0xbe2 <DataflashManager_WriteBlocks+0x176>
     be8:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bec:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bee:	0d b4       	in	r0, 0x2d	; 45
     bf0:	07 fe       	sbrs	r0, 7
     bf2:	fd cf       	rjmp	.-6      	; 0xbee <DataflashManager_WriteBlocks+0x182>
     bf4:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     bf8:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     bfa:	0d b4       	in	r0, 0x2d	; 45
     bfc:	07 fe       	sbrs	r0, 7
     bfe:	fd cf       	rjmp	.-6      	; 0xbfa <DataflashManager_WriteBlocks+0x18e>
     c00:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c04:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c06:	0d b4       	in	r0, 0x2d	; 45
     c08:	07 fe       	sbrs	r0, 7
     c0a:	fd cf       	rjmp	.-6      	; 0xc06 <DataflashManager_WriteBlocks+0x19a>
     c0c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c10:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c12:	0d b4       	in	r0, 0x2d	; 45
     c14:	07 fe       	sbrs	r0, 7
     c16:	fd cf       	rjmp	.-6      	; 0xc12 <DataflashManager_WriteBlocks+0x1a6>
     c18:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c1c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c1e:	0d b4       	in	r0, 0x2d	; 45
     c20:	07 fe       	sbrs	r0, 7
     c22:	fd cf       	rjmp	.-6      	; 0xc1e <DataflashManager_WriteBlocks+0x1b2>
     c24:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c28:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c2a:	0d b4       	in	r0, 0x2d	; 45
     c2c:	07 fe       	sbrs	r0, 7
     c2e:	fd cf       	rjmp	.-6      	; 0xc2a <DataflashManager_WriteBlocks+0x1be>
     c30:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c34:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c36:	0d b4       	in	r0, 0x2d	; 45
     c38:	07 fe       	sbrs	r0, 7
     c3a:	fd cf       	rjmp	.-6      	; 0xc36 <DataflashManager_WriteBlocks+0x1ca>
     c3c:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c40:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c42:	0d b4       	in	r0, 0x2d	; 45
     c44:	07 fe       	sbrs	r0, 7
     c46:	fd cf       	rjmp	.-6      	; 0xc42 <DataflashManager_WriteBlocks+0x1d6>
     c48:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c4c:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c4e:	0d b4       	in	r0, 0x2d	; 45
     c50:	07 fe       	sbrs	r0, 7
     c52:	fd cf       	rjmp	.-6      	; 0xc4e <DataflashManager_WriteBlocks+0x1e2>
     c54:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c58:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c5a:	0d b4       	in	r0, 0x2d	; 45
     c5c:	07 fe       	sbrs	r0, 7
     c5e:	fd cf       	rjmp	.-6      	; 0xc5a <DataflashManager_WriteBlocks+0x1ee>
     c60:	80 91 f1 00 	lds	r24, 0x00F1
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c64:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c66:	0d b4       	in	r0, 0x2d	; 45
     c68:	07 fe       	sbrs	r0, 7
     c6a:	fd cf       	rjmp	.-6      	; 0xc66 <DataflashManager_WriteBlocks+0x1fa>

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     c6c:	f6 01       	movw	r30, r12
     c6e:	80 ad       	ldd	r24, Z+56	; 0x38
     c70:	88 23       	and	r24, r24
     c72:	41 f5       	brne	.+80     	; 0xcc4 <DataflashManager_WriteBlocks+0x258>
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());
			Dataflash_SendByte(Endpoint_Read_8());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     c74:	9f 5f       	subi	r25, 0xFF	; 255
     c76:	aa 94       	dec	r10
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     c78:	09 f0       	breq	.+2      	; 0xc7c <DataflashManager_WriteBlocks+0x210>
     c7a:	4b cf       	rjmp	.-362    	; 0xb12 <DataflashManager_WriteBlocks+0xa6>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     c7c:	08 94       	sec
     c7e:	e1 08       	sbc	r14, r1
     c80:	f1 08       	sbc	r15, r1
     c82:	00 52       	subi	r16, 0x20	; 32
     c84:	10 40       	sbci	r17, 0x00	; 0

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     c86:	e1 14       	cp	r14, r1
     c88:	f1 04       	cpc	r15, r1
     c8a:	09 f0       	breq	.+2      	; 0xc8e <DataflashManager_WriteBlocks+0x222>
     c8c:	40 cf       	rjmp	.-384    	; 0xb0e <DataflashManager_WriteBlocks+0xa2>
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* Write the Dataflash buffer contents back to the Dataflash page */
	Dataflash_WaitWhileBusy();
     c8e:	c7 de       	rcall	.-626    	; 0xa1e <Dataflash_WaitWhileBusy>
	Dataflash_SendByte(UsingSecondBuffer ? DF_CMD_BUFF2TOMAINMEMWITHERASE : DF_CMD_BUFF1TOMAINMEMWITHERASE);
     c90:	bb 20       	and	r11, r11
     c92:	11 f0       	breq	.+4      	; 0xc98 <DataflashManager_WriteBlocks+0x22c>
     c94:	86 e8       	ldi	r24, 0x86	; 134
     c96:	01 c0       	rjmp	.+2      	; 0xc9a <DataflashManager_WriteBlocks+0x22e>
     c98:	83 e8       	ldi	r24, 0x83	; 131
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     c9a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     c9c:	0d b4       	in	r0, 0x2d	; 45
     c9e:	07 fe       	sbrs	r0, 7
     ca0:	fd cf       	rjmp	.-6      	; 0xc9c <DataflashManager_WriteBlocks+0x230>
	Dataflash_SendAddressBytes(CurrDFPage, 0x00);
     ca2:	c3 01       	movw	r24, r6
     ca4:	60 e0       	ldi	r22, 0x00	; 0
     ca6:	70 e0       	ldi	r23, 0x00	; 0
     ca8:	c8 de       	rcall	.-624    	; 0xa3a <Dataflash_SendAddressBytes>
	Dataflash_WaitWhileBusy();
     caa:	b9 de       	rcall	.-654    	; 0xa1e <Dataflash_WaitWhileBusy>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     cac:	80 91 e8 00 	lds	r24, 0x00E8

	/* If the endpoint is empty, clear it ready for the next packet from the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     cb0:	85 fd       	sbrc	r24, 5
     cb2:	05 c0       	rjmp	.+10     	; 0xcbe <DataflashManager_WriteBlocks+0x252>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
     cb4:	80 91 e8 00 	lds	r24, 0x00E8
     cb8:	8b 77       	andi	r24, 0x7B	; 123
     cba:	80 93 e8 00 	sts	0x00E8, r24
			 *              the chip number).
			 */
			static inline void Dataflash_SelectChip(const uint8_t ChipMask) ATTR_ALWAYS_INLINE;
			static inline void Dataflash_SelectChip(const uint8_t ChipMask)
			{
				DATAFLASH_CHIPCS_PORT = ((DATAFLASH_CHIPCS_PORT | DATAFLASH_CHIPCS_MASK) & ~ChipMask);
     cbe:	8e b1       	in	r24, 0x0e	; 14
     cc0:	83 60       	ori	r24, 0x03	; 3
     cc2:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearOUT();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     cc4:	0f 90       	pop	r0
     cc6:	cf 91       	pop	r28
     cc8:	df 91       	pop	r29
     cca:	1f 91       	pop	r17
     ccc:	0f 91       	pop	r16
     cce:	ff 90       	pop	r15
     cd0:	ef 90       	pop	r14
     cd2:	df 90       	pop	r13
     cd4:	cf 90       	pop	r12
     cd6:	bf 90       	pop	r11
     cd8:	af 90       	pop	r10
     cda:	9f 90       	pop	r9
     cdc:	7f 90       	pop	r7
     cde:	6f 90       	pop	r6
     ce0:	08 95       	ret

00000ce2 <DataflashManager_ReadBlocks>:
 *  \param[in] TotalBlocks   Number of blocks of data to read
 */
void DataflashManager_ReadBlocks(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo,
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
     ce2:	bf 92       	push	r11
     ce4:	cf 92       	push	r12
     ce6:	df 92       	push	r13
     ce8:	ef 92       	push	r14
     cea:	ff 92       	push	r15
     cec:	0f 93       	push	r16
     cee:	1f 93       	push	r17
     cf0:	cf 93       	push	r28
     cf2:	df 93       	push	r29
     cf4:	6c 01       	movw	r12, r24
     cf6:	79 01       	movw	r14, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     cf8:	db 01       	movw	r26, r22
     cfa:	ca 01       	movw	r24, r20
     cfc:	69 e0       	ldi	r22, 0x09	; 9
     cfe:	88 0f       	add	r24, r24
     d00:	99 1f       	adc	r25, r25
     d02:	aa 1f       	adc	r26, r26
     d04:	bb 1f       	adc	r27, r27
     d06:	6a 95       	dec	r22
     d08:	d1 f7       	brne	.-12     	; 0xcfe <DataflashManager_ReadBlocks+0x1c>
     d0a:	3a e0       	ldi	r19, 0x0A	; 10
     d0c:	b6 95       	lsr	r27
     d0e:	a7 95       	ror	r26
     d10:	97 95       	ror	r25
     d12:	87 95       	ror	r24
     d14:	3a 95       	dec	r19
     d16:	d1 f7       	brne	.-12     	; 0xd0c <DataflashManager_ReadBlocks+0x2a>
     d18:	ec 01       	movw	r28, r24
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     d1a:	8a 01       	movw	r16, r20
     d1c:	10 2f       	mov	r17, r16
     d1e:	00 27       	eor	r16, r16
     d20:	11 0f       	add	r17, r17
     d22:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     d24:	5f de       	rcall	.-834    	; 0x9e4 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d26:	82 ed       	ldi	r24, 0xD2	; 210
     d28:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     d2a:	0d b4       	in	r0, 0x2d	; 45
     d2c:	07 fe       	sbrs	r0, 7
     d2e:	fd cf       	rjmp	.-6      	; 0xd2a <DataflashManager_ReadBlocks+0x48>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     d30:	ce 01       	movw	r24, r28
     d32:	b8 01       	movw	r22, r16
     d34:	82 de       	rcall	.-764    	; 0xa3a <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d36:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d38:	0d b4       	in	r0, 0x2d	; 45
     d3a:	07 fe       	sbrs	r0, 7
     d3c:	fd cf       	rjmp	.-6      	; 0xd38 <DataflashManager_ReadBlocks+0x56>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d3e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d40:	0d b4       	in	r0, 0x2d	; 45
     d42:	07 fe       	sbrs	r0, 7
     d44:	fd cf       	rjmp	.-6      	; 0xd40 <DataflashManager_ReadBlocks+0x5e>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d46:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d48:	0d b4       	in	r0, 0x2d	; 45
     d4a:	07 fe       	sbrs	r0, 7
     d4c:	fd cf       	rjmp	.-6      	; 0xd48 <DataflashManager_ReadBlocks+0x66>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d4e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     d50:	0d b4       	in	r0, 0x2d	; 45
     d52:	07 fe       	sbrs	r0, 7
     d54:	fd cf       	rjmp	.-6      	; 0xd50 <DataflashManager_ReadBlocks+0x6e>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
     d56:	0e 94 c8 28 	call	0x5190	; 0x5190 <Endpoint_WaitUntilReady>
     d5a:	88 23       	and	r24, r24
     d5c:	09 f0       	breq	.+2      	; 0xd60 <DataflashManager_ReadBlocks+0x7e>
     d5e:	c0 c0       	rjmp	.+384    	; 0xee0 <DataflashManager_ReadBlocks+0x1fe>
                                 const uint32_t BlockAddress,
                                 uint16_t TotalBlocks)
{
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     d60:	94 e0       	ldi	r25, 0x04	; 4
     d62:	16 95       	lsr	r17
     d64:	07 95       	ror	r16
     d66:	9a 95       	dec	r25
     d68:	e1 f7       	brne	.-8      	; 0xd62 <DataflashManager_ReadBlocks+0x80>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     d6a:	82 ed       	ldi	r24, 0xD2	; 210
     d6c:	b8 2e       	mov	r11, r24
     d6e:	a8 c0       	rjmp	.+336    	; 0xec0 <DataflashManager_ReadBlocks+0x1de>

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     d70:	10 e2       	ldi	r17, 0x20	; 32
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     d72:	80 91 e8 00 	lds	r24, 0x00E8

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if the endpoint is currently full */
			if (!(Endpoint_IsReadWriteAllowed()))
     d76:	85 fd       	sbrc	r24, 5
     d78:	0a c0       	rjmp	.+20     	; 0xd8e <DataflashManager_ReadBlocks+0xac>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     d7a:	80 91 e8 00 	lds	r24, 0x00E8
     d7e:	8e 77       	andi	r24, 0x7E	; 126
     d80:	80 93 e8 00 	sts	0x00E8, r24
			{
				/* Clear the endpoint bank to send its contents to the host */
				Endpoint_ClearIN();

				/* Wait until the endpoint is ready for more data */
				if (Endpoint_WaitUntilReady())
     d84:	0e 94 c8 28 	call	0x5190	; 0x5190 <Endpoint_WaitUntilReady>
     d88:	88 23       	and	r24, r24
     d8a:	09 f0       	breq	.+2      	; 0xd8e <DataflashManager_ReadBlocks+0xac>
     d8c:	a9 c0       	rjmp	.+338    	; 0xee0 <DataflashManager_ReadBlocks+0x1fe>
				  return;
			}

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     d8e:	00 34       	cpi	r16, 0x40	; 64
     d90:	e1 f4       	brne	.+56     	; 0xdca <DataflashManager_ReadBlocks+0xe8>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     d92:	21 96       	adiw	r28, 0x01	; 1

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     d94:	ce 01       	movw	r24, r28
     d96:	26 de       	rcall	.-948    	; 0x9e4 <Dataflash_SelectChipFromPage>
     d98:	be bc       	out	0x2e, r11	; 46
				while (!(SPSR & (1 << SPIF)));
     d9a:	0d b4       	in	r0, 0x2d	; 45
     d9c:	07 fe       	sbrs	r0, 7
     d9e:	fd cf       	rjmp	.-6      	; 0xd9a <DataflashManager_ReadBlocks+0xb8>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     da0:	ce 01       	movw	r24, r28
     da2:	60 e0       	ldi	r22, 0x00	; 0
     da4:	70 e0       	ldi	r23, 0x00	; 0
     da6:	49 de       	rcall	.-878    	; 0xa3a <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     da8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     daa:	0d b4       	in	r0, 0x2d	; 45
     dac:	07 fe       	sbrs	r0, 7
     dae:	fd cf       	rjmp	.-6      	; 0xdaa <DataflashManager_ReadBlocks+0xc8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     db0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     db2:	0d b4       	in	r0, 0x2d	; 45
     db4:	07 fe       	sbrs	r0, 7
     db6:	fd cf       	rjmp	.-6      	; 0xdb2 <DataflashManager_ReadBlocks+0xd0>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     db8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     dba:	0d b4       	in	r0, 0x2d	; 45
     dbc:	07 fe       	sbrs	r0, 7
     dbe:	fd cf       	rjmp	.-6      	; 0xdba <DataflashManager_ReadBlocks+0xd8>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     dc0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     dc2:	0d b4       	in	r0, 0x2d	; 45
     dc4:	07 fe       	sbrs	r0, 7
     dc6:	fd cf       	rjmp	.-6      	; 0xdc2 <DataflashManager_ReadBlocks+0xe0>

			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     dc8:	00 e0       	ldi	r16, 0x00	; 0
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dca:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     dcc:	0d b4       	in	r0, 0x2d	; 45
     dce:	07 fe       	sbrs	r0, 7
     dd0:	fd cf       	rjmp	.-6      	; 0xdcc <DataflashManager_ReadBlocks+0xea>
				return SPDR;
     dd2:	8e b5       	in	r24, 0x2e	; 46
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
     dd4:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     dd8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     dda:	0d b4       	in	r0, 0x2d	; 45
     ddc:	07 fe       	sbrs	r0, 7
     dde:	fd cf       	rjmp	.-6      	; 0xdda <DataflashManager_ReadBlocks+0xf8>
				return SPDR;
     de0:	8e b5       	in	r24, 0x2e	; 46
     de2:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     de6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     de8:	0d b4       	in	r0, 0x2d	; 45
     dea:	07 fe       	sbrs	r0, 7
     dec:	fd cf       	rjmp	.-6      	; 0xde8 <DataflashManager_ReadBlocks+0x106>
				return SPDR;
     dee:	8e b5       	in	r24, 0x2e	; 46
     df0:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     df4:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     df6:	0d b4       	in	r0, 0x2d	; 45
     df8:	07 fe       	sbrs	r0, 7
     dfa:	fd cf       	rjmp	.-6      	; 0xdf6 <DataflashManager_ReadBlocks+0x114>
				return SPDR;
     dfc:	8e b5       	in	r24, 0x2e	; 46
     dfe:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e02:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e04:	0d b4       	in	r0, 0x2d	; 45
     e06:	07 fe       	sbrs	r0, 7
     e08:	fd cf       	rjmp	.-6      	; 0xe04 <DataflashManager_ReadBlocks+0x122>
				return SPDR;
     e0a:	8e b5       	in	r24, 0x2e	; 46
     e0c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e10:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e12:	0d b4       	in	r0, 0x2d	; 45
     e14:	07 fe       	sbrs	r0, 7
     e16:	fd cf       	rjmp	.-6      	; 0xe12 <DataflashManager_ReadBlocks+0x130>
				return SPDR;
     e18:	8e b5       	in	r24, 0x2e	; 46
     e1a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e1e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e20:	0d b4       	in	r0, 0x2d	; 45
     e22:	07 fe       	sbrs	r0, 7
     e24:	fd cf       	rjmp	.-6      	; 0xe20 <DataflashManager_ReadBlocks+0x13e>
				return SPDR;
     e26:	8e b5       	in	r24, 0x2e	; 46
     e28:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e2c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e2e:	0d b4       	in	r0, 0x2d	; 45
     e30:	07 fe       	sbrs	r0, 7
     e32:	fd cf       	rjmp	.-6      	; 0xe2e <DataflashManager_ReadBlocks+0x14c>
				return SPDR;
     e34:	8e b5       	in	r24, 0x2e	; 46
     e36:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e3a:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e3c:	0d b4       	in	r0, 0x2d	; 45
     e3e:	07 fe       	sbrs	r0, 7
     e40:	fd cf       	rjmp	.-6      	; 0xe3c <DataflashManager_ReadBlocks+0x15a>
				return SPDR;
     e42:	8e b5       	in	r24, 0x2e	; 46
     e44:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e48:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e4a:	0d b4       	in	r0, 0x2d	; 45
     e4c:	07 fe       	sbrs	r0, 7
     e4e:	fd cf       	rjmp	.-6      	; 0xe4a <DataflashManager_ReadBlocks+0x168>
				return SPDR;
     e50:	8e b5       	in	r24, 0x2e	; 46
     e52:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e56:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e58:	0d b4       	in	r0, 0x2d	; 45
     e5a:	07 fe       	sbrs	r0, 7
     e5c:	fd cf       	rjmp	.-6      	; 0xe58 <DataflashManager_ReadBlocks+0x176>
				return SPDR;
     e5e:	8e b5       	in	r24, 0x2e	; 46
     e60:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e64:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e66:	0d b4       	in	r0, 0x2d	; 45
     e68:	07 fe       	sbrs	r0, 7
     e6a:	fd cf       	rjmp	.-6      	; 0xe66 <DataflashManager_ReadBlocks+0x184>
				return SPDR;
     e6c:	8e b5       	in	r24, 0x2e	; 46
     e6e:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e72:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e74:	0d b4       	in	r0, 0x2d	; 45
     e76:	07 fe       	sbrs	r0, 7
     e78:	fd cf       	rjmp	.-6      	; 0xe74 <DataflashManager_ReadBlocks+0x192>
				return SPDR;
     e7a:	8e b5       	in	r24, 0x2e	; 46
     e7c:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e80:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e82:	0d b4       	in	r0, 0x2d	; 45
     e84:	07 fe       	sbrs	r0, 7
     e86:	fd cf       	rjmp	.-6      	; 0xe82 <DataflashManager_ReadBlocks+0x1a0>
				return SPDR;
     e88:	8e b5       	in	r24, 0x2e	; 46
     e8a:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e8e:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e90:	0d b4       	in	r0, 0x2d	; 45
     e92:	07 fe       	sbrs	r0, 7
     e94:	fd cf       	rjmp	.-6      	; 0xe90 <DataflashManager_ReadBlocks+0x1ae>
				return SPDR;
     e96:	8e b5       	in	r24, 0x2e	; 46
     e98:	80 93 f1 00 	sts	0x00F1, r24
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     e9c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     e9e:	0d b4       	in	r0, 0x2d	; 45
     ea0:	07 fe       	sbrs	r0, 7
     ea2:	fd cf       	rjmp	.-6      	; 0xe9e <DataflashManager_ReadBlocks+0x1bc>
				return SPDR;
     ea4:	8e b5       	in	r24, 0x2e	; 46
     ea6:	80 93 f1 00 	sts	0x00F1, r24

			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;

			/* Check if the current command is being aborted by the host */
			if (MSInterfaceInfo->State.IsMassStoreReset)
     eaa:	f6 01       	movw	r30, r12
     eac:	80 ad       	ldd	r24, Z+56	; 0x38
     eae:	88 23       	and	r24, r24
     eb0:	b9 f4       	brne	.+46     	; 0xee0 <DataflashManager_ReadBlocks+0x1fe>
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());
			Endpoint_Write_8(Dataflash_ReceiveByte());

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     eb2:	0f 5f       	subi	r16, 0xFF	; 255
     eb4:	11 50       	subi	r17, 0x01	; 1
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     eb6:	09 f0       	breq	.+2      	; 0xeba <DataflashManager_ReadBlocks+0x1d8>
     eb8:	5c cf       	rjmp	.-328    	; 0xd72 <DataflashManager_ReadBlocks+0x90>
			if (MSInterfaceInfo->State.IsMassStoreReset)
			  return;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     eba:	08 94       	sec
     ebc:	e1 08       	sbc	r14, r1
     ebe:	f1 08       	sbc	r15, r1

	/* Wait until endpoint is ready before continuing */
	if (Endpoint_WaitUntilReady())
	  return;

	while (TotalBlocks)
     ec0:	e1 14       	cp	r14, r1
     ec2:	f1 04       	cpc	r15, r1
     ec4:	09 f0       	breq	.+2      	; 0xec8 <DataflashManager_ReadBlocks+0x1e6>
     ec6:	54 cf       	rjmp	.-344    	; 0xd70 <DataflashManager_ReadBlocks+0x8e>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
     ec8:	80 91 e8 00 	lds	r24, 0x00E8
		/* Decrement the blocks remaining counter */
		TotalBlocks--;
	}

	/* If the endpoint is full, send its contents to the host */
	if (!(Endpoint_IsReadWriteAllowed()))
     ecc:	85 fd       	sbrc	r24, 5
     ece:	05 c0       	rjmp	.+10     	; 0xeda <DataflashManager_ReadBlocks+0x1f8>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
     ed0:	80 91 e8 00 	lds	r24, 0x00E8
     ed4:	8e 77       	andi	r24, 0x7E	; 126
     ed6:	80 93 e8 00 	sts	0x00E8, r24
     eda:	8e b1       	in	r24, 0x0e	; 14
     edc:	83 60       	ori	r24, 0x03	; 3
     ede:	8e b9       	out	0x0e, r24	; 14
	  Endpoint_ClearIN();

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
     ee0:	df 91       	pop	r29
     ee2:	cf 91       	pop	r28
     ee4:	1f 91       	pop	r17
     ee6:	0f 91       	pop	r16
     ee8:	ff 90       	pop	r15
     eea:	ef 90       	pop	r14
     eec:	df 90       	pop	r13
     eee:	cf 90       	pop	r12
     ef0:	bf 90       	pop	r11
     ef2:	08 95       	ret

00000ef4 <DataflashManager_ReadBlocks_RAM>:
 *  \param[out] BufferPtr    Pointer to the data destination RAM buffer
 */
void DataflashManager_ReadBlocks_RAM(const uint32_t BlockAddress,
                                     uint16_t TotalBlocks,
                                     uint8_t* BufferPtr)
{
     ef4:	9f 92       	push	r9
     ef6:	af 92       	push	r10
     ef8:	bf 92       	push	r11
     efa:	cf 92       	push	r12
     efc:	df 92       	push	r13
     efe:	ef 92       	push	r14
     f00:	ff 92       	push	r15
     f02:	0f 93       	push	r16
     f04:	1f 93       	push	r17
     f06:	cf 93       	push	r28
     f08:	df 93       	push	r29
     f0a:	5a 01       	movw	r10, r20
     f0c:	69 01       	movw	r12, r18
	uint16_t CurrDFPage          = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) / DATAFLASH_PAGE_SIZE);
     f0e:	9b 01       	movw	r18, r22
     f10:	ac 01       	movw	r20, r24
     f12:	f9 e0       	ldi	r31, 0x09	; 9
     f14:	22 0f       	add	r18, r18
     f16:	33 1f       	adc	r19, r19
     f18:	44 1f       	adc	r20, r20
     f1a:	55 1f       	adc	r21, r21
     f1c:	fa 95       	dec	r31
     f1e:	d1 f7       	brne	.-12     	; 0xf14 <DataflashManager_ReadBlocks_RAM+0x20>
     f20:	ea e0       	ldi	r30, 0x0A	; 10
     f22:	56 95       	lsr	r21
     f24:	47 95       	ror	r20
     f26:	37 95       	ror	r19
     f28:	27 95       	ror	r18
     f2a:	ea 95       	dec	r30
     f2c:	d1 f7       	brne	.-12     	; 0xf22 <DataflashManager_ReadBlocks_RAM+0x2e>
     f2e:	e9 01       	movw	r28, r18
	uint16_t CurrDFPageByte      = ((BlockAddress * VIRTUAL_MEMORY_BLOCK_SIZE) % DATAFLASH_PAGE_SIZE);
     f30:	8b 01       	movw	r16, r22
     f32:	10 2f       	mov	r17, r16
     f34:	00 27       	eor	r16, r16
     f36:	11 0f       	add	r17, r17
     f38:	13 70       	andi	r17, 0x03	; 3
	uint8_t  CurrDFPageByteDiv16 = (CurrDFPageByte >> 4);
     f3a:	c8 01       	movw	r24, r16
     f3c:	44 e0       	ldi	r20, 0x04	; 4
     f3e:	96 95       	lsr	r25
     f40:	87 95       	ror	r24
     f42:	4a 95       	dec	r20
     f44:	e1 f7       	brne	.-8      	; 0xf3e <DataflashManager_ReadBlocks_RAM+0x4a>
     f46:	f8 2e       	mov	r15, r24

	/* Select the correct starting Dataflash IC for the block requested */
	Dataflash_SelectChipFromPage(CurrDFPage);
     f48:	c9 01       	movw	r24, r18
     f4a:	4c dd       	rcall	.-1384   	; 0x9e4 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f4c:	82 ed       	ldi	r24, 0xD2	; 210
     f4e:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
     f50:	0d b4       	in	r0, 0x2d	; 45
     f52:	07 fe       	sbrs	r0, 7
     f54:	fd cf       	rjmp	.-6      	; 0xf50 <DataflashManager_ReadBlocks_RAM+0x5c>

	/* Send the Dataflash main memory page read command */
	Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
	Dataflash_SendAddressBytes(CurrDFPage, CurrDFPageByte);
     f56:	ce 01       	movw	r24, r28
     f58:	b8 01       	movw	r22, r16
     f5a:	6f dd       	rcall	.-1314   	; 0xa3a <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f5c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f5e:	0d b4       	in	r0, 0x2d	; 45
     f60:	07 fe       	sbrs	r0, 7
     f62:	fd cf       	rjmp	.-6      	; 0xf5e <DataflashManager_ReadBlocks_RAM+0x6a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f64:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f66:	0d b4       	in	r0, 0x2d	; 45
     f68:	07 fe       	sbrs	r0, 7
     f6a:	fd cf       	rjmp	.-6      	; 0xf66 <DataflashManager_ReadBlocks_RAM+0x72>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f6c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f6e:	0d b4       	in	r0, 0x2d	; 45
     f70:	07 fe       	sbrs	r0, 7
     f72:	fd cf       	rjmp	.-6      	; 0xf6e <DataflashManager_ReadBlocks_RAM+0x7a>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f74:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     f76:	0d b4       	in	r0, 0x2d	; 45
     f78:	07 fe       	sbrs	r0, 7
     f7a:	fd cf       	rjmp	.-6      	; 0xf76 <DataflashManager_ReadBlocks_RAM+0x82>
     f7c:	39 c0       	rjmp	.+114    	; 0xff0 <DataflashManager_ReadBlocks_RAM+0xfc>
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     f7e:	86 01       	movw	r16, r12
     f80:	80 e2       	ldi	r24, 0x20	; 32
     f82:	e8 2e       	mov	r14, r24

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
     f84:	8f 2d       	mov	r24, r15
     f86:	80 34       	cpi	r24, 0x40	; 64
     f88:	e1 f4       	brne	.+56     	; 0xfc2 <DataflashManager_ReadBlocks_RAM+0xce>
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
				CurrDFPage++;
     f8a:	21 96       	adiw	r28, 0x01	; 1

				/* Select the next Dataflash chip based on the new Dataflash page index */
				Dataflash_SelectChipFromPage(CurrDFPage);
     f8c:	ce 01       	movw	r24, r28
     f8e:	2a dd       	rcall	.-1452   	; 0x9e4 <Dataflash_SelectChipFromPage>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     f90:	9e bc       	out	0x2e, r9	; 46
				while (!(SPSR & (1 << SPIF)));
     f92:	0d b4       	in	r0, 0x2d	; 45
     f94:	07 fe       	sbrs	r0, 7
     f96:	fd cf       	rjmp	.-6      	; 0xf92 <DataflashManager_ReadBlocks_RAM+0x9e>

				/* Send the Dataflash main memory page read command */
				Dataflash_SendByte(DF_CMD_MAINMEMPAGEREAD);
				Dataflash_SendAddressBytes(CurrDFPage, 0);
     f98:	ce 01       	movw	r24, r28
     f9a:	60 e0       	ldi	r22, 0x00	; 0
     f9c:	70 e0       	ldi	r23, 0x00	; 0
     f9e:	4d dd       	rcall	.-1382   	; 0xa3a <Dataflash_SendAddressBytes>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fa0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fa2:	0d b4       	in	r0, 0x2d	; 45
     fa4:	07 fe       	sbrs	r0, 7
     fa6:	fd cf       	rjmp	.-6      	; 0xfa2 <DataflashManager_ReadBlocks_RAM+0xae>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fa8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     faa:	0d b4       	in	r0, 0x2d	; 45
     fac:	07 fe       	sbrs	r0, 7
     fae:	fd cf       	rjmp	.-6      	; 0xfaa <DataflashManager_ReadBlocks_RAM+0xb6>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fb0:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fb2:	0d b4       	in	r0, 0x2d	; 45
     fb4:	07 fe       	sbrs	r0, 7
     fb6:	fd cf       	rjmp	.-6      	; 0xfb2 <DataflashManager_ReadBlocks_RAM+0xbe>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     fb8:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fba:	0d b4       	in	r0, 0x2d	; 45
     fbc:	07 fe       	sbrs	r0, 7
     fbe:	fd cf       	rjmp	.-6      	; 0xfba <DataflashManager_ReadBlocks_RAM+0xc6>
		{
			/* Check if end of Dataflash page reached */
			if (CurrDFPageByteDiv16 == (DATAFLASH_PAGE_SIZE >> 4))
			{
				/* Reset the Dataflash buffer counter, increment the page counter */
				CurrDFPageByteDiv16 = 0;
     fc0:	ff 24       	eor	r15, r15
     fc2:	f8 01       	movw	r30, r16
     fc4:	80 e1       	ldi	r24, 0x10	; 16
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
     fc6:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
     fc8:	0d b4       	in	r0, 0x2d	; 45
     fca:	07 fe       	sbrs	r0, 7
     fcc:	fd cf       	rjmp	.-6      	; 0xfc8 <DataflashManager_ReadBlocks_RAM+0xd4>
				return SPDR;
     fce:	9e b5       	in	r25, 0x2e	; 46
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
			  *(BufferPtr++) = Dataflash_ReceiveByte();
     fd0:	91 93       	st	Z+, r25
     fd2:	81 50       	subi	r24, 0x01	; 1
				Dataflash_SendByte(0x00);
				Dataflash_SendByte(0x00);
			}

			/* Read one 16-byte chunk of data from the Dataflash */
			for (uint8_t ByteNum = 0; ByteNum < 16; ByteNum++)
     fd4:	c1 f7       	brne	.-16     	; 0xfc6 <DataflashManager_ReadBlocks_RAM+0xd2>
     fd6:	00 5f       	subi	r16, 0xF0	; 240
     fd8:	1f 4f       	sbci	r17, 0xFF	; 255
			  *(BufferPtr++) = Dataflash_ReceiveByte();

			/* Increment the Dataflash page 16 byte block counter */
			CurrDFPageByteDiv16++;
     fda:	f3 94       	inc	r15
     fdc:	ea 94       	dec	r14
	while (TotalBlocks)
	{
		uint8_t BytesInBlockDiv16 = 0;

		/* Write an endpoint packet sized data block to the Dataflash */
		while (BytesInBlockDiv16 < (VIRTUAL_MEMORY_BLOCK_SIZE >> 4))
     fde:	91 f6       	brne	.-92     	; 0xf84 <DataflashManager_ReadBlocks_RAM+0x90>
     fe0:	80 e0       	ldi	r24, 0x00	; 0
     fe2:	92 e0       	ldi	r25, 0x02	; 2
     fe4:	c8 0e       	add	r12, r24
     fe6:	d9 1e       	adc	r13, r25
			/* Increment the block 16 byte block counter */
			BytesInBlockDiv16++;
		}

		/* Decrement the blocks remaining counter */
		TotalBlocks--;
     fe8:	08 94       	sec
     fea:	a1 08       	sbc	r10, r1
     fec:	b1 08       	sbc	r11, r1
     fee:	02 c0       	rjmp	.+4      	; 0xff4 <DataflashManager_ReadBlocks_RAM+0x100>
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
     ff0:	02 ed       	ldi	r16, 0xD2	; 210
     ff2:	90 2e       	mov	r9, r16
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);
	Dataflash_SendByte(0x00);

	while (TotalBlocks)
     ff4:	a1 14       	cp	r10, r1
     ff6:	b1 04       	cpc	r11, r1
     ff8:	09 f0       	breq	.+2      	; 0xffc <DataflashManager_ReadBlocks_RAM+0x108>
     ffa:	c1 cf       	rjmp	.-126    	; 0xf7e <DataflashManager_ReadBlocks_RAM+0x8a>
     ffc:	8e b1       	in	r24, 0x0e	; 14
     ffe:	83 60       	ori	r24, 0x03	; 3
    1000:	8e b9       	out	0x0e, r24	; 14
		TotalBlocks--;
	}

	/* Deselect all Dataflash chips */
	Dataflash_DeselectChip();
}
    1002:	df 91       	pop	r29
    1004:	cf 91       	pop	r28
    1006:	1f 91       	pop	r17
    1008:	0f 91       	pop	r16
    100a:	ff 90       	pop	r15
    100c:	ef 90       	pop	r14
    100e:	df 90       	pop	r13
    1010:	cf 90       	pop	r12
    1012:	bf 90       	pop	r11
    1014:	af 90       	pop	r10
    1016:	9f 90       	pop	r9
    1018:	08 95       	ret

0000101a <DataflashManager_CheckDataflashOperation>:
    101a:	8e b1       	in	r24, 0x0e	; 14
    101c:	83 60       	ori	r24, 0x03	; 3
    101e:	8e 7f       	andi	r24, 0xFE	; 254
    1020:	8e b9       	out	0x0e, r24	; 14
    1022:	8f e9       	ldi	r24, 0x9F	; 159
    1024:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    1026:	0d b4       	in	r0, 0x2d	; 45
    1028:	07 fe       	sbrs	r0, 7
    102a:	fd cf       	rjmp	.-6      	; 0x1026 <DataflashManager_CheckDataflashOperation+0xc>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    102c:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    102e:	0d b4       	in	r0, 0x2d	; 45
    1030:	07 fe       	sbrs	r0, 7
    1032:	fd cf       	rjmp	.-6      	; 0x102e <DataflashManager_CheckDataflashOperation+0x14>
				return SPDR;
    1034:	9e b5       	in	r25, 0x2e	; 46
    1036:	8e b1       	in	r24, 0x0e	; 14
    1038:	83 60       	ori	r24, 0x03	; 3
    103a:	8e b9       	out	0x0e, r24	; 14
	Dataflash_SendByte(DF_CMD_READMANUFACTURERDEVICEINFO);
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
    103c:	9f 31       	cpi	r25, 0x1F	; 31
    103e:	b1 f4       	brne	.+44     	; 0x106c <DataflashManager_CheckDataflashOperation+0x52>
    1040:	8e b1       	in	r24, 0x0e	; 14
    1042:	83 60       	ori	r24, 0x03	; 3
    1044:	8d 7f       	andi	r24, 0xFD	; 253
    1046:	8e b9       	out	0x0e, r24	; 14
			 *  \param[in] Byte  Byte to send through the SPI interface.
			 */
			static inline void SPI_SendByte(const uint8_t Byte) ATTR_ALWAYS_INLINE;
			static inline void SPI_SendByte(const uint8_t Byte)
			{
				SPDR = Byte;
    1048:	8f e9       	ldi	r24, 0x9F	; 159
    104a:	8e bd       	out	0x2e, r24	; 46
				while (!(SPSR & (1 << SPIF)));
    104c:	0d b4       	in	r0, 0x2d	; 45
    104e:	07 fe       	sbrs	r0, 7
    1050:	fd cf       	rjmp	.-6      	; 0x104c <DataflashManager_CheckDataflashOperation+0x32>
			 *  \return The response byte from the attached SPI device.
			 */
			static inline uint8_t SPI_ReceiveByte(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint8_t SPI_ReceiveByte(void)
			{
				SPDR = 0x00;
    1052:	1e bc       	out	0x2e, r1	; 46
				while (!(SPSR & (1 << SPIF)));
    1054:	0d b4       	in	r0, 0x2d	; 45
    1056:	07 fe       	sbrs	r0, 7
    1058:	fd cf       	rjmp	.-6      	; 0x1054 <DataflashManager_CheckDataflashOperation+0x3a>
				return SPDR;
    105a:	9e b5       	in	r25, 0x2e	; 46
    105c:	8e b1       	in	r24, 0x0e	; 14
    105e:	83 60       	ori	r24, 0x03	; 3
    1060:	8e b9       	out	0x0e, r24	; 14

/** Performs a simple test on the attached Dataflash IC(s) to ensure that they are working.
 *
 *  \return Boolean true if all media chips are working, false otherwise
 */
bool DataflashManager_CheckDataflashOperation(void)
    1062:	81 e0       	ldi	r24, 0x01	; 1
    1064:	9f 31       	cpi	r25, 0x1F	; 31
    1066:	19 f0       	breq	.+6      	; 0x106e <DataflashManager_CheckDataflashOperation+0x54>
    1068:	80 e0       	ldi	r24, 0x00	; 0
    106a:	08 95       	ret
	ReturnByte = Dataflash_ReceiveByte();
	Dataflash_DeselectChip();

	/* If returned data is invalid, fail the command */
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
    106c:	80 e0       	ldi	r24, 0x00	; 0
	if (ReturnByte != DF_MANUFACTURER_ATMEL)
	  return false;
	#endif

	return true;
}
    106e:	08 95       	ret

00001070 <LEDs_SetAllLEDs>:
				PORTD &= ~LEDMask;
			}

			static inline void LEDs_SetAllLEDs(const uint8_t LEDMask)
			{
				PORTD = ((PORTD & ~LEDS_ALL_LEDS) | LEDMask);
    1070:	9b b1       	in	r25, 0x0b	; 11
    1072:	9f 70       	andi	r25, 0x0F	; 15
    1074:	98 2b       	or	r25, r24
    1076:	9b b9       	out	0x0b, r25	; 11
			}
    1078:	08 95       	ret

0000107a <uIPManagement_Init>:
struct uip_eth_addr MACAddress;


/** Configures the uIP stack ready for network traffic processing. */
void uIPManagement_Init(void)
{
    107a:	1f 93       	push	r17
	/* uIP Timing Initialization */
	clock_init();
    107c:	0e 94 4b 1c 	call	0x3896	; 0x3896 <clock_init>
	timer_set(&ConnectionTimer, CLOCK_SECOND / 2);
    1080:	86 e5       	ldi	r24, 0x56	; 86
    1082:	93 e0       	ldi	r25, 0x03	; 3
    1084:	62 e3       	ldi	r22, 0x32	; 50
    1086:	70 e0       	ldi	r23, 0x00	; 0
    1088:	0e 94 09 1c 	call	0x3812	; 0x3812 <timer_set>
	timer_set(&ARPTimer, CLOCK_SECOND * 10);
    108c:	8a e5       	ldi	r24, 0x5A	; 90
    108e:	93 e0       	ldi	r25, 0x03	; 3
    1090:	68 ee       	ldi	r22, 0xE8	; 232
    1092:	73 e0       	ldi	r23, 0x03	; 3
    1094:	0e 94 09 1c 	call	0x3812	; 0x3812 <timer_set>

	/* uIP Stack Initialization */
	uip_init();
    1098:	0e 94 76 10 	call	0x20ec	; 0x20ec <uip_init>
	uip_arp_init();
    109c:	0e 94 f3 19 	call	0x33e6	; 0x33e6 <uip_arp_init>

	/* DHCP/Server IP Settings Initialization */
	if (USB_CurrentMode == USB_MODE_Device)
    10a0:	10 91 d9 03 	lds	r17, 0x03D9
    10a4:	11 30       	cpi	r17, 0x01	; 1
    10a6:	49 f5       	brne	.+82     	; 0x10fa <uIPManagement_Init+0x80>
	{
		MACAddress.addr[0] = SERVER_MAC_ADDRESS[0];
    10a8:	10 93 dc 03 	sts	0x03DC, r17
		MACAddress.addr[1] = SERVER_MAC_ADDRESS[1];
    10ac:	10 92 dd 03 	sts	0x03DD, r1
		MACAddress.addr[2] = SERVER_MAC_ADDRESS[2];
    10b0:	10 93 de 03 	sts	0x03DE, r17
		MACAddress.addr[3] = SERVER_MAC_ADDRESS[3];
    10b4:	10 92 df 03 	sts	0x03DF, r1
		MACAddress.addr[4] = SERVER_MAC_ADDRESS[4];
    10b8:	10 93 e0 03 	sts	0x03E0, r17
		MACAddress.addr[5] = SERVER_MAC_ADDRESS[5];
    10bc:	10 92 e1 03 	sts	0x03E1, r1

		#if defined(ENABLE_DHCP_SERVER)
		DHCPServerApp_Init();
    10c0:	a2 d3       	rcall	.+1860   	; 0x1806 <DHCPServerApp_Init>
    10c2:	9a e0       	ldi	r25, 0x0A	; 10
    10c4:	90 93 99 07 	sts	0x0799, r25
    10c8:	10 92 9a 07 	sts	0x079A, r1
    10cc:	10 92 9b 07 	sts	0x079B, r1
    10d0:	82 e0       	ldi	r24, 0x02	; 2
    10d2:	80 93 9c 07 	sts	0x079C, r24
    10d6:	8f ef       	ldi	r24, 0xFF	; 255
    10d8:	80 93 95 07 	sts	0x0795, r24
    10dc:	80 93 96 07 	sts	0x0796, r24
    10e0:	80 93 97 07 	sts	0x0797, r24
    10e4:	10 92 98 07 	sts	0x0798, r1
    10e8:	90 93 91 07 	sts	0x0791, r25
    10ec:	10 92 92 07 	sts	0x0792, r1
    10f0:	10 92 93 07 	sts	0x0793, r1
    10f4:	10 93 94 07 	sts	0x0794, r17
    10f8:	01 c0       	rjmp	.+2      	; 0x10fc <uIPManagement_Init+0x82>
		uip_setdraddr(&GatewayIPAddress);
	}
	else
	{
		#if defined(ENABLE_DHCP_CLIENT)
		DHCPClientApp_Init();
    10fa:	b9 d1       	rcall	.+882    	; 0x146e <DHCPClientApp_Init>
		uip_setdraddr(&GatewayIPAddress);
		#endif
	}

	/* Virtual Webserver Ethernet Address Configuration */
	uip_setethaddr(MACAddress);
    10fc:	80 91 dc 03 	lds	r24, 0x03DC
    1100:	80 93 5e 03 	sts	0x035E, r24
    1104:	80 91 dd 03 	lds	r24, 0x03DD
    1108:	80 93 5f 03 	sts	0x035F, r24
    110c:	80 91 de 03 	lds	r24, 0x03DE
    1110:	80 93 60 03 	sts	0x0360, r24
    1114:	80 91 df 03 	lds	r24, 0x03DF
    1118:	80 93 61 03 	sts	0x0361, r24
    111c:	80 91 e0 03 	lds	r24, 0x03E0
    1120:	80 93 62 03 	sts	0x0362, r24
    1124:	80 91 e1 03 	lds	r24, 0x03E1
    1128:	80 93 63 03 	sts	0x0363, r24

	/* HTTP Webserver Initialization */
	HTTPServerApp_Init();
    112c:	dd d4       	rcall	.+2490   	; 0x1ae8 <HTTPServerApp_Init>

	/* TELNET Server Initialization */
	#if defined(ENABLE_TELNET_SERVER)
	TELNETServerApp_Init();
    112e:	60 d6       	rcall	.+3264   	; 0x1df0 <TELNETServerApp_Init>
	#endif
}
    1130:	1f 91       	pop	r17
    1132:	08 95       	ret

00001134 <uIPManagement_ManageNetwork>:

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    1134:	0f 93       	push	r16
    1136:	1f 93       	push	r17
    1138:	cf 93       	push	r28
    113a:	df 93       	push	r29
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    113c:	80 91 d9 03 	lds	r24, 0x03D9
    1140:	82 30       	cpi	r24, 0x02	; 2
    1142:	19 f4       	brne	.+6      	; 0x114a <uIPManagement_ManageNetwork+0x16>
    1144:	8e b3       	in	r24, 0x1e	; 30
    1146:	8b 30       	cpi	r24, 0x0B	; 11
    1148:	49 f0       	breq	.+18     	; 0x115c <uIPManagement_ManageNetwork+0x28>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    114a:	80 91 d9 03 	lds	r24, 0x03D9
/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
	if (((USB_CurrentMode == USB_MODE_Host)   && (USB_HostState   == HOST_STATE_Configured)) ||
    114e:	81 30       	cpi	r24, 0x01	; 1
    1150:	09 f0       	breq	.+2      	; 0x1154 <uIPManagement_ManageNetwork+0x20>
    1152:	c6 c0       	rjmp	.+396    	; 0x12e0 <uIPManagement_ManageNetwork+0x1ac>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
    1154:	8e b3       	in	r24, 0x1e	; 30
    1156:	84 30       	cpi	r24, 0x04	; 4
    1158:	09 f0       	breq	.+2      	; 0x115c <uIPManagement_ManageNetwork+0x28>
    115a:	c2 c0       	rjmp	.+388    	; 0x12e0 <uIPManagement_ManageNetwork+0x1ac>

/** Processes Incoming packets to the server from the connected RNDIS device, creating responses as needed. */
static void uIPManagement_ProcessIncomingPacket(void)
{
	/* Determine which USB mode the system is currently initialized in */
	if (USB_CurrentMode == USB_MODE_Device)
    115c:	80 91 d9 03 	lds	r24, 0x03D9
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	91 f4       	brne	.+36     	; 0x1188 <uIPManagement_ManageNetwork+0x54>
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Device_IsPacketReceived(&Ethernet_RNDIS_Interface_Device)))
    1164:	83 e1       	ldi	r24, 0x13	; 19
    1166:	91 e0       	ldi	r25, 0x01	; 1
    1168:	0e 94 ab 37 	call	0x6f56	; 0x6f56 <RNDIS_Device_IsPacketReceived>
    116c:	88 23       	and	r24, r24
    116e:	09 f4       	brne	.+2      	; 0x1172 <uIPManagement_ManageNetwork+0x3e>
    1170:	45 c0       	rjmp	.+138    	; 0x11fc <uIPManagement_ManageNetwork+0xc8>
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    1172:	80 ed       	ldi	r24, 0xD0	; 208
    1174:	7d df       	rcall	.-262    	; 0x1070 <LEDs_SetAllLEDs>

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Device_ReadPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, &uip_len);
    1176:	83 e1       	ldi	r24, 0x13	; 19
    1178:	91 e0       	ldi	r25, 0x01	; 1
    117a:	6d e9       	ldi	r22, 0x9D	; 157
    117c:	77 e0       	ldi	r23, 0x07	; 7
    117e:	45 e2       	ldi	r20, 0x25	; 37
    1180:	56 e0       	ldi	r21, 0x06	; 6
    1182:	0e 94 c2 37 	call	0x6f84	; 0x6f84 <RNDIS_Device_ReadPacket>
    1186:	10 c0       	rjmp	.+32     	; 0x11a8 <uIPManagement_ManageNetwork+0x74>
	}
	else
	{
		/* If no packet received, exit processing routine */
		if (!(RNDIS_Host_IsPacketReceived(&Ethernet_RNDIS_Interface_Host)))
    1188:	8a ee       	ldi	r24, 0xEA	; 234
    118a:	91 e0       	ldi	r25, 0x01	; 1
    118c:	0e 94 83 3b 	call	0x7706	; 0x7706 <RNDIS_Host_IsPacketReceived>
    1190:	88 23       	and	r24, r24
    1192:	a1 f1       	breq	.+104    	; 0x11fc <uIPManagement_ManageNetwork+0xc8>
		  return;

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    1194:	80 ed       	ldi	r24, 0xD0	; 208
    1196:	6c df       	rcall	.-296    	; 0x1070 <LEDs_SetAllLEDs>

		/* Read the Incoming packet straight into the UIP packet buffer */
		RNDIS_Host_ReadPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, &uip_len);
    1198:	8a ee       	ldi	r24, 0xEA	; 234
    119a:	91 e0       	ldi	r25, 0x01	; 1
    119c:	6d e9       	ldi	r22, 0x9D	; 157
    119e:	77 e0       	ldi	r23, 0x07	; 7
    11a0:	45 e2       	ldi	r20, 0x25	; 37
    11a2:	56 e0       	ldi	r21, 0x06	; 6
    11a4:	0e 94 a0 3b 	call	0x7740	; 0x7740 <RNDIS_Host_ReadPacket>
	}

	/* If the packet contains an Ethernet frame, process it */
	if (uip_len > 0)
    11a8:	80 91 25 06 	lds	r24, 0x0625
    11ac:	90 91 26 06 	lds	r25, 0x0626
    11b0:	00 97       	sbiw	r24, 0x00	; 0
    11b2:	11 f1       	breq	.+68     	; 0x11f8 <uIPManagement_ManageNetwork+0xc4>
	{
		switch (((struct uip_eth_hdr*)uip_buf)->type)
    11b4:	80 91 a9 07 	lds	r24, 0x07A9
    11b8:	90 91 aa 07 	lds	r25, 0x07AA
    11bc:	88 30       	cpi	r24, 0x08	; 8
    11be:	91 05       	cpc	r25, r1
    11c0:	29 f0       	breq	.+10     	; 0x11cc <uIPManagement_ManageNetwork+0x98>
    11c2:	26 e0       	ldi	r18, 0x06	; 6
    11c4:	88 30       	cpi	r24, 0x08	; 8
    11c6:	92 07       	cpc	r25, r18
    11c8:	b9 f4       	brne	.+46     	; 0x11f8 <uIPManagement_ManageNetwork+0xc4>
    11ca:	0c c0       	rjmp	.+24     	; 0x11e4 <uIPManagement_ManageNetwork+0xb0>
			case HTONS(UIP_ETHTYPE_IP):
				/* Filter packet by MAC destination */
				uip_arp_ipin();

				/* Process Incoming packet */
				uip_input();
    11cc:	81 e0       	ldi	r24, 0x01	; 1
    11ce:	0e 94 5d 11 	call	0x22ba	; 0x22ba <uip_process>

				/* If a response was generated, send it */
				if (uip_len > 0)
    11d2:	80 91 25 06 	lds	r24, 0x0625
    11d6:	90 91 26 06 	lds	r25, 0x0626
    11da:	00 97       	sbiw	r24, 0x00	; 0
    11dc:	69 f0       	breq	.+26     	; 0x11f8 <uIPManagement_ManageNetwork+0xc4>
				{
					/* Add destination MAC to outgoing packet */
					uip_arp_out();
    11de:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <uip_arp_out>
    11e2:	08 c0       	rjmp	.+16     	; 0x11f4 <uIPManagement_ManageNetwork+0xc0>
				}

				break;
			case HTONS(UIP_ETHTYPE_ARP):
				/* Process ARP packet */
				uip_arp_arpin();
    11e4:	0e 94 4b 1a 	call	0x3496	; 0x3496 <uip_arp_arpin>

				/* If a response was generated, send it */
				if (uip_len > 0)
    11e8:	80 91 25 06 	lds	r24, 0x0625
    11ec:	90 91 26 06 	lds	r25, 0x0626
    11f0:	00 97       	sbiw	r24, 0x00	; 0
    11f2:	11 f0       	breq	.+4      	; 0x11f8 <uIPManagement_ManageNetwork+0xc4>
				  uip_split_output();
    11f4:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uip_split_output>

				break;
		}
	}

	LEDs_SetAllLEDs(LEDMASK_USB_READY);
    11f8:	80 e2       	ldi	r24, 0x20	; 32
    11fa:	3a df       	rcall	.-396    	; 0x1070 <LEDs_SetAllLEDs>

/** uIP Management function. This function manages the uIP stack when called while an RNDIS device has been
 *  attached to the system.
 */
void uIPManagement_ManageNetwork(void)
{
    11fc:	c0 e0       	ldi	r28, 0x00	; 0
    11fe:	d0 e0       	ldi	r29, 0x00	; 0
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		uip_poll_conn(&uip_conns[i]);
    1200:	01 e7       	ldi	r16, 0x71	; 113
    1202:	10 e0       	ldi	r17, 0x00	; 0
    1204:	c0 9f       	mul	r28, r16
    1206:	c0 01       	movw	r24, r0
    1208:	c1 9f       	mul	r28, r17
    120a:	90 0d       	add	r25, r0
    120c:	d0 9f       	mul	r29, r16
    120e:	90 0d       	add	r25, r0
    1210:	11 24       	eor	r1, r1
    1212:	8c 5c       	subi	r24, 0xCC	; 204
    1214:	99 4f       	sbci	r25, 0xF9	; 249
    1216:	90 93 33 06 	sts	0x0633, r25
    121a:	80 93 32 06 	sts	0x0632, r24
    121e:	83 e0       	ldi	r24, 0x03	; 3
    1220:	0e 94 5d 11 	call	0x22ba	; 0x22ba <uip_process>

		/* If a response was generated, send it */
		if (uip_len > 0)
    1224:	80 91 25 06 	lds	r24, 0x0625
    1228:	90 91 26 06 	lds	r25, 0x0626
    122c:	00 97       	sbiw	r24, 0x00	; 0
    122e:	21 f0       	breq	.+8      	; 0x1238 <uIPManagement_ManageNetwork+0x104>
		{
			/* Add destination MAC to outgoing packet */
			uip_arp_out();
    1230:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <uip_arp_out>

			/* Split and send the outgoing packet */
			uip_split_output();
    1234:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uip_split_output>
    1238:	21 96       	adiw	r28, 0x01	; 1

/** Manages the currently open network connections, including TCP and (if enabled) UDP. */
static void uIPManagement_ManageConnections(void)
{
	/* Poll TCP connections for more data to send back to the host */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    123a:	c3 30       	cpi	r28, 0x03	; 3
    123c:	d1 05       	cpc	r29, r1
    123e:	11 f7       	brne	.-60     	; 0x1204 <uIPManagement_ManageNetwork+0xd0>
			uip_split_output();
		}
	}

	/* Manage open connections for timeouts */
	if (timer_expired(&ConnectionTimer))
    1240:	86 e5       	ldi	r24, 0x56	; 86
    1242:	93 e0       	ldi	r25, 0x03	; 3
    1244:	0e 94 1e 1c 	call	0x383c	; 0x383c <timer_expired>
    1248:	00 97       	sbiw	r24, 0x00	; 0
    124a:	09 f4       	brne	.+2      	; 0x124e <uIPManagement_ManageNetwork+0x11a>
    124c:	3d c0       	rjmp	.+122    	; 0x12c8 <uIPManagement_ManageNetwork+0x194>
	{
		timer_reset(&ConnectionTimer);
    124e:	86 e5       	ldi	r24, 0x56	; 86
    1250:	93 e0       	ldi	r25, 0x03	; 3
    1252:	0e 94 14 1c 	call	0x3828	; 0x3828 <timer_reset>

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);
    1256:	80 ed       	ldi	r24, 0xD0	; 208
    1258:	0b df       	rcall	.-490    	; 0x1070 <LEDs_SetAllLEDs>
    125a:	c0 e0       	ldi	r28, 0x00	; 0
    125c:	d0 e0       	ldi	r29, 0x00	; 0

		for (uint8_t i = 0; i < UIP_CONNS; i++)
		{
			/* Run periodic connection management for each TCP connection */
			uip_periodic(i);
    125e:	01 e7       	ldi	r16, 0x71	; 113
    1260:	10 e0       	ldi	r17, 0x00	; 0
    1262:	c0 9f       	mul	r28, r16
    1264:	c0 01       	movw	r24, r0
    1266:	c1 9f       	mul	r28, r17
    1268:	90 0d       	add	r25, r0
    126a:	d0 9f       	mul	r29, r16
    126c:	90 0d       	add	r25, r0
    126e:	11 24       	eor	r1, r1
    1270:	8c 5c       	subi	r24, 0xCC	; 204
    1272:	99 4f       	sbci	r25, 0xF9	; 249
    1274:	90 93 33 06 	sts	0x0633, r25
    1278:	80 93 32 06 	sts	0x0632, r24
    127c:	82 e0       	ldi	r24, 0x02	; 2
    127e:	0e 94 5d 11 	call	0x22ba	; 0x22ba <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    1282:	80 91 25 06 	lds	r24, 0x0625
    1286:	90 91 26 06 	lds	r25, 0x0626
    128a:	00 97       	sbiw	r24, 0x00	; 0
    128c:	21 f0       	breq	.+8      	; 0x1296 <uIPManagement_ManageNetwork+0x162>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    128e:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    1292:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uip_split_output>
    1296:	21 96       	adiw	r28, 0x01	; 1
	{
		timer_reset(&ConnectionTimer);

		LEDs_SetAllLEDs(LEDMASK_USB_BUSY);

		for (uint8_t i = 0; i < UIP_CONNS; i++)
    1298:	c3 30       	cpi	r28, 0x03	; 3
    129a:	d1 05       	cpc	r29, r1
    129c:	11 f7       	brne	.-60     	; 0x1262 <uIPManagement_ManageNetwork+0x12e>

		#if defined(ENABLE_DHCP_CLIENT)
		for (uint8_t i = 0; i < UIP_UDP_CONNS; i++)
		{
			/* Run periodic connection management for each UDP connection */
			uip_udp_periodic(i);
    129e:	8b e8       	ldi	r24, 0x8B	; 139
    12a0:	9d e0       	ldi	r25, 0x0D	; 13
    12a2:	90 93 2f 06 	sts	0x062F, r25
    12a6:	80 93 2e 06 	sts	0x062E, r24
    12aa:	85 e0       	ldi	r24, 0x05	; 5
    12ac:	0e 94 5d 11 	call	0x22ba	; 0x22ba <uip_process>

			/* If a response was generated, send it */
			if (uip_len > 0)
    12b0:	80 91 25 06 	lds	r24, 0x0625
    12b4:	90 91 26 06 	lds	r25, 0x0626
    12b8:	00 97       	sbiw	r24, 0x00	; 0
    12ba:	21 f0       	breq	.+8      	; 0x12c4 <uIPManagement_ManageNetwork+0x190>
			{
				/* Add destination MAC to outgoing packet */
				uip_arp_out();
    12bc:	0e 94 f9 1a 	call	0x35f2	; 0x35f2 <uip_arp_out>

				/* Split and send the outgoing packet */
				uip_split_output();
    12c0:	0e 94 60 1c 	call	0x38c0	; 0x38c0 <uip_split_output>
			}
		}
		#endif

		LEDs_SetAllLEDs(LEDMASK_USB_READY);
    12c4:	80 e2       	ldi	r24, 0x20	; 32
    12c6:	d4 de       	rcall	.-600    	; 0x1070 <LEDs_SetAllLEDs>
	}

	/* Manage ARP cache refreshing */
	if (timer_expired(&ARPTimer))
    12c8:	8a e5       	ldi	r24, 0x5A	; 90
    12ca:	93 e0       	ldi	r25, 0x03	; 3
    12cc:	0e 94 1e 1c 	call	0x383c	; 0x383c <timer_expired>
    12d0:	00 97       	sbiw	r24, 0x00	; 0
    12d2:	31 f0       	breq	.+12     	; 0x12e0 <uIPManagement_ManageNetwork+0x1ac>
	{
		timer_reset(&ARPTimer);
    12d4:	8a e5       	ldi	r24, 0x5A	; 90
    12d6:	93 e0       	ldi	r25, 0x03	; 3
    12d8:	0e 94 14 1c 	call	0x3828	; 0x3828 <timer_reset>
		uip_arp_timer();
    12dc:	0e 94 0f 1a 	call	0x341e	; 0x341e <uip_arp_timer>
	    ((USB_CurrentMode == USB_MODE_Device) && (USB_DeviceState == DEVICE_STATE_Configured)))
	{
		uIPManagement_ProcessIncomingPacket();
		uIPManagement_ManageConnections();
	}
}
    12e0:	df 91       	pop	r29
    12e2:	cf 91       	pop	r28
    12e4:	1f 91       	pop	r17
    12e6:	0f 91       	pop	r16
    12e8:	08 95       	ret

000012ea <uIPManagement_TCPCallback>:
 *  to the appropriate TCP protocol application based on the connection's listen port number.
 */
void uIPManagement_TCPCallback(void)
{
	/* Call the correct TCP application based on the port number the connection is listening on */
	switch (uip_conn->lport)
    12ea:	e0 91 32 06 	lds	r30, 0x0632
    12ee:	f0 91 33 06 	lds	r31, 0x0633
    12f2:	84 81       	ldd	r24, Z+4	; 0x04
    12f4:	95 81       	ldd	r25, Z+5	; 0x05
    12f6:	27 e1       	ldi	r18, 0x17	; 23
    12f8:	80 30       	cpi	r24, 0x00	; 0
    12fa:	92 07       	cpc	r25, r18
    12fc:	29 f0       	breq	.+10     	; 0x1308 <uIPManagement_TCPCallback+0x1e>
    12fe:	20 e5       	ldi	r18, 0x50	; 80
    1300:	80 30       	cpi	r24, 0x00	; 0
    1302:	92 07       	cpc	r25, r18
    1304:	11 f4       	brne	.+4      	; 0x130a <uIPManagement_TCPCallback+0x20>
	{
		case HTONS(HTTP_SERVER_PORT):
			HTTPServerApp_Callback();
			break;
    1306:	f8 c3       	rjmp	.+2032   	; 0x1af8 <HTTPServerApp_Callback>
		#if defined(ENABLE_TELNET_SERVER)
		case HTONS(TELNET_SERVER_PORT):
			TELNETServerApp_Callback();
    1308:	76 c5       	rjmp	.+2796   	; 0x1df6 <TELNETServerApp_Callback>
    130a:	08 95       	ret

0000130c <uIPManagement_UDPCallback>:
 *  to the appropriate UDP protocol application based on the connection's listen port number.
 */
void uIPManagement_UDPCallback(void)
{
	/* Call the correct UDP application based on the port number the connection is listening on */
	switch (uip_udp_conn->lport)
    130c:	e0 91 2e 06 	lds	r30, 0x062E
    1310:	f0 91 2f 06 	lds	r31, 0x062F
    1314:	84 81       	ldd	r24, Z+4	; 0x04
    1316:	95 81       	ldd	r25, Z+5	; 0x05
    1318:	23 e4       	ldi	r18, 0x43	; 67
    131a:	80 30       	cpi	r24, 0x00	; 0
    131c:	92 07       	cpc	r25, r18
    131e:	29 f0       	breq	.+10     	; 0x132a <uIPManagement_UDPCallback+0x1e>
    1320:	24 e4       	ldi	r18, 0x44	; 68
    1322:	80 30       	cpi	r24, 0x00	; 0
    1324:	92 07       	cpc	r25, r18
    1326:	11 f4       	brne	.+4      	; 0x132c <uIPManagement_UDPCallback+0x20>
	{
		#if defined(ENABLE_DHCP_CLIENT)
		case HTONS(DHCP_CLIENT_PORT):
			DHCPClientApp_Callback();
			break;
    1328:	b5 c0       	rjmp	.+362    	; 0x1494 <DHCPClientApp_Callback>
		#endif
		#if defined(ENABLE_DHCP_SERVER)
		case HTONS(DHCP_SERVER_PORT):
			DHCPServerApp_Callback();
    132a:	86 c2       	rjmp	.+1292   	; 0x1838 <DHCPServerApp_Callback>
    132c:	08 95       	ret

0000132e <DHCPCommon_SetOption>:
 */
uint8_t DHCPCommon_SetOption(uint8_t* DHCPOptionList,
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
    132e:	0f 93       	push	r16
    1330:	1f 93       	push	r17
    1332:	cf 93       	push	r28
    1334:	df 93       	push	r29
    1336:	ec 01       	movw	r28, r24
    1338:	14 2f       	mov	r17, r20
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    133a:	05 c0       	rjmp	.+10     	; 0x1346 <DHCPCommon_SetOption+0x18>
	  DHCPOptionList += (DHCPOptionList[1] + 2);
    133c:	89 81       	ldd	r24, Y+1	; 0x01
    133e:	90 e0       	ldi	r25, 0x00	; 0
    1340:	02 96       	adiw	r24, 0x02	; 2
    1342:	c8 0f       	add	r28, r24
    1344:	d9 1f       	adc	r29, r25
                             const uint8_t Option,
                             const uint8_t DataLen,
                             void* const OptionData)
{
	/* Skip through the DHCP options list until the terminator option is found */
	while (*DHCPOptionList != DHCP_OPTION_END)
    1346:	08 81       	ld	r16, Y
    1348:	0f 3f       	cpi	r16, 0xFF	; 255
    134a:	c1 f7       	brne	.-16     	; 0x133c <DHCPCommon_SetOption+0xe>
	  DHCPOptionList += (DHCPOptionList[1] + 2);

	/* Overwrite the existing terminator with the new option, add a new terminator at the end of the list */
	DHCPOptionList[0] = Option;
    134c:	68 83       	st	Y, r22
	DHCPOptionList[1] = DataLen;
    134e:	19 83       	std	Y+1, r17	; 0x01
	memcpy(&DHCPOptionList[2], OptionData, DataLen);
    1350:	ae 01       	movw	r20, r28
    1352:	4e 5f       	subi	r20, 0xFE	; 254
    1354:	5f 4f       	sbci	r21, 0xFF	; 255
    1356:	ca 01       	movw	r24, r20
    1358:	b9 01       	movw	r22, r18
    135a:	41 2f       	mov	r20, r17
    135c:	50 e0       	ldi	r21, 0x00	; 0
    135e:	0e 94 0a 3d 	call	0x7a14	; 0x7a14 <memcpy>
	DHCPOptionList[2 + DataLen] = DHCP_OPTION_END;
    1362:	c1 0f       	add	r28, r17
    1364:	d1 1d       	adc	r29, r1
    1366:	0a 83       	std	Y+2, r16	; 0x02

	/* Calculate the total number of bytes added to the outgoing packet */
	return (2 + DataLen);
}
    1368:	81 2f       	mov	r24, r17
    136a:	8e 5f       	subi	r24, 0xFE	; 254
    136c:	df 91       	pop	r29
    136e:	cf 91       	pop	r28
    1370:	1f 91       	pop	r17
    1372:	0f 91       	pop	r16
    1374:	08 95       	ret

00001376 <DHCPCommon_GetOption>:
 *  \return Boolean true if the option was found in the DHCP packet's options list, false otherwise
 */
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
    1376:	fc 01       	movw	r30, r24
    1378:	ca 01       	movw	r24, r20
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    137a:	10 c0       	rjmp	.+32     	; 0x139c <DHCPCommon_GetOption+0x26>
    137c:	21 81       	ldd	r18, Z+1	; 0x01
	{
		/* Check if the current DHCP option in the packet is the one requested */
		if (DHCPOptionList[0] == Option)
    137e:	36 17       	cp	r19, r22
    1380:	41 f4       	brne	.+16     	; 0x1392 <DHCPCommon_GetOption+0x1c>
		{
			/* Copy request option's data to the destination buffer */
			memcpy(Destination, &DHCPOptionList[2], DHCPOptionList[1]);
    1382:	32 96       	adiw	r30, 0x02	; 2
    1384:	bf 01       	movw	r22, r30
    1386:	42 2f       	mov	r20, r18
    1388:	50 e0       	ldi	r21, 0x00	; 0
    138a:	0e 94 0a 3d 	call	0x7a14	; 0x7a14 <memcpy>

			/* Indicate that the requested option data was successfully retrieved */
			return true;
    138e:	81 e0       	ldi	r24, 0x01	; 1
    1390:	08 95       	ret
		}

		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
    1392:	30 e0       	ldi	r19, 0x00	; 0
    1394:	2e 5f       	subi	r18, 0xFE	; 254
    1396:	3f 4f       	sbci	r19, 0xFF	; 255
    1398:	e2 0f       	add	r30, r18
    139a:	f3 1f       	adc	r31, r19
bool DHCPCommon_GetOption(const uint8_t* DHCPOptionList,
                          const uint8_t Option,
                          void* const Destination)
{
	/* Look through the incoming DHCP packet's options list for the requested option */
	while (*DHCPOptionList != DHCP_OPTION_END)
    139c:	30 81       	ld	r19, Z
    139e:	3f 3f       	cpi	r19, 0xFF	; 255
    13a0:	69 f7       	brne	.-38     	; 0x137c <DHCPCommon_GetOption+0x6>
		/* Skip to next DHCP option in the options list */
		DHCPOptionList += (DHCPOptionList[1] + 2);
	}

	/* Requested option not found in the incoming packet's DHCP options list */
	return false;
    13a2:	80 e0       	ldi	r24, 0x00	; 0
}
    13a4:	08 95       	ret

000013a6 <DHCPClientApp_FillDHCPHeader>:
 *  \return Size in bytes of the created DHCP packet
 */
static uint16_t DHCPClientApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             uip_udp_appstate_t* const AppState)
{
    13a6:	cf 93       	push	r28
    13a8:	df 93       	push	r29
    13aa:	fc 01       	movw	r30, r24
    13ac:	ea 01       	movw	r28, r20
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    13ae:	80 ef       	ldi	r24, 0xF0	; 240
    13b0:	df 01       	movw	r26, r30
    13b2:	1d 92       	st	X+, r1
    13b4:	8a 95       	dec	r24
    13b6:	e9 f7       	brne	.-6      	; 0x13b2 <DHCPClientApp_FillDHCPHeader+0xc>

	/* Fill out the DHCP packet header */
	DHCPHeader->Operation             = DHCP_OP_BOOTREQUEST;
    13b8:	81 e0       	ldi	r24, 0x01	; 1
    13ba:	80 83       	st	Z, r24
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    13bc:	81 83       	std	Z+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    13be:	86 e0       	ldi	r24, 0x06	; 6
    13c0:	82 83       	std	Z+2, r24	; 0x02
	DHCPHeader->Hops                  = 0;
    13c2:	13 82       	std	Z+3, r1	; 0x03
	DHCPHeader->TransactionID         = DHCP_TRANSACTION_ID;
    13c4:	86 e6       	ldi	r24, 0x66	; 102
    13c6:	94 e5       	ldi	r25, 0x54	; 84
    13c8:	a4 e2       	ldi	r26, 0x24	; 36
    13ca:	b3 e1       	ldi	r27, 0x13	; 19
    13cc:	84 83       	std	Z+4, r24	; 0x04
    13ce:	95 83       	std	Z+5, r25	; 0x05
    13d0:	a6 83       	std	Z+6, r26	; 0x06
    13d2:	b7 83       	std	Z+7, r27	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    13d4:	11 86       	std	Z+9, r1	; 0x09
    13d6:	10 86       	std	Z+8, r1	; 0x08
	DHCPHeader->Flags                 = HTONS(BOOTP_BROADCAST);
    13d8:	80 e8       	ldi	r24, 0x80	; 128
    13da:	90 e0       	ldi	r25, 0x00	; 0
    13dc:	93 87       	std	Z+11, r25	; 0x0b
    13de:	82 87       	std	Z+10, r24	; 0x0a
	memcpy(&DHCPHeader->ClientIP,     &uip_hostaddr,        sizeof(uip_ipaddr_t));
    13e0:	80 91 99 07 	lds	r24, 0x0799
    13e4:	90 91 9a 07 	lds	r25, 0x079A
    13e8:	a0 91 9b 07 	lds	r26, 0x079B
    13ec:	b0 91 9c 07 	lds	r27, 0x079C
    13f0:	84 87       	std	Z+12, r24	; 0x0c
    13f2:	95 87       	std	Z+13, r25	; 0x0d
    13f4:	a6 87       	std	Z+14, r26	; 0x0e
    13f6:	b7 87       	std	Z+15, r27	; 0x0f
	memcpy(&DHCPHeader->YourIP,       &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, sizeof(uip_ipaddr_t));
    13f8:	8d 81       	ldd	r24, Y+5	; 0x05
    13fa:	9e 81       	ldd	r25, Y+6	; 0x06
    13fc:	af 81       	ldd	r26, Y+7	; 0x07
    13fe:	b8 85       	ldd	r27, Y+8	; 0x08
    1400:	80 8b       	std	Z+16, r24	; 0x10
    1402:	91 8b       	std	Z+17, r25	; 0x11
    1404:	a2 8b       	std	Z+18, r26	; 0x12
    1406:	b3 8b       	std	Z+19, r27	; 0x13
	memcpy(&DHCPHeader->NextServerIP, &AppState->DHCPClient.DHCPOffer_Data.ServerIP,    sizeof(uip_ipaddr_t));
    1408:	89 89       	ldd	r24, Y+17	; 0x11
    140a:	9a 89       	ldd	r25, Y+18	; 0x12
    140c:	ab 89       	ldd	r26, Y+19	; 0x13
    140e:	bc 89       	ldd	r27, Y+20	; 0x14
    1410:	84 8b       	std	Z+20, r24	; 0x14
    1412:	95 8b       	std	Z+21, r25	; 0x15
    1414:	a6 8b       	std	Z+22, r26	; 0x16
    1416:	b7 8b       	std	Z+23, r27	; 0x17
	memcpy(&DHCPHeader->ClientHardwareAddress, &MACAddress, sizeof(struct uip_eth_addr));
    1418:	ef 01       	movw	r28, r30
    141a:	6c 96       	adiw	r28, 0x1c	; 28
    141c:	ac ed       	ldi	r26, 0xDC	; 220
    141e:	b3 e0       	ldi	r27, 0x03	; 3
    1420:	86 e0       	ldi	r24, 0x06	; 6
    1422:	0d 90       	ld	r0, X+
    1424:	09 92       	st	Y+, r0
    1426:	81 50       	subi	r24, 0x01	; 1
    1428:	e1 f7       	brne	.-8      	; 0x1422 <DHCPClientApp_FillDHCPHeader+0x7c>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    142a:	ef 01       	movw	r28, r30
    142c:	c4 51       	subi	r28, 0x14	; 20
    142e:	df 4f       	sbci	r29, 0xFF	; 255
    1430:	83 e6       	ldi	r24, 0x63	; 99
    1432:	92 e8       	ldi	r25, 0x82	; 130
    1434:	a3 e5       	ldi	r26, 0x53	; 83
    1436:	b3 e6       	ldi	r27, 0x63	; 99
    1438:	88 83       	st	Y, r24
    143a:	99 83       	std	Y+1, r25	; 0x01
    143c:	aa 83       	std	Y+2, r26	; 0x02
    143e:	bb 83       	std	Y+3, r27	; 0x03

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1440:	df 01       	movw	r26, r30
    1442:	a0 51       	subi	r26, 0x10	; 16
    1444:	bf 4f       	sbci	r27, 0xFF	; 255
    1446:	85 e3       	ldi	r24, 0x35	; 53
    1448:	8c 93       	st	X, r24
	DHCPHeader->Options[1]            = 1;
    144a:	df 01       	movw	r26, r30
    144c:	af 50       	subi	r26, 0x0F	; 15
    144e:	bf 4f       	sbci	r27, 0xFF	; 255
    1450:	81 e0       	ldi	r24, 0x01	; 1
    1452:	8c 93       	st	X, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    1454:	df 01       	movw	r26, r30
    1456:	ae 50       	subi	r26, 0x0E	; 14
    1458:	bf 4f       	sbci	r27, 0xFF	; 255
    145a:	6c 93       	st	X, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    145c:	ed 50       	subi	r30, 0x0D	; 13
    145e:	ff 4f       	sbci	r31, 0xFF	; 255
    1460:	8f ef       	ldi	r24, 0xFF	; 255
    1462:	80 83       	st	Z, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    1464:	84 ef       	ldi	r24, 0xF4	; 244
    1466:	90 e0       	ldi	r25, 0x00	; 0
    1468:	df 91       	pop	r29
    146a:	cf 91       	pop	r28
    146c:	08 95       	ret

0000146e <DHCPClientApp_Init>:

/** Initialization function for the DHCP client. */
void DHCPClientApp_Init(void)
{
	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* Connection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_SERVER_PORT));
    146e:	80 e2       	ldi	r24, 0x20	; 32
    1470:	93 e0       	ldi	r25, 0x03	; 3
    1472:	60 e0       	ldi	r22, 0x00	; 0
    1474:	73 e4       	ldi	r23, 0x43	; 67
    1476:	86 d6       	rcall	.+3340   	; 0x2184 <uip_udp_new>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (Connection != NULL)
    1478:	00 97       	sbiw	r24, 0x00	; 0
    147a:	59 f0       	breq	.+22     	; 0x1492 <DHCPClientApp_Init+0x24>
	{
		uip_udp_appstate_t* const AppState = &Connection->appstate;
		uip_udp_bind(Connection, HTONS(DHCP_CLIENT_PORT));
    147c:	20 e0       	ldi	r18, 0x00	; 0
    147e:	34 e4       	ldi	r19, 0x44	; 68
    1480:	fc 01       	movw	r30, r24
    1482:	35 83       	std	Z+5, r19	; 0x05
    1484:	24 83       	std	Z+4, r18	; 0x04

		/* Set the initial client state */
		AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1486:	11 86       	std	Z+9, r1	; 0x09

		/* Set timeout period to half a second for a DHCP server to respond */
		timer_set(&AppState->DHCPClient.Timeout, CLOCK_SECOND / 2);
    1488:	0a 96       	adiw	r24, 0x0a	; 10
    148a:	62 e3       	ldi	r22, 0x32	; 50
    148c:	70 e0       	ldi	r23, 0x00	; 0
    148e:	0c 94 09 1c 	jmp	0x3812	; 0x3812 <timer_set>
    1492:	08 95       	ret

00001494 <DHCPClientApp_Callback>:

/** uIP stack application callback for the DHCP client. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPClientApp_Callback(void)
{
    1494:	af 92       	push	r10
    1496:	bf 92       	push	r11
    1498:	cf 92       	push	r12
    149a:	df 92       	push	r13
    149c:	ef 92       	push	r14
    149e:	ff 92       	push	r15
    14a0:	0f 93       	push	r16
    14a2:	1f 93       	push	r17
    14a4:	df 93       	push	r29
    14a6:	cf 93       	push	r28
    14a8:	00 d0       	rcall	.+0      	; 0x14aa <DHCPClientApp_Callback+0x16>
    14aa:	00 d0       	rcall	.+0      	; 0x14ac <DHCPClientApp_Callback+0x18>
    14ac:	0f 92       	push	r0
    14ae:	cd b7       	in	r28, 0x3d	; 61
    14b0:	de b7       	in	r29, 0x3e	; 62
	uip_udp_appstate_t* const AppState    = &uip_udp_conn->appstate;
    14b2:	00 91 2e 06 	lds	r16, 0x062E
    14b6:	10 91 2f 06 	lds	r17, 0x062F
    14ba:	a8 01       	movw	r20, r16
    14bc:	47 5f       	subi	r20, 0xF7	; 247
    14be:	5f 4f       	sbci	r21, 0xFF	; 255
	DHCP_Header_t*      const AppData     = (DHCP_Header_t*)uip_appdata;
    14c0:	e0 90 30 06 	lds	r14, 0x0630
    14c4:	f0 90 31 06 	lds	r15, 0x0631
	uint16_t                  AppDataSize = 0;

	switch (AppState->DHCPClient.CurrentState)
    14c8:	d8 01       	movw	r26, r16
    14ca:	19 96       	adiw	r26, 0x09	; 9
    14cc:	8c 91       	ld	r24, X
    14ce:	19 97       	sbiw	r26, 0x09	; 9
    14d0:	81 30       	cpi	r24, 0x01	; 1
    14d2:	09 f4       	brne	.+2      	; 0x14d6 <DHCPClientApp_Callback+0x42>
    14d4:	43 c0       	rjmp	.+134    	; 0x155c <DHCPClientApp_Callback+0xc8>
    14d6:	81 30       	cpi	r24, 0x01	; 1
    14d8:	38 f0       	brcs	.+14     	; 0x14e8 <DHCPClientApp_Callback+0x54>
    14da:	82 30       	cpi	r24, 0x02	; 2
    14dc:	09 f4       	brne	.+2      	; 0x14e0 <DHCPClientApp_Callback+0x4c>
    14de:	88 c0       	rjmp	.+272    	; 0x15f0 <DHCPClientApp_Callback+0x15c>
    14e0:	83 30       	cpi	r24, 0x03	; 3
    14e2:	09 f0       	breq	.+2      	; 0x14e6 <DHCPClientApp_Callback+0x52>
    14e4:	01 c1       	rjmp	.+514    	; 0x16e8 <DHCPClientApp_Callback+0x254>
    14e6:	b1 c0       	rjmp	.+354    	; 0x164a <DHCPClientApp_Callback+0x1b6>
	{
		case DHCP_STATE_SendDiscover:
			/* Clear all DHCP settings, reset client IP address */
			memset(&AppState->DHCPClient.DHCPOffer_Data, 0x00, sizeof(AppState->DHCPClient.DHCPOffer_Data));
    14e8:	c8 01       	movw	r24, r16
    14ea:	0e 96       	adiw	r24, 0x0e	; 14
    14ec:	fc 01       	movw	r30, r24
    14ee:	80 e1       	ldi	r24, 0x10	; 16
    14f0:	df 01       	movw	r26, r30
    14f2:	1d 92       	st	X+, r1
    14f4:	8a 95       	dec	r24
    14f6:	e9 f7       	brne	.-6      	; 0x14f2 <DHCPClientApp_Callback+0x5e>
			uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    14f8:	f8 01       	movw	r30, r16
    14fa:	86 85       	ldd	r24, Z+14	; 0x0e
    14fc:	97 85       	ldd	r25, Z+15	; 0x0f
    14fe:	a0 89       	ldd	r26, Z+16	; 0x10
    1500:	b1 89       	ldd	r27, Z+17	; 0x11
    1502:	80 93 99 07 	sts	0x0799, r24
    1506:	90 93 9a 07 	sts	0x079A, r25
    150a:	a0 93 9b 07 	sts	0x079B, r26
    150e:	b0 93 9c 07 	sts	0x079C, r27

			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_DISCOVER, AppState);
    1512:	c7 01       	movw	r24, r14
    1514:	61 e0       	ldi	r22, 0x01	; 1
    1516:	47 df       	rcall	.-370    	; 0x13a6 <DHCPClientApp_FillDHCPHeader>
    1518:	6c 01       	movw	r12, r24

			/* Add the required DHCP options list to the packet */
			uint8_t RequiredOptionList[] = {DHCP_OPTION_SUBNET_MASK, DHCP_OPTION_ROUTER, DHCP_OPTION_DNS_SERVER};
    151a:	de 01       	movw	r26, r28
    151c:	13 96       	adiw	r26, 0x03	; 3
    151e:	e0 e4       	ldi	r30, 0x40	; 64
    1520:	f2 e0       	ldi	r31, 0x02	; 2
    1522:	83 e0       	ldi	r24, 0x03	; 3
    1524:	01 90       	ld	r0, Z+
    1526:	0d 92       	st	X+, r0
    1528:	81 50       	subi	r24, 0x01	; 1
    152a:	e1 f7       	brne	.-8      	; 0x1524 <DHCPClientApp_Callback+0x90>
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_LIST, sizeof(RequiredOptionList),
    152c:	c7 01       	movw	r24, r14
    152e:	80 51       	subi	r24, 0x10	; 16
    1530:	9f 4f       	sbci	r25, 0xFF	; 255
    1532:	67 e3       	ldi	r22, 0x37	; 55
    1534:	43 e0       	ldi	r20, 0x03	; 3
    1536:	9e 01       	movw	r18, r28
    1538:	2d 5f       	subi	r18, 0xFD	; 253
    153a:	3f 4f       	sbci	r19, 0xFF	; 255
    153c:	f8 de       	rcall	.-528    	; 0x132e <DHCPCommon_SetOption>
    153e:	b6 01       	movw	r22, r12
    1540:	68 0f       	add	r22, r24
    1542:	71 1d       	adc	r23, r1
			                                    RequiredOptionList);

			/* Send the DHCP DISCOVER packet */
			uip_udp_send(AppDataSize);
    1544:	80 91 30 06 	lds	r24, 0x0630
    1548:	90 91 31 06 	lds	r25, 0x0631
    154c:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1550:	c8 01       	movw	r24, r16
    1552:	0a 96       	adiw	r24, 0x0a	; 10
    1554:	0e 94 14 1c 	call	0x3828	; 0x3828 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForOffer;
    1558:	81 e0       	ldi	r24, 0x01	; 1
    155a:	72 c0       	rjmp	.+228    	; 0x1640 <DHCPClientApp_Callback+0x1ac>

			break;
		case DHCP_STATE_WaitForOffer:
			if (!(uip_newdata()))
    155c:	80 91 2d 06 	lds	r24, 0x062D
    1560:	81 ff       	sbrs	r24, 1
    1562:	77 c0       	rjmp	.+238    	; 0x1652 <DHCPClientApp_Callback+0x1be>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1564:	f7 01       	movw	r30, r14
    1566:	84 81       	ldd	r24, Z+4	; 0x04
    1568:	95 81       	ldd	r25, Z+5	; 0x05
    156a:	a6 81       	ldd	r26, Z+6	; 0x06
    156c:	b7 81       	ldd	r27, Z+7	; 0x07
    156e:	86 36       	cpi	r24, 0x66	; 102
    1570:	f4 e5       	ldi	r31, 0x54	; 84
    1572:	9f 07       	cpc	r25, r31
    1574:	f4 e2       	ldi	r31, 0x24	; 36
    1576:	af 07       	cpc	r26, r31
    1578:	f3 e1       	ldi	r31, 0x13	; 19
    157a:	bf 07       	cpc	r27, r31
    157c:	09 f0       	breq	.+2      	; 0x1580 <DHCPClientApp_Callback+0xec>
    157e:	b4 c0       	rjmp	.+360    	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    1580:	80 ef       	ldi	r24, 0xF0	; 240
    1582:	c8 2e       	mov	r12, r24
    1584:	d1 2c       	mov	r13, r1
    1586:	ce 0c       	add	r12, r14
    1588:	df 1c       	adc	r13, r15
    158a:	c6 01       	movw	r24, r12
    158c:	65 e3       	ldi	r22, 0x35	; 53
    158e:	ae 01       	movw	r20, r28
    1590:	4f 5f       	subi	r20, 0xFF	; 255
    1592:	5f 4f       	sbci	r21, 0xFF	; 255
    1594:	f0 de       	rcall	.-544    	; 0x1376 <DHCPCommon_GetOption>

				break;
			}

			uint8_t OfferResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1596:	88 23       	and	r24, r24
    1598:	09 f4       	brne	.+2      	; 0x159c <DHCPClientApp_Callback+0x108>
    159a:	a6 c0       	rjmp	.+332    	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &OfferResponse_MessageType) &&
    159c:	a9 80       	ldd	r10, Y+1	; 0x01
    159e:	2a 2d       	mov	r18, r10
    15a0:	22 30       	cpi	r18, 0x02	; 2
    15a2:	09 f0       	breq	.+2      	; 0x15a6 <DHCPClientApp_Callback+0x112>
    15a4:	a1 c0       	rjmp	.+322    	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    (OfferResponse_MessageType == DHCP_OFFER))
			{
				/* Received a DHCP offer for an IP address, copy over values for later request */
				memcpy(&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP, &AppData->YourIP, sizeof(uip_ipaddr_t));
    15a6:	f7 01       	movw	r30, r14
    15a8:	80 89       	ldd	r24, Z+16	; 0x10
    15aa:	91 89       	ldd	r25, Z+17	; 0x11
    15ac:	a2 89       	ldd	r26, Z+18	; 0x12
    15ae:	b3 89       	ldd	r27, Z+19	; 0x13
    15b0:	f8 01       	movw	r30, r16
    15b2:	86 87       	std	Z+14, r24	; 0x0e
    15b4:	97 87       	std	Z+15, r25	; 0x0f
    15b6:	a0 8b       	std	Z+16, r26	; 0x10
    15b8:	b1 8b       	std	Z+17, r27	; 0x11
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK, &AppState->DHCPClient.DHCPOffer_Data.Netmask);
    15ba:	a8 01       	movw	r20, r16
    15bc:	4e 5e       	subi	r20, 0xEE	; 238
    15be:	5f 4f       	sbci	r21, 0xFF	; 255
    15c0:	c6 01       	movw	r24, r12
    15c2:	61 e0       	ldi	r22, 0x01	; 1
    15c4:	d8 de       	rcall	.-592    	; 0x1376 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_ROUTER,      &AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    15c6:	a8 01       	movw	r20, r16
    15c8:	4a 5e       	subi	r20, 0xEA	; 234
    15ca:	5f 4f       	sbci	r21, 0xFF	; 255
    15cc:	c6 01       	movw	r24, r12
    15ce:	63 e0       	ldi	r22, 0x03	; 3
    15d0:	d2 de       	rcall	.-604    	; 0x1376 <DHCPCommon_GetOption>
				DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_SERVER_ID,   &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    15d2:	a8 01       	movw	r20, r16
    15d4:	46 5e       	subi	r20, 0xE6	; 230
    15d6:	5f 4f       	sbci	r21, 0xFF	; 255
    15d8:	c6 01       	movw	r24, r12
    15da:	66 e3       	ldi	r22, 0x36	; 54
    15dc:	cc de       	rcall	.-616    	; 0x1376 <DHCPCommon_GetOption>

				timer_reset(&AppState->DHCPClient.Timeout);
    15de:	c8 01       	movw	r24, r16
    15e0:	0a 96       	adiw	r24, 0x0a	; 10
    15e2:	0e 94 14 1c 	call	0x3828	; 0x3828 <timer_reset>
				AppState->DHCPClient.CurrentState = DHCP_STATE_SendRequest;
    15e6:	d8 01       	movw	r26, r16
    15e8:	19 96       	adiw	r26, 0x09	; 9
    15ea:	ac 92       	st	X, r10
    15ec:	19 97       	sbiw	r26, 0x09	; 9
    15ee:	7c c0       	rjmp	.+248    	; 0x16e8 <DHCPClientApp_Callback+0x254>
			}

			break;
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);
    15f0:	c7 01       	movw	r24, r14
    15f2:	63 e0       	ldi	r22, 0x03	; 3
    15f4:	d8 de       	rcall	.-592    	; 0x13a6 <DHCPClientApp_FillDHCPHeader>
    15f6:	5c 01       	movw	r10, r24

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    15f8:	e0 ef       	ldi	r30, 0xF0	; 240
    15fa:	f0 e0       	ldi	r31, 0x00	; 0
    15fc:	ee 0e       	add	r14, r30
    15fe:	ff 1e       	adc	r15, r31
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    1600:	98 01       	movw	r18, r16
    1602:	22 5f       	subi	r18, 0xF2	; 242
    1604:	3f 4f       	sbci	r19, 0xFF	; 255
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    1606:	c7 01       	movw	r24, r14
    1608:	62 e3       	ldi	r22, 0x32	; 50
    160a:	44 e0       	ldi	r20, 0x04	; 4
    160c:	90 de       	rcall	.-736    	; 0x132e <DHCPCommon_SetOption>
    160e:	c8 2e       	mov	r12, r24
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);
    1610:	98 01       	movw	r18, r16
    1612:	26 5e       	subi	r18, 0xE6	; 230
    1614:	3f 4f       	sbci	r19, 0xFF	; 255
			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    1616:	c7 01       	movw	r24, r14
    1618:	66 e3       	ldi	r22, 0x36	; 54
    161a:	44 e0       	ldi	r20, 0x04	; 4
    161c:	88 de       	rcall	.-752    	; 0x132e <DHCPCommon_SetOption>
    161e:	68 2f       	mov	r22, r24
    1620:	70 e0       	ldi	r23, 0x00	; 0
		case DHCP_STATE_SendRequest:
			/* Fill out the DHCP response header */
			AppDataSize += DHCPClientApp_FillDHCPHeader(AppData, DHCP_REQUEST, AppState);

			/* Add the DHCP REQUESTED IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, sizeof(uip_ipaddr_t),
    1622:	6c 0d       	add	r22, r12
    1624:	71 1d       	adc	r23, r1
			                                    &AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);

			/* Add the DHCP SERVER IP ADDRESS option to the packet */
			AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SERVER_ID, sizeof(uip_ipaddr_t),
    1626:	6a 0d       	add	r22, r10
    1628:	7b 1d       	adc	r23, r11
			                                    &AppState->DHCPClient.DHCPOffer_Data.ServerIP);

			/* Send the DHCP REQUEST packet */
			uip_udp_send(AppDataSize);
    162a:	80 91 30 06 	lds	r24, 0x0630
    162e:	90 91 31 06 	lds	r25, 0x0631
    1632:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

			/* Reset the timeout timer, progress to next state */
			timer_reset(&AppState->DHCPClient.Timeout);
    1636:	c8 01       	movw	r24, r16
    1638:	0a 96       	adiw	r24, 0x0a	; 10
    163a:	0e 94 14 1c 	call	0x3828	; 0x3828 <timer_reset>
			AppState->DHCPClient.CurrentState = DHCP_STATE_WaitForACK;
    163e:	83 e0       	ldi	r24, 0x03	; 3
    1640:	d8 01       	movw	r26, r16
    1642:	19 96       	adiw	r26, 0x09	; 9
    1644:	8c 93       	st	X, r24
    1646:	19 97       	sbiw	r26, 0x09	; 9

			break;
    1648:	4f c0       	rjmp	.+158    	; 0x16e8 <DHCPClientApp_Callback+0x254>
		case DHCP_STATE_WaitForACK:
			if (!(uip_newdata()))
    164a:	80 91 2d 06 	lds	r24, 0x062D
    164e:	81 fd       	sbrc	r24, 1
    1650:	0a c0       	rjmp	.+20     	; 0x1666 <DHCPClientApp_Callback+0x1d2>
			{
				/* Check if the DHCP timeout period has expired while waiting for a response */
				if (timer_expired(&AppState->DHCPClient.Timeout))
    1652:	c8 01       	movw	r24, r16
    1654:	0a 96       	adiw	r24, 0x0a	; 10
    1656:	0e 94 1e 1c 	call	0x383c	; 0x383c <timer_expired>
    165a:	00 97       	sbiw	r24, 0x00	; 0
    165c:	09 f4       	brne	.+2      	; 0x1660 <DHCPClientApp_Callback+0x1cc>
    165e:	44 c0       	rjmp	.+136    	; 0x16e8 <DHCPClientApp_Callback+0x254>
				  AppState->DHCPClient.CurrentState = DHCP_STATE_SendDiscover;
    1660:	f8 01       	movw	r30, r16
    1662:	11 86       	std	Z+9, r1	; 0x09
    1664:	41 c0       	rjmp	.+130    	; 0x16e8 <DHCPClientApp_Callback+0x254>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1666:	f7 01       	movw	r30, r14
    1668:	84 81       	ldd	r24, Z+4	; 0x04
    166a:	95 81       	ldd	r25, Z+5	; 0x05
    166c:	a6 81       	ldd	r26, Z+6	; 0x06
    166e:	b7 81       	ldd	r27, Z+7	; 0x07
    1670:	86 36       	cpi	r24, 0x66	; 102
    1672:	f4 e5       	ldi	r31, 0x54	; 84
    1674:	9f 07       	cpc	r25, r31
    1676:	f4 e2       	ldi	r31, 0x24	; 36
    1678:	af 07       	cpc	r26, r31
    167a:	f3 e1       	ldi	r31, 0x13	; 19
    167c:	bf 07       	cpc	r27, r31
    167e:	a1 f5       	brne	.+104    	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1680:	c7 01       	movw	r24, r14
    1682:	80 51       	subi	r24, 0x10	; 16
    1684:	9f 4f       	sbci	r25, 0xFF	; 255
    1686:	65 e3       	ldi	r22, 0x35	; 53
    1688:	ae 01       	movw	r20, r28
    168a:	4e 5f       	subi	r20, 0xFE	; 254
    168c:	5f 4f       	sbci	r21, 0xFF	; 255
    168e:	73 de       	rcall	.-794    	; 0x1376 <DHCPCommon_GetOption>

				break;
			}

			uint8_t RequestResponse_MessageType;
			if ((AppData->TransactionID == DHCP_TRANSACTION_ID) &&
    1690:	88 23       	and	r24, r24
    1692:	51 f1       	breq	.+84     	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &RequestResponse_MessageType) &&
    1694:	8a 81       	ldd	r24, Y+2	; 0x02
    1696:	85 30       	cpi	r24, 0x05	; 5
    1698:	39 f5       	brne	.+78     	; 0x16e8 <DHCPClientApp_Callback+0x254>
			    (RequestResponse_MessageType == DHCP_ACK))
			{
				/* Set the new network parameters from the DHCP server */
				uip_sethostaddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.AllocatedIP);
    169a:	f8 01       	movw	r30, r16
    169c:	86 85       	ldd	r24, Z+14	; 0x0e
    169e:	97 85       	ldd	r25, Z+15	; 0x0f
    16a0:	a0 89       	ldd	r26, Z+16	; 0x10
    16a2:	b1 89       	ldd	r27, Z+17	; 0x11
    16a4:	80 93 99 07 	sts	0x0799, r24
    16a8:	90 93 9a 07 	sts	0x079A, r25
    16ac:	a0 93 9b 07 	sts	0x079B, r26
    16b0:	b0 93 9c 07 	sts	0x079C, r27
				uip_setnetmask((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.Netmask);
    16b4:	82 89       	ldd	r24, Z+18	; 0x12
    16b6:	93 89       	ldd	r25, Z+19	; 0x13
    16b8:	a4 89       	ldd	r26, Z+20	; 0x14
    16ba:	b5 89       	ldd	r27, Z+21	; 0x15
    16bc:	80 93 95 07 	sts	0x0795, r24
    16c0:	90 93 96 07 	sts	0x0796, r25
    16c4:	a0 93 97 07 	sts	0x0797, r26
    16c8:	b0 93 98 07 	sts	0x0798, r27
				uip_setdraddr((uip_ipaddr_t*)&AppState->DHCPClient.DHCPOffer_Data.GatewayIP);
    16cc:	86 89       	ldd	r24, Z+22	; 0x16
    16ce:	97 89       	ldd	r25, Z+23	; 0x17
    16d0:	a0 8d       	ldd	r26, Z+24	; 0x18
    16d2:	b1 8d       	ldd	r27, Z+25	; 0x19
    16d4:	80 93 91 07 	sts	0x0791, r24
    16d8:	90 93 92 07 	sts	0x0792, r25
    16dc:	a0 93 93 07 	sts	0x0793, r26
    16e0:	b0 93 94 07 	sts	0x0794, r27

				AppState->DHCPClient.CurrentState = DHCP_STATE_AddressLeased;
    16e4:	84 e0       	ldi	r24, 0x04	; 4
    16e6:	81 87       	std	Z+9, r24	; 0x09
			}

			break;
	}
}
    16e8:	0f 90       	pop	r0
    16ea:	0f 90       	pop	r0
    16ec:	0f 90       	pop	r0
    16ee:	0f 90       	pop	r0
    16f0:	0f 90       	pop	r0
    16f2:	cf 91       	pop	r28
    16f4:	df 91       	pop	r29
    16f6:	1f 91       	pop	r17
    16f8:	0f 91       	pop	r16
    16fa:	ff 90       	pop	r15
    16fc:	ef 90       	pop	r14
    16fe:	df 90       	pop	r13
    1700:	cf 90       	pop	r12
    1702:	bf 90       	pop	r11
    1704:	af 90       	pop	r10
    1706:	08 95       	ret

00001708 <DHCPServerApp_FillDHCPHeader>:
static uint16_t DHCPServerApp_FillDHCPHeader(DHCP_Header_t* const DHCPHeader,
                                             const uint8_t DHCPMessageType,
                                             const struct uip_eth_addr* const ClientHardwareAddress,
											 const uip_ipaddr_t* const PreferredClientIP,
                                             const uint32_t TransactionID)
{
    1708:	ef 92       	push	r14
    170a:	ff 92       	push	r15
    170c:	0f 93       	push	r16
    170e:	1f 93       	push	r17
    1710:	cf 93       	push	r28
    1712:	df 93       	push	r29
    1714:	fc 01       	movw	r30, r24
	/* Erase existing packet data so that we start will all 0x00 DHCP header data */
 	memset(DHCPHeader, 0, sizeof(DHCP_Header_t));
    1716:	80 ef       	ldi	r24, 0xF0	; 240
    1718:	ef 01       	movw	r28, r30
    171a:	19 92       	st	Y+, r1
    171c:	8a 95       	dec	r24
    171e:	e9 f7       	brne	.-6      	; 0x171a <DHCPServerApp_FillDHCPHeader+0x12>

	DHCPHeader->Operation             = DHCPMessageType;
    1720:	60 83       	st	Z, r22
	DHCPHeader->HardwareType          = DHCP_HTYPE_ETHERNET;
    1722:	81 e0       	ldi	r24, 0x01	; 1
    1724:	81 83       	std	Z+1, r24	; 0x01
	DHCPHeader->HardwareAddressLength = sizeof(MACAddress);
    1726:	86 e0       	ldi	r24, 0x06	; 6
    1728:	82 83       	std	Z+2, r24	; 0x02
	DHCPHeader->Hops                  = 0;
    172a:	13 82       	std	Z+3, r1	; 0x03
	DHCPHeader->TransactionID         = TransactionID;
    172c:	e4 82       	std	Z+4, r14	; 0x04
    172e:	f5 82       	std	Z+5, r15	; 0x05
    1730:	06 83       	std	Z+6, r16	; 0x06
    1732:	17 83       	std	Z+7, r17	; 0x07
	DHCPHeader->ElapsedSeconds        = 0;
    1734:	11 86       	std	Z+9, r1	; 0x09
    1736:	10 86       	std	Z+8, r1	; 0x08
	DHCPHeader->Flags                 = 0;
    1738:	13 86       	std	Z+11, r1	; 0x0b
    173a:	12 86       	std	Z+10, r1	; 0x0a
	memcpy(&DHCPHeader->NextServerIP, &uip_hostaddr, sizeof(uip_ipaddr_t));
    173c:	80 91 99 07 	lds	r24, 0x0799
    1740:	90 91 9a 07 	lds	r25, 0x079A
    1744:	a0 91 9b 07 	lds	r26, 0x079B
    1748:	b0 91 9c 07 	lds	r27, 0x079C
    174c:	84 8b       	std	Z+20, r24	; 0x14
    174e:	95 8b       	std	Z+21, r25	; 0x15
    1750:	a6 8b       	std	Z+22, r26	; 0x16
    1752:	b7 8b       	std	Z+23, r27	; 0x17
	memcpy(&DHCPHeader->YourIP, PreferredClientIP, sizeof(uip_ipaddr_t));
    1754:	e9 01       	movw	r28, r18
    1756:	88 81       	ld	r24, Y
    1758:	99 81       	ldd	r25, Y+1	; 0x01
    175a:	aa 81       	ldd	r26, Y+2	; 0x02
    175c:	bb 81       	ldd	r27, Y+3	; 0x03
    175e:	80 8b       	std	Z+16, r24	; 0x10
    1760:	91 8b       	std	Z+17, r25	; 0x11
    1762:	a2 8b       	std	Z+18, r26	; 0x12
    1764:	b3 8b       	std	Z+19, r27	; 0x13
	memcpy(&DHCPHeader->ClientHardwareAddress, ClientHardwareAddress, sizeof(struct uip_eth_addr));
    1766:	ef 01       	movw	r28, r30
    1768:	6c 96       	adiw	r28, 0x1c	; 28
    176a:	84 2f       	mov	r24, r20
    176c:	95 2f       	mov	r25, r21
    176e:	dc 01       	movw	r26, r24
    1770:	86 e0       	ldi	r24, 0x06	; 6
    1772:	0d 90       	ld	r0, X+
    1774:	09 92       	st	Y+, r0
    1776:	81 50       	subi	r24, 0x01	; 1
    1778:	e1 f7       	brne	.-8      	; 0x1772 <DHCPServerApp_FillDHCPHeader+0x6a>
	DHCPHeader->Cookie                = DHCP_MAGIC_COOKIE;
    177a:	ef 01       	movw	r28, r30
    177c:	c4 51       	subi	r28, 0x14	; 20
    177e:	df 4f       	sbci	r29, 0xFF	; 255
    1780:	83 e6       	ldi	r24, 0x63	; 99
    1782:	92 e8       	ldi	r25, 0x82	; 130
    1784:	a3 e5       	ldi	r26, 0x53	; 83
    1786:	b3 e6       	ldi	r27, 0x63	; 99
    1788:	88 83       	st	Y, r24
    178a:	99 83       	std	Y+1, r25	; 0x01
    178c:	aa 83       	std	Y+2, r26	; 0x02
    178e:	bb 83       	std	Y+3, r27	; 0x03

	/* Add a DHCP message type and terminator options to the start of the DHCP options field */
	DHCPHeader->Options[0]            = DHCP_OPTION_MSG_TYPE;
    1790:	df 01       	movw	r26, r30
    1792:	a0 51       	subi	r26, 0x10	; 16
    1794:	bf 4f       	sbci	r27, 0xFF	; 255
    1796:	85 e3       	ldi	r24, 0x35	; 53
    1798:	8c 93       	st	X, r24
	DHCPHeader->Options[1]            = 1;
    179a:	df 01       	movw	r26, r30
    179c:	af 50       	subi	r26, 0x0F	; 15
    179e:	bf 4f       	sbci	r27, 0xFF	; 255
    17a0:	81 e0       	ldi	r24, 0x01	; 1
    17a2:	8c 93       	st	X, r24
	DHCPHeader->Options[2]            = DHCPMessageType;
    17a4:	df 01       	movw	r26, r30
    17a6:	ae 50       	subi	r26, 0x0E	; 14
    17a8:	bf 4f       	sbci	r27, 0xFF	; 255
    17aa:	6c 93       	st	X, r22
	DHCPHeader->Options[3]            = DHCP_OPTION_END;
    17ac:	ed 50       	subi	r30, 0x0D	; 13
    17ae:	ff 4f       	sbci	r31, 0xFF	; 255
    17b0:	8f ef       	ldi	r24, 0xFF	; 255
    17b2:	80 83       	st	Z, r24

	/* Calculate the total number of bytes added to the outgoing packet */
	return (sizeof(DHCP_Header_t) + 4);
}
    17b4:	84 ef       	ldi	r24, 0xF4	; 244
    17b6:	90 e0       	ldi	r25, 0x00	; 0
    17b8:	df 91       	pop	r29
    17ba:	cf 91       	pop	r28
    17bc:	1f 91       	pop	r17
    17be:	0f 91       	pop	r16
    17c0:	ff 90       	pop	r15
    17c2:	ef 90       	pop	r14
    17c4:	08 95       	ret

000017c6 <DHCPServerApp_CheckIfIPLeased.clone.0>:
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    17c6:	88 23       	and	r24, r24
    17c8:	d1 f0       	breq	.+52     	; 0x17fe <DHCPServerApp_CheckIfIPLeased.clone.0+0x38>
    17ca:	90 91 9c 07 	lds	r25, 0x079C
    17ce:	89 17       	cp	r24, r25
    17d0:	c1 f0       	breq	.+48     	; 0x1802 <DHCPServerApp_CheckIfIPLeased.clone.0+0x3c>
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    17d2:	98 2f       	mov	r25, r24
    17d4:	97 70       	andi	r25, 0x07	; 7
    17d6:	21 e0       	ldi	r18, 0x01	; 1
    17d8:	30 e0       	ldi	r19, 0x00	; 0
    17da:	02 c0       	rjmp	.+4      	; 0x17e0 <DHCPServerApp_CheckIfIPLeased.clone.0+0x1a>
    17dc:	22 0f       	add	r18, r18
    17de:	33 1f       	adc	r19, r19
    17e0:	9a 95       	dec	r25
    17e2:	e2 f7       	brpl	.-8      	; 0x17dc <DHCPServerApp_CheckIfIPLeased.clone.0+0x16>
 *
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    17e4:	86 95       	lsr	r24
    17e6:	86 95       	lsr	r24
    17e8:	86 95       	lsr	r24
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
    17ea:	e8 2f       	mov	r30, r24
    17ec:	f0 e0       	ldi	r31, 0x00	; 0
    17ee:	ee 51       	subi	r30, 0x1E	; 30
    17f0:	fc 4f       	sbci	r31, 0xFC	; 252
    17f2:	90 81       	ld	r25, Z
    17f4:	92 23       	and	r25, r18
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 *
 *  \return Boolean true if the IP has already been leased to a client, false otherwise.
 */
static bool DHCPServerApp_CheckIfIPLeased(const uip_ipaddr_t* const IPAddress)
    17f6:	81 e0       	ldi	r24, 0x01	; 1
    17f8:	29 f4       	brne	.+10     	; 0x1804 <DHCPServerApp_CheckIfIPLeased.clone.0+0x3e>
    17fa:	80 e0       	ldi	r24, 0x00	; 0
    17fc:	08 95       	ret

	/* Make sure that the requested IP address isn't already leased to the virtual server or another client */
	if (IPAddress->u8[3] && !(IPAddress->u8[3] == uip_hostaddr.u8[3]) && !(LeasedIPs[Byte] & Mask))
	  return false;
	else
	  return true;
    17fe:	81 e0       	ldi	r24, 0x01	; 1
    1800:	08 95       	ret
    1802:	81 e0       	ldi	r24, 0x01	; 1
}
    1804:	08 95       	ret

00001806 <DHCPServerApp_Init>:

/** Initialization function for the DHCP server. */
void DHCPServerApp_Init(void)
{
	/* Listen on port 67 for DHCP server connections from hosts */
	uip_listen(HTONS(DHCP_SERVER_PORT));
    1806:	80 e0       	ldi	r24, 0x00	; 0
    1808:	93 e4       	ldi	r25, 0x43	; 67
    180a:	9e d4       	rcall	.+2364   	; 0x2148 <uip_listen>

	/* Create a new UDP connection to the DHCP server port for the DHCP solicitation */
	struct uip_udp_conn* BroadcastConnection = uip_udp_new(&uip_broadcast_addr, HTONS(DHCP_CLIENT_PORT));
    180c:	80 e2       	ldi	r24, 0x20	; 32
    180e:	93 e0       	ldi	r25, 0x03	; 3
    1810:	60 e0       	ldi	r22, 0x00	; 0
    1812:	74 e4       	ldi	r23, 0x44	; 68
    1814:	b7 d4       	rcall	.+2414   	; 0x2184 <uip_udp_new>

	/* If the connection was successfully created, bind it to the local DHCP client port */
	if (BroadcastConnection != NULL)
    1816:	00 97       	sbiw	r24, 0x00	; 0
    1818:	39 f0       	breq	.+14     	; 0x1828 <DHCPServerApp_Init+0x22>
	  uip_udp_bind(BroadcastConnection, HTONS(DHCP_SERVER_PORT));
    181a:	20 e0       	ldi	r18, 0x00	; 0
    181c:	33 e4       	ldi	r19, 0x43	; 67
    181e:	dc 01       	movw	r26, r24
    1820:	15 96       	adiw	r26, 0x05	; 5
    1822:	3c 93       	st	X, r19
    1824:	2e 93       	st	-X, r18
    1826:	14 97       	sbiw	r26, 0x04	; 4

	/* Set all IP addresses as unleased */
	memset(LeasedIPs, 0x00, sizeof(LeasedIPs));
    1828:	8f e1       	ldi	r24, 0x1F	; 31
    182a:	e2 ee       	ldi	r30, 0xE2	; 226
    182c:	f3 e0       	ldi	r31, 0x03	; 3
    182e:	df 01       	movw	r26, r30
    1830:	1d 92       	st	X+, r1
    1832:	8a 95       	dec	r24
    1834:	e9 f7       	brne	.-6      	; 0x1830 <DHCPServerApp_Init+0x2a>
}
    1836:	08 95       	ret

00001838 <DHCPServerApp_Callback>:

/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
    1838:	af 92       	push	r10
    183a:	bf 92       	push	r11
    183c:	cf 92       	push	r12
    183e:	df 92       	push	r13
    1840:	ef 92       	push	r14
    1842:	ff 92       	push	r15
    1844:	0f 93       	push	r16
    1846:	1f 93       	push	r17
    1848:	df 93       	push	r29
    184a:	cf 93       	push	r28
    184c:	cd b7       	in	r28, 0x3d	; 61
    184e:	de b7       	in	r29, 0x3e	; 62
    1850:	64 97       	sbiw	r28, 0x14	; 20
    1852:	0f b6       	in	r0, 0x3f	; 63
    1854:	f8 94       	cli
    1856:	de bf       	out	0x3e, r29	; 62
    1858:	0f be       	out	0x3f, r0	; 63
    185a:	cd bf       	out	0x3d, r28	; 61
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    185c:	90 91 30 06 	lds	r25, 0x0630
    1860:	80 91 31 06 	lds	r24, 0x0631
	uint16_t             AppDataSize = 0;

	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
    1864:	20 91 2d 06 	lds	r18, 0x062D
    1868:	21 ff       	sbrs	r18, 1
    186a:	2d c1       	rjmp	.+602    	; 0x1ac6 <DHCPServerApp_Callback+0x28e>
/** uIP stack application callback for the DHCP server. This function must be called each time the TCP/IP stack
 *  needs a UDP packet to be processed.
 */
void DHCPServerApp_Callback(void)
{
	DHCP_Header_t* const AppData     = (DHCP_Header_t*)uip_appdata;
    186c:	09 2f       	mov	r16, r25
    186e:	18 2f       	mov	r17, r24
	/* Only process when new data arrives - don't retransmit lost packets */
	if (uip_newdata())
	{
		/* Get the DHCP message type (if present), otherwise early-abort */
		uint8_t DHCPMessageType;
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_MSG_TYPE, &DHCPMessageType)))
    1870:	80 ef       	ldi	r24, 0xF0	; 240
    1872:	a8 2e       	mov	r10, r24
    1874:	b1 2c       	mov	r11, r1
    1876:	a0 0e       	add	r10, r16
    1878:	b1 1e       	adc	r11, r17
    187a:	c5 01       	movw	r24, r10
    187c:	65 e3       	ldi	r22, 0x35	; 53
    187e:	ae 01       	movw	r20, r28
    1880:	4f 5f       	subi	r20, 0xFF	; 255
    1882:	5f 4f       	sbci	r21, 0xFF	; 255
    1884:	78 dd       	rcall	.-1296   	; 0x1376 <DHCPCommon_GetOption>
    1886:	88 23       	and	r24, r24
    1888:	09 f4       	brne	.+2      	; 0x188c <DHCPServerApp_Callback+0x54>
    188a:	1d c1       	rjmp	.+570    	; 0x1ac6 <DHCPServerApp_Callback+0x28e>
		uip_ipaddr_t        Netmask, GatewayIPAddress, PreferredClientIP;
		struct uip_eth_addr RemoteMACAddress;
		uint32_t            TransactionID;

		/* Get configured network mask, gateway IP and extract out DHCP transaction ID and remote IP */
		uip_getnetmask(&Netmask);
    188c:	80 91 95 07 	lds	r24, 0x0795
    1890:	90 91 96 07 	lds	r25, 0x0796
    1894:	a0 91 97 07 	lds	r26, 0x0797
    1898:	b0 91 98 07 	lds	r27, 0x0798
    189c:	8a 83       	std	Y+2, r24	; 0x02
    189e:	9b 83       	std	Y+3, r25	; 0x03
    18a0:	ac 83       	std	Y+4, r26	; 0x04
    18a2:	bd 83       	std	Y+5, r27	; 0x05
		uip_getdraddr(&GatewayIPAddress);
    18a4:	80 91 91 07 	lds	r24, 0x0791
    18a8:	90 91 92 07 	lds	r25, 0x0792
    18ac:	a0 91 93 07 	lds	r26, 0x0793
    18b0:	b0 91 94 07 	lds	r27, 0x0794
    18b4:	8e 83       	std	Y+6, r24	; 0x06
    18b6:	9f 83       	std	Y+7, r25	; 0x07
    18b8:	a8 87       	std	Y+8, r26	; 0x08
    18ba:	b9 87       	std	Y+9, r27	; 0x09
		memcpy(&RemoteMACAddress, &AppData->ClientHardwareAddress, sizeof(struct uip_eth_addr));
    18bc:	de 01       	movw	r26, r28
    18be:	1e 96       	adiw	r26, 0x0e	; 14
    18c0:	f8 01       	movw	r30, r16
    18c2:	7c 96       	adiw	r30, 0x1c	; 28
    18c4:	86 e0       	ldi	r24, 0x06	; 6
    18c6:	01 90       	ld	r0, Z+
    18c8:	0d 92       	st	X+, r0
    18ca:	81 50       	subi	r24, 0x01	; 1
    18cc:	e1 f7       	brne	.-8      	; 0x18c6 <DHCPServerApp_Callback+0x8e>
		TransactionID = AppData->TransactionID;
    18ce:	f8 01       	movw	r30, r16
    18d0:	c4 80       	ldd	r12, Z+4	; 0x04
    18d2:	d5 80       	ldd	r13, Z+5	; 0x05
    18d4:	e6 80       	ldd	r14, Z+6	; 0x06
    18d6:	f7 80       	ldd	r15, Z+7	; 0x07

		/* Try to extract out the client's preferred IP address if it is indicated in the packet */
		if (!(DHCPCommon_GetOption(AppData->Options, DHCP_OPTION_REQ_IPADDR, &PreferredClientIP)))
    18d8:	c5 01       	movw	r24, r10
    18da:	62 e3       	ldi	r22, 0x32	; 50
    18dc:	ae 01       	movw	r20, r28
    18de:	46 5f       	subi	r20, 0xF6	; 246
    18e0:	5f 4f       	sbci	r21, 0xFF	; 255
    18e2:	49 dd       	rcall	.-1390   	; 0x1376 <DHCPCommon_GetOption>
    18e4:	88 23       	and	r24, r24
    18e6:	61 f4       	brne	.+24     	; 0x1900 <DHCPServerApp_Callback+0xc8>
		  memcpy(&PreferredClientIP, &uip_all_zeroes_addr, sizeof(uip_ipaddr_t));
    18e8:	80 91 24 03 	lds	r24, 0x0324
    18ec:	90 91 25 03 	lds	r25, 0x0325
    18f0:	a0 91 26 03 	lds	r26, 0x0326
    18f4:	b0 91 27 03 	lds	r27, 0x0327
    18f8:	8a 87       	std	Y+10, r24	; 0x0a
    18fa:	9b 87       	std	Y+11, r25	; 0x0b
    18fc:	ac 87       	std	Y+12, r26	; 0x0c
    18fe:	bd 87       	std	Y+13, r27	; 0x0d

		switch (DHCPMessageType)
    1900:	89 81       	ldd	r24, Y+1	; 0x01
    1902:	83 30       	cpi	r24, 0x03	; 3
    1904:	09 f4       	brne	.+2      	; 0x1908 <DHCPServerApp_Callback+0xd0>
    1906:	62 c0       	rjmp	.+196    	; 0x19cc <DHCPServerApp_Callback+0x194>
    1908:	87 30       	cpi	r24, 0x07	; 7
    190a:	09 f4       	brne	.+2      	; 0x190e <DHCPServerApp_Callback+0xd6>
    190c:	c3 c0       	rjmp	.+390    	; 0x1a94 <DHCPServerApp_Callback+0x25c>
    190e:	81 30       	cpi	r24, 0x01	; 1
    1910:	09 f0       	breq	.+2      	; 0x1914 <DHCPServerApp_Callback+0xdc>
    1912:	d9 c0       	rjmp	.+434    	; 0x1ac6 <DHCPServerApp_Callback+0x28e>
		{
			case DHCP_DISCOVER:
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
    1914:	8d 85       	ldd	r24, Y+13	; 0x0d
    1916:	57 df       	rcall	.-338    	; 0x17c6 <DHCPServerApp_CheckIfIPLeased.clone.0>
    1918:	88 23       	and	r24, r24
    191a:	b9 f0       	breq	.+46     	; 0x194a <DHCPServerApp_Callback+0x112>
 *
 *  \param[out] NewIPAddress  Location where the generated IP Address should be stored
 */
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);
    191c:	80 91 99 07 	lds	r24, 0x0799
    1920:	90 91 9a 07 	lds	r25, 0x079A
    1924:	a0 91 9b 07 	lds	r26, 0x079B
    1928:	b0 91 9c 07 	lds	r27, 0x079C
    192c:	8a 87       	std	Y+10, r24	; 0x0a
    192e:	9b 87       	std	Y+11, r25	; 0x0b
    1930:	ac 87       	std	Y+12, r26	; 0x0c
    1932:	bd 87       	std	Y+13, r27	; 0x0d

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1934:	91 e0       	ldi	r25, 0x01	; 1
	{
		/* Update new IP address to lease with the current IP address to test */
		NewIPAddress->u8[3] = IP;
    1936:	9d 87       	std	Y+13, r25	; 0x0d

		/* If we've found an unleased IP, abort with the updated IP stored for the called */
		if (!(DHCPServerApp_CheckIfIPLeased(NewIPAddress)))
    1938:	89 2f       	mov	r24, r25
    193a:	9c 8b       	std	Y+20, r25	; 0x14
    193c:	44 df       	rcall	.-376    	; 0x17c6 <DHCPServerApp_CheckIfIPLeased.clone.0>
    193e:	9c 89       	ldd	r25, Y+20	; 0x14
    1940:	88 23       	and	r24, r24
    1942:	19 f0       	breq	.+6      	; 0x194a <DHCPServerApp_Callback+0x112>
static void DHCPServerApp_GetUnleasedIP(uip_ipaddr_t* const NewIPAddress)
{
	uip_ipaddr_copy(NewIPAddress, &uip_hostaddr);

	/** Look through the current subnet, skipping the broadcast and zero IP addresses */
	for (uint8_t IP = 1; IP < 254; IP++)
    1944:	9f 5f       	subi	r25, 0xFF	; 255
    1946:	9e 3f       	cpi	r25, 0xFE	; 254
    1948:	b1 f7       	brne	.-20     	; 0x1936 <DHCPServerApp_Callback+0xfe>
				/* If no preference was made or the preferred IP is already taken, find a new address */
				if (DHCPServerApp_CheckIfIPLeased(&PreferredClientIP))
				  DHCPServerApp_GetUnleasedIP(&PreferredClientIP);

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    194a:	c8 01       	movw	r24, r16
    194c:	62 e0       	ldi	r22, 0x02	; 2
    194e:	ae 01       	movw	r20, r28
    1950:	42 5f       	subi	r20, 0xF2	; 242
    1952:	5f 4f       	sbci	r21, 0xFF	; 255
    1954:	9e 01       	movw	r18, r28
    1956:	26 5f       	subi	r18, 0xF6	; 246
    1958:	3f 4f       	sbci	r19, 0xFF	; 255
    195a:	87 01       	movw	r16, r14
    195c:	76 01       	movw	r14, r12
    195e:	d4 de       	rcall	.-600    	; 0x1708 <DHCPServerApp_FillDHCPHeader>
    1960:	8c 01       	movw	r16, r24

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1962:	c5 01       	movw	r24, r10
    1964:	61 e0       	ldi	r22, 0x01	; 1
    1966:	44 e0       	ldi	r20, 0x04	; 4
    1968:	9e 01       	movw	r18, r28
    196a:	2e 5f       	subi	r18, 0xFE	; 254
    196c:	3f 4f       	sbci	r19, 0xFF	; 255
    196e:	df dc       	rcall	.-1602   	; 0x132e <DHCPCommon_SetOption>
    1970:	f8 2e       	mov	r15, r24
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1972:	c5 01       	movw	r24, r10
    1974:	63 e0       	ldi	r22, 0x03	; 3
    1976:	44 e0       	ldi	r20, 0x04	; 4
    1978:	9e 01       	movw	r18, r28
    197a:	2a 5f       	subi	r18, 0xFA	; 250
    197c:	3f 4f       	sbci	r19, 0xFF	; 255
    197e:	d7 dc       	rcall	.-1618   	; 0x132e <DHCPCommon_SetOption>
    1980:	c8 2e       	mov	r12, r24
    1982:	dd 24       	eor	r13, r13

				/* Create a new DHCP OFFER packet with the offered IP address */
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1984:	cf 0c       	add	r12, r15
    1986:	d1 1c       	adc	r13, r1
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
					                                sizeof(uip_ipaddr_t), &GatewayIPAddress);

				/* Send the DHCP OFFER packet */
				uip_poll_conn(BroadcastConnection);
    1988:	80 91 01 04 	lds	r24, 0x0401
    198c:	90 91 02 04 	lds	r25, 0x0402
    1990:	90 93 33 06 	sts	0x0633, r25
    1994:	80 93 32 06 	sts	0x0632, r24
    1998:	83 e0       	ldi	r24, 0x03	; 3
    199a:	8f d4       	rcall	.+2334   	; 0x22ba <uip_process>
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    199c:	e0 91 2e 06 	lds	r30, 0x062E
    19a0:	f0 91 2f 06 	lds	r31, 0x062F
    19a4:	80 91 20 03 	lds	r24, 0x0320
    19a8:	90 91 21 03 	lds	r25, 0x0321
    19ac:	a0 91 22 03 	lds	r26, 0x0322
    19b0:	b0 91 23 03 	lds	r27, 0x0323
    19b4:	80 83       	st	Z, r24
    19b6:	91 83       	std	Z+1, r25	; 0x01
    19b8:	a2 83       	std	Z+2, r26	; 0x02
    19ba:	b3 83       	std	Z+3, r27	; 0x03
				AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_OFFER, &RemoteMACAddress, &PreferredClientIP, TransactionID);

				/* Add network mask and router information to the list of DHCP OFFER packet options */
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
													sizeof(uip_ipaddr_t), &Netmask);
				AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19bc:	b6 01       	movw	r22, r12
    19be:	60 0f       	add	r22, r16
    19c0:	71 1f       	adc	r23, r17
					                                sizeof(uip_ipaddr_t), &GatewayIPAddress);

				/* Send the DHCP OFFER packet */
				uip_poll_conn(BroadcastConnection);
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
				uip_udp_send(AppDataSize);
    19c2:	80 91 30 06 	lds	r24, 0x0630
    19c6:	90 91 31 06 	lds	r25, 0x0631
    19ca:	61 c0       	rjmp	.+194    	; 0x1a8e <DHCPServerApp_Callback+0x256>

				break;
			case DHCP_REQUEST:
				/* Check to see if the requested IP address has already been leased to a client */
				if (!(DHCPServerApp_CheckIfIPLeased(&PreferredClientIP)))
    19cc:	8d 85       	ldd	r24, Y+13	; 0x0d
    19ce:	fb de       	rcall	.-522    	; 0x17c6 <DHCPServerApp_CheckIfIPLeased.clone.0>
    19d0:	ae 01       	movw	r20, r28
    19d2:	42 5f       	subi	r20, 0xF2	; 242
    19d4:	5f 4f       	sbci	r21, 0xFF	; 255
    19d6:	88 23       	and	r24, r24
    19d8:	99 f5       	brne	.+102    	; 0x1a40 <DHCPServerApp_Callback+0x208>
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);
    19da:	c8 01       	movw	r24, r16
    19dc:	65 e0       	ldi	r22, 0x05	; 5
    19de:	9e 01       	movw	r18, r28
    19e0:	26 5f       	subi	r18, 0xF6	; 246
    19e2:	3f 4f       	sbci	r19, 0xFF	; 255
    19e4:	87 01       	movw	r16, r14
    19e6:	76 01       	movw	r14, r12
    19e8:	8f de       	rcall	.-738    	; 0x1708 <DHCPServerApp_FillDHCPHeader>
    19ea:	8c 01       	movw	r16, r24

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    19ec:	c5 01       	movw	r24, r10
    19ee:	61 e0       	ldi	r22, 0x01	; 1
    19f0:	44 e0       	ldi	r20, 0x04	; 4
    19f2:	9e 01       	movw	r18, r28
    19f4:	2e 5f       	subi	r18, 0xFE	; 254
    19f6:	3f 4f       	sbci	r19, 0xFF	; 255
    19f8:	9a dc       	rcall	.-1740   	; 0x132e <DHCPCommon_SetOption>
    19fa:	f8 2e       	mov	r15, r24
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    19fc:	c5 01       	movw	r24, r10
    19fe:	63 e0       	ldi	r22, 0x03	; 3
    1a00:	44 e0       	ldi	r20, 0x04	; 4
    1a02:	9e 01       	movw	r18, r28
    1a04:	2a 5f       	subi	r18, 0xFA	; 250
    1a06:	3f 4f       	sbci	r19, 0xFF	; 255
    1a08:	92 dc       	rcall	.-1756   	; 0x132e <DHCPCommon_SetOption>
    1a0a:	c8 2e       	mov	r12, r24
    1a0c:	dd 24       	eor	r13, r13
				{
					/* Create a new DHCP ACK packet to accept the IP address lease */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_ACK, &RemoteMACAddress, &PreferredClientIP, TransactionID);

					/* Add network mask and router information to the list of DHCP ACK packet options */
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_SUBNET_MASK,
    1a0e:	cf 0c       	add	r12, r15
    1a10:	d1 1c       	adc	r13, r1
														sizeof(uip_ipaddr_t), &Netmask);
					AppDataSize += DHCPCommon_SetOption(AppData->Options, DHCP_OPTION_ROUTER,
    1a12:	c0 0e       	add	r12, r16
    1a14:	d1 1e       	adc	r13, r17
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
}
    1a16:	8d 85       	ldd	r24, Y+13	; 0x0d
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1a18:	e8 2f       	mov	r30, r24
    1a1a:	e6 95       	lsr	r30
    1a1c:	e6 95       	lsr	r30
    1a1e:	e6 95       	lsr	r30
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    1a20:	f0 e0       	ldi	r31, 0x00	; 0
    1a22:	ee 51       	subi	r30, 0x1E	; 30
    1a24:	fc 4f       	sbci	r31, 0xFC	; 252
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_LeaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1a26:	28 2f       	mov	r18, r24
    1a28:	27 70       	andi	r18, 0x07	; 7
    1a2a:	81 e0       	ldi	r24, 0x01	; 1
    1a2c:	90 e0       	ldi	r25, 0x00	; 0
    1a2e:	02 c0       	rjmp	.+4      	; 0x1a34 <DHCPServerApp_Callback+0x1fc>
    1a30:	88 0f       	add	r24, r24
    1a32:	99 1f       	adc	r25, r25
    1a34:	2a 95       	dec	r18
    1a36:	e2 f7       	brpl	.-8      	; 0x1a30 <DHCPServerApp_Callback+0x1f8>

	/* Mark the IP address as leased in the allocation table */
	LeasedIPs[Byte] |= Mask;
    1a38:	20 81       	ld	r18, Z
    1a3a:	28 2b       	or	r18, r24
    1a3c:	20 83       	st	Z, r18
    1a3e:	08 c0       	rjmp	.+16     	; 0x1a50 <DHCPServerApp_Callback+0x218>
					DHCPServerApp_LeaseIP(&PreferredClientIP);
				}
				else
				{
					/* Create a new DHCP NAK packet to reject the requested allocation */
					AppDataSize += DHCPServerApp_FillDHCPHeader(AppData, DHCP_NAK, &RemoteMACAddress, &uip_all_zeroes_addr, TransactionID);
    1a40:	c8 01       	movw	r24, r16
    1a42:	66 e0       	ldi	r22, 0x06	; 6
    1a44:	24 e2       	ldi	r18, 0x24	; 36
    1a46:	33 e0       	ldi	r19, 0x03	; 3
    1a48:	87 01       	movw	r16, r14
    1a4a:	76 01       	movw	r14, r12
    1a4c:	5d de       	rcall	.-838    	; 0x1708 <DHCPServerApp_FillDHCPHeader>
    1a4e:	6c 01       	movw	r12, r24
				}

				/* Send the DHCP ACK or NAK packet */
				uip_poll_conn(BroadcastConnection);
    1a50:	80 91 01 04 	lds	r24, 0x0401
    1a54:	90 91 02 04 	lds	r25, 0x0402
    1a58:	90 93 33 06 	sts	0x0633, r25
    1a5c:	80 93 32 06 	sts	0x0632, r24
    1a60:	83 e0       	ldi	r24, 0x03	; 3
    1a62:	2b d4       	rcall	.+2134   	; 0x22ba <uip_process>
				memcpy(&uip_udp_conn->ripaddr, &uip_broadcast_addr, sizeof(uip_ipaddr_t));
    1a64:	e0 91 2e 06 	lds	r30, 0x062E
    1a68:	f0 91 2f 06 	lds	r31, 0x062F
    1a6c:	80 91 20 03 	lds	r24, 0x0320
    1a70:	90 91 21 03 	lds	r25, 0x0321
    1a74:	a0 91 22 03 	lds	r26, 0x0322
    1a78:	b0 91 23 03 	lds	r27, 0x0323
    1a7c:	80 83       	st	Z, r24
    1a7e:	91 83       	std	Z+1, r25	; 0x01
    1a80:	a2 83       	std	Z+2, r26	; 0x02
    1a82:	b3 83       	std	Z+3, r27	; 0x03
				uip_udp_send(AppDataSize);
    1a84:	80 91 30 06 	lds	r24, 0x0630
    1a88:	90 91 31 06 	lds	r25, 0x0631
    1a8c:	b6 01       	movw	r22, r12
    1a8e:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

				break;
    1a92:	19 c0       	rjmp	.+50     	; 0x1ac6 <DHCPServerApp_Callback+0x28e>
			case DHCP_RELEASE:
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
    1a94:	e0 91 2e 06 	lds	r30, 0x062E
    1a98:	f0 91 2f 06 	lds	r31, 0x062F
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
}
    1a9c:	83 81       	ldd	r24, Z+3	; 0x03
 *
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
    1a9e:	e8 2f       	mov	r30, r24
    1aa0:	e6 95       	lsr	r30
    1aa2:	e6 95       	lsr	r30
    1aa4:	e6 95       	lsr	r30
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1aa6:	f0 e0       	ldi	r31, 0x00	; 0
    1aa8:	ee 51       	subi	r30, 0x1E	; 30
    1aaa:	fc 4f       	sbci	r31, 0xFC	; 252
 *  \pre The IP address must be within the same /24 subnet as the virtual webserver.
 */
static void DHCPServerApp_UnleaseIP(const uip_ipaddr_t* const IPAddress)
{
	uint8_t Byte = (IPAddress->u8[3] / 8);
	uint8_t Mask = (1 << (IPAddress->u8[3] % 8));
    1aac:	28 2f       	mov	r18, r24
    1aae:	27 70       	andi	r18, 0x07	; 7
    1ab0:	81 e0       	ldi	r24, 0x01	; 1
    1ab2:	90 e0       	ldi	r25, 0x00	; 0
    1ab4:	02 c0       	rjmp	.+4      	; 0x1aba <DHCPServerApp_Callback+0x282>
    1ab6:	88 0f       	add	r24, r24
    1ab8:	99 1f       	adc	r25, r25
    1aba:	2a 95       	dec	r18
    1abc:	e2 f7       	brpl	.-8      	; 0x1ab6 <DHCPServerApp_Callback+0x27e>

	/* Mark the IP address as unleased in the allocation table */
	LeasedIPs[Byte] &= ~Mask;
    1abe:	80 95       	com	r24
    1ac0:	90 81       	ld	r25, Z
    1ac2:	89 23       	and	r24, r25
    1ac4:	80 83       	st	Z, r24
				/* Mark the IP address as released in the allocation table */
				DHCPServerApp_UnleaseIP(&uip_udp_conn->ripaddr);
				break;
		}
	}
}
    1ac6:	64 96       	adiw	r28, 0x14	; 20
    1ac8:	0f b6       	in	r0, 0x3f	; 63
    1aca:	f8 94       	cli
    1acc:	de bf       	out	0x3e, r29	; 62
    1ace:	0f be       	out	0x3f, r0	; 63
    1ad0:	cd bf       	out	0x3d, r28	; 61
    1ad2:	cf 91       	pop	r28
    1ad4:	df 91       	pop	r29
    1ad6:	1f 91       	pop	r17
    1ad8:	0f 91       	pop	r16
    1ada:	ff 90       	pop	r15
    1adc:	ef 90       	pop	r14
    1ade:	df 90       	pop	r13
    1ae0:	cf 90       	pop	r12
    1ae2:	bf 90       	pop	r11
    1ae4:	af 90       	pop	r10
    1ae6:	08 95       	ret

00001ae8 <HTTPServerApp_Init>:

/** Initialization function for the simple HTTP webserver. */
void HTTPServerApp_Init(void)
{
	/* Listen on port 80 for HTTP connections from hosts */
	uip_listen(HTONS(HTTP_SERVER_PORT));
    1ae8:	80 e0       	ldi	r24, 0x00	; 0
    1aea:	90 e5       	ldi	r25, 0x50	; 80
    1aec:	2d d3       	rcall	.+1626   	; 0x2148 <uip_listen>

	/* Mount the Dataflash disk via FatFS */
	f_mount(0, &DiskFATState);
    1aee:	80 e0       	ldi	r24, 0x00	; 0
    1af0:	63 e0       	ldi	r22, 0x03	; 3
    1af2:	74 e0       	ldi	r23, 0x04	; 4
    1af4:	0c 94 1e 1f 	jmp	0x3e3c	; 0x3e3c <f_mount>

00001af8 <HTTPServerApp_Callback>:

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
{
    1af8:	af 92       	push	r10
    1afa:	bf 92       	push	r11
    1afc:	cf 92       	push	r12
    1afe:	df 92       	push	r13
    1b00:	ef 92       	push	r14
    1b02:	ff 92       	push	r15
    1b04:	0f 93       	push	r16
    1b06:	1f 93       	push	r17
    1b08:	cf 93       	push	r28
    1b0a:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState = &uip_conn->appstate;
    1b0c:	c0 91 32 06 	lds	r28, 0x0632
    1b10:	d0 91 33 06 	lds	r29, 0x0633

	if (uip_aborted() || uip_timedout() || uip_closed())
    1b14:	80 91 2d 06 	lds	r24, 0x062D
    1b18:	68 2f       	mov	r22, r24
    1b1a:	85 fd       	sbrc	r24, 5
    1b1c:	04 c0       	rjmp	.+8      	; 0x1b26 <HTTPServerApp_Callback+0x2e>
    1b1e:	87 fd       	sbrc	r24, 7
    1b20:	02 c0       	rjmp	.+4      	; 0x1b26 <HTTPServerApp_Callback+0x2e>
    1b22:	84 ff       	sbrs	r24, 4
    1b24:	03 c0       	rjmp	.+6      	; 0x1b2c <HTTPServerApp_Callback+0x34>
	{
		/* Lock to the closed state so that no further processing will occur on the connection */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_Closing;
    1b26:	83 e0       	ldi	r24, 0x03	; 3
    1b28:	8c 8f       	std	Y+28, r24	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_Closing;
    1b2a:	8d 8f       	std	Y+29, r24	; 0x1d
	}

	if (uip_connected())
    1b2c:	66 ff       	sbrs	r22, 6
    1b2e:	12 c0       	rjmp	.+36     	; 0x1b54 <HTTPServerApp_Callback+0x5c>
	{
		/* New connection - initialize connection state values */
		AppState->HTTPServer.CurrentState  = WEBSERVER_STATE_OpenRequestedFile;
    1b30:	1c 8e       	std	Y+28, r1	; 0x1c
		AppState->HTTPServer.NextState     = WEBSERVER_STATE_OpenRequestedFile;
    1b32:	1d 8e       	std	Y+29, r1	; 0x1d
		AppState->HTTPServer.FileOpen      = false;
    1b34:	fe 01       	movw	r30, r28
    1b36:	e6 59       	subi	r30, 0x96	; 150
    1b38:	ff 4f       	sbci	r31, 0xFF	; 255
    1b3a:	10 82       	st	Z, r1
		AppState->HTTPServer.ACKedFilePos  = 0;
    1b3c:	fe 01       	movw	r30, r28
    1b3e:	e5 59       	subi	r30, 0x95	; 149
    1b40:	ff 4f       	sbci	r31, 0xFF	; 255
    1b42:	10 82       	st	Z, r1
    1b44:	11 82       	std	Z+1, r1	; 0x01
    1b46:	12 82       	std	Z+2, r1	; 0x02
    1b48:	13 82       	std	Z+3, r1	; 0x03
		AppState->HTTPServer.SentChunkSize = 0;
    1b4a:	fe 01       	movw	r30, r28
    1b4c:	e1 59       	subi	r30, 0x91	; 145
    1b4e:	ff 4f       	sbci	r31, 0xFF	; 255
    1b50:	11 82       	std	Z+1, r1	; 0x01
    1b52:	10 82       	st	Z, r1
	}

	if (uip_acked())
    1b54:	60 ff       	sbrs	r22, 0
    1b56:	18 c0       	rjmp	.+48     	; 0x1b88 <HTTPServerApp_Callback+0x90>
	{
		/* Add the amount of ACKed file data to the total sent file bytes counter */
		AppState->HTTPServer.ACKedFilePos += AppState->HTTPServer.SentChunkSize;
    1b58:	fe 01       	movw	r30, r28
    1b5a:	e5 59       	subi	r30, 0x95	; 149
    1b5c:	ff 4f       	sbci	r31, 0xFF	; 255
    1b5e:	de 01       	movw	r26, r28
    1b60:	a1 59       	subi	r26, 0x91	; 145
    1b62:	bf 4f       	sbci	r27, 0xFF	; 255
    1b64:	8d 91       	ld	r24, X+
    1b66:	9c 91       	ld	r25, X
    1b68:	a0 e0       	ldi	r26, 0x00	; 0
    1b6a:	b0 e0       	ldi	r27, 0x00	; 0
    1b6c:	20 81       	ld	r18, Z
    1b6e:	31 81       	ldd	r19, Z+1	; 0x01
    1b70:	42 81       	ldd	r20, Z+2	; 0x02
    1b72:	53 81       	ldd	r21, Z+3	; 0x03
    1b74:	82 0f       	add	r24, r18
    1b76:	93 1f       	adc	r25, r19
    1b78:	a4 1f       	adc	r26, r20
    1b7a:	b5 1f       	adc	r27, r21
    1b7c:	80 83       	st	Z, r24
    1b7e:	91 83       	std	Z+1, r25	; 0x01
    1b80:	a2 83       	std	Z+2, r26	; 0x02
    1b82:	b3 83       	std	Z+3, r27	; 0x03

		/* Progress to the next state once the current state's data has been ACKed */
		AppState->HTTPServer.CurrentState = AppState->HTTPServer.NextState;
    1b84:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1b86:	8c 8f       	std	Y+28, r24	; 0x1c
	}

	if (uip_rexmit())
    1b88:	62 ff       	sbrs	r22, 2
    1b8a:	0c c0       	rjmp	.+24     	; 0x1ba4 <HTTPServerApp_Callback+0xac>
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
    1b8c:	fe 01       	movw	r30, r28
    1b8e:	e5 59       	subi	r30, 0x95	; 149
    1b90:	ff 4f       	sbci	r31, 0xFF	; 255
    1b92:	40 81       	ld	r20, Z
    1b94:	51 81       	ldd	r21, Z+1	; 0x01
    1b96:	62 81       	ldd	r22, Z+2	; 0x02
    1b98:	73 81       	ldd	r23, Z+3	; 0x03
    1b9a:	ce 01       	movw	r24, r28
    1b9c:	80 5b       	subi	r24, 0xB0	; 176
    1b9e:	9f 4f       	sbci	r25, 0xFF	; 255
    1ba0:	0e 94 7c 24 	call	0x48f8	; 0x48f8 <f_lseek>
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1ba4:	20 91 2d 06 	lds	r18, 0x062D
    1ba8:	30 e0       	ldi	r19, 0x00	; 0
    1baa:	22 fd       	sbrc	r18, 2
    1bac:	0b c0       	rjmp	.+22     	; 0x1bc4 <HTTPServerApp_Callback+0xcc>
}

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
    1bae:	c9 01       	movw	r24, r18
    1bb0:	83 70       	andi	r24, 0x03	; 3
    1bb2:	90 70       	andi	r25, 0x00	; 0
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1bb4:	00 97       	sbiw	r24, 0x00	; 0
    1bb6:	31 f4       	brne	.+12     	; 0x1bc4 <HTTPServerApp_Callback+0xcc>
}

/** uIP stack application callback for the simple HTTP webserver. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void HTTPServerApp_Callback(void)
    1bb8:	c9 01       	movw	r24, r18
    1bba:	88 74       	andi	r24, 0x48	; 72
    1bbc:	90 70       	andi	r25, 0x00	; 0
	{
		/* Return file pointer to the last ACKed position */
		f_lseek(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.ACKedFilePos);
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1bbe:	00 97       	sbiw	r24, 0x00	; 0
    1bc0:	09 f4       	brne	.+2      	; 0x1bc4 <HTTPServerApp_Callback+0xcc>
    1bc2:	0b c1       	rjmp	.+534    	; 0x1dda <HTTPServerApp_Callback+0x2e2>
	{
		switch (AppState->HTTPServer.CurrentState)
    1bc4:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1bc6:	81 30       	cpi	r24, 0x01	; 1
    1bc8:	09 f4       	brne	.+2      	; 0x1bcc <HTTPServerApp_Callback+0xd4>
    1bca:	60 c0       	rjmp	.+192    	; 0x1c8c <HTTPServerApp_Callback+0x194>
    1bcc:	81 30       	cpi	r24, 0x01	; 1
    1bce:	38 f0       	brcs	.+14     	; 0x1bde <HTTPServerApp_Callback+0xe6>
    1bd0:	82 30       	cpi	r24, 0x02	; 2
    1bd2:	09 f4       	brne	.+2      	; 0x1bd6 <HTTPServerApp_Callback+0xde>
    1bd4:	d0 c0       	rjmp	.+416    	; 0x1d76 <HTTPServerApp_Callback+0x27e>
    1bd6:	83 30       	cpi	r24, 0x03	; 3
    1bd8:	09 f0       	breq	.+2      	; 0x1bdc <HTTPServerApp_Callback+0xe4>
    1bda:	ff c0       	rjmp	.+510    	; 0x1dda <HTTPServerApp_Callback+0x2e2>
    1bdc:	ef c0       	rjmp	.+478    	; 0x1dbc <HTTPServerApp_Callback+0x2c4>
/** HTTP Server State handler for the Request Process state. This state manages the processing of incoming HTTP
 *  GET requests to the server from the receiving HTTP client.
 */
static void HTTPServerApp_OpenRequestedFile(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1bde:	c0 91 32 06 	lds	r28, 0x0632
    1be2:	d0 91 33 06 	lds	r29, 0x0633
	char*               const AppData     = (char*)uip_appdata;
    1be6:	80 91 30 06 	lds	r24, 0x0630
    1bea:	90 91 31 06 	lds	r25, 0x0631

	/* No HTTP header received from the client, abort processing */
	if (!(uip_newdata()))
    1bee:	21 ff       	sbrs	r18, 1
    1bf0:	f4 c0       	rjmp	.+488    	; 0x1dda <HTTPServerApp_Callback+0x2e2>
	  return;

	char* RequestToken      = strtok(AppData, " ");
    1bf2:	63 e4       	ldi	r22, 0x43	; 67
    1bf4:	72 e0       	ldi	r23, 0x02	; 2
    1bf6:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <strtok>
    1bfa:	8c 01       	movw	r16, r24
	char* RequestedFileName = strtok(NULL, " ");
    1bfc:	80 e0       	ldi	r24, 0x00	; 0
    1bfe:	90 e0       	ldi	r25, 0x00	; 0
    1c00:	63 e4       	ldi	r22, 0x43	; 67
    1c02:	72 e0       	ldi	r23, 0x02	; 2
    1c04:	0e 94 07 3d 	call	0x7a0e	; 0x7a0e <strtok>
    1c08:	7c 01       	movw	r14, r24

	/* Must be a GET request, abort otherwise */
	if (strcmp_P(RequestToken, PSTR("GET")) != 0)
    1c0a:	c8 01       	movw	r24, r16
    1c0c:	61 e4       	ldi	r22, 0x41	; 65
    1c0e:	72 e0       	ldi	r23, 0x02	; 2
    1c10:	0e 94 e3 3c 	call	0x79c6	; 0x79c6 <strcmp_P>
    1c14:	00 97       	sbiw	r24, 0x00	; 0
    1c16:	21 f0       	breq	.+8      	; 0x1c20 <HTTPServerApp_Callback+0x128>
	{
		uip_abort();
    1c18:	80 e2       	ldi	r24, 0x20	; 32
    1c1a:	80 93 2d 06 	sts	0x062D, r24
    1c1e:	dd c0       	rjmp	.+442    	; 0x1dda <HTTPServerApp_Callback+0x2e2>
		return;
	}

	/* Copy over the requested filename */
	strlcpy(AppState->HTTPServer.FileName, &RequestedFileName[1], sizeof(AppState->HTTPServer.FileName));
    1c20:	8e 01       	movw	r16, r28
    1c22:	02 5e       	subi	r16, 0xE2	; 226
    1c24:	1f 4f       	sbci	r17, 0xFF	; 255
    1c26:	b7 01       	movw	r22, r14
    1c28:	6f 5f       	subi	r22, 0xFF	; 255
    1c2a:	7f 4f       	sbci	r23, 0xFF	; 255
    1c2c:	c8 01       	movw	r24, r16
    1c2e:	42 e3       	ldi	r20, 0x32	; 50
    1c30:	50 e0       	ldi	r21, 0x00	; 0
    1c32:	0e 94 39 3d 	call	0x7a72	; 0x7a72 <strlcpy>

	/* Determine the length of the URI so that it can be checked to see if it is a directory */
	uint8_t FileNameLen = strlen(AppState->HTTPServer.FileName);
    1c36:	d8 01       	movw	r26, r16
    1c38:	0d 90       	ld	r0, X+
    1c3a:	00 20       	and	r0, r0
    1c3c:	e9 f7       	brne	.-6      	; 0x1c38 <HTTPServerApp_Callback+0x140>
    1c3e:	11 97       	sbiw	r26, 0x01	; 1
    1c40:	a0 1b       	sub	r26, r16

	/* If the URI is a directory, append the default filename */
	if ((AppState->HTTPServer.FileName[FileNameLen - 1] == '/') || !(FileNameLen))
    1c42:	fe 01       	movw	r30, r28
    1c44:	ea 0f       	add	r30, r26
    1c46:	f1 1d       	adc	r31, r1
    1c48:	85 8d       	ldd	r24, Z+29	; 0x1d
    1c4a:	8f 32       	cpi	r24, 0x2F	; 47
    1c4c:	11 f0       	breq	.+4      	; 0x1c52 <HTTPServerApp_Callback+0x15a>
    1c4e:	aa 23       	and	r26, r26
    1c50:	69 f4       	brne	.+26     	; 0x1c6c <HTTPServerApp_Callback+0x174>
	{
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
    1c52:	b0 e0       	ldi	r27, 0x00	; 0
    1c54:	cd 01       	movw	r24, r26
    1c56:	4e 96       	adiw	r24, 0x1e	; 30
    1c58:	42 e3       	ldi	r20, 0x32	; 50
    1c5a:	50 e0       	ldi	r21, 0x00	; 0
    1c5c:	4a 1b       	sub	r20, r26
    1c5e:	5b 0b       	sbc	r21, r27
    1c60:	8c 0f       	add	r24, r28
    1c62:	9d 1f       	adc	r25, r29
    1c64:	6c e2       	ldi	r22, 0x2C	; 44
    1c66:	72 e0       	ldi	r23, 0x02	; 2
    1c68:	0e 94 f3 3c 	call	0x79e6	; 0x79e6 <strlcpy_P>
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c6c:	ce 01       	movw	r24, r28
    1c6e:	80 5b       	subi	r24, 0xB0	; 176
    1c70:	9f 4f       	sbci	r25, 0xFF	; 255
    1c72:	b8 01       	movw	r22, r16
    1c74:	41 e0       	ldi	r20, 0x01	; 1
    1c76:	0e 94 34 1f 	call	0x3e68	; 0x3e68 <f_open>
    1c7a:	fe 01       	movw	r30, r28
    1c7c:	e6 59       	subi	r30, 0x96	; 150
    1c7e:	ff 4f       	sbci	r31, 0xFF	; 255
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);
    1c80:	91 e0       	ldi	r25, 0x01	; 1
    1c82:	81 11       	cpse	r24, r1
    1c84:	90 e0       	ldi	r25, 0x00	; 0
		strlcpy_P(&AppState->HTTPServer.FileName[FileNameLen], DefaultDirFileName,
		          (sizeof(AppState->HTTPServer.FileName) - FileNameLen));
	}

	/* Try to open the file from the Dataflash disk */
	AppState->HTTPServer.FileOpen     = (f_open(&AppState->HTTPServer.FileHandle, AppState->HTTPServer.FileName,
    1c86:	90 83       	st	Z, r25
	                                            (FA_OPEN_EXISTING | FA_READ)) == FR_OK);

	/* Lock to the SendResponseHeader state until connection terminated */
	AppState->HTTPServer.CurrentState = WEBSERVER_STATE_SendResponseHeader;
    1c88:	81 e0       	ldi	r24, 0x01	; 1
    1c8a:	a5 c0       	rjmp	.+330    	; 0x1dd6 <HTTPServerApp_Callback+0x2de>
/** HTTP Server State handler for the HTTP Response Header Send state. This state manages the transmission of
 *  the HTTP response header to the receiving HTTP client.
 */
static void HTTPServerApp_SendResponseHeader(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1c8c:	00 91 32 06 	lds	r16, 0x0632
    1c90:	10 91 33 06 	lds	r17, 0x0633
	char*               const AppData     = (char*)uip_appdata;
    1c94:	a0 90 30 06 	lds	r10, 0x0630
    1c98:	b0 90 31 06 	lds	r11, 0x0631

	char* Extension     = strpbrk(AppState->HTTPServer.FileName, ".");
    1c9c:	e8 01       	movw	r28, r16
    1c9e:	6e 96       	adiw	r28, 0x1e	; 30
    1ca0:	ce 01       	movw	r24, r28
    1ca2:	6e e2       	ldi	r22, 0x2E	; 46
    1ca4:	70 e0       	ldi	r23, 0x00	; 0
    1ca6:	0e 94 25 3d 	call	0x7a4a	; 0x7a4a <strchr>
    1caa:	6c 01       	movw	r12, r24
	bool  FoundMIMEType = false;

	/* If the file isn't already open, it wasn't found - send back a 404 error response and abort */
	if (!(AppState->HTTPServer.FileOpen))
    1cac:	f8 01       	movw	r30, r16
    1cae:	e6 59       	subi	r30, 0x96	; 150
    1cb0:	ff 4f       	sbci	r31, 0xFF	; 255
    1cb2:	80 81       	ld	r24, Z
    1cb4:	88 23       	and	r24, r24
    1cb6:	c1 f4       	brne	.+48     	; 0x1ce8 <HTTPServerApp_Callback+0x1f0>
	{
		/* Copy over the HTTP 404 response header and send it to the receiving client */
		strcpy_P(AppData, HTTP404Header);
    1cb8:	c5 01       	movw	r24, r10
    1cba:	60 ea       	ldi	r22, 0xA0	; 160
    1cbc:	71 e0       	ldi	r23, 0x01	; 1
    1cbe:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <strcpy_P>
		strcat(AppData, AppState->HTTPServer.FileName);
    1cc2:	c5 01       	movw	r24, r10
    1cc4:	be 01       	movw	r22, r28
    1cc6:	0e 94 1a 3d 	call	0x7a34	; 0x7a34 <strcat>
		uip_send(AppData, strlen(AppData));
    1cca:	f5 01       	movw	r30, r10
    1ccc:	df 01       	movw	r26, r30
    1cce:	0d 90       	ld	r0, X+
    1cd0:	00 20       	and	r0, r0
    1cd2:	e9 f7       	brne	.-6      	; 0x1cce <HTTPServerApp_Callback+0x1d6>
    1cd4:	bd 01       	movw	r22, r26
    1cd6:	61 50       	subi	r22, 0x01	; 1
    1cd8:	70 40       	sbci	r23, 0x00	; 0
    1cda:	6e 1b       	sub	r22, r30
    1cdc:	7f 0b       	sbc	r23, r31
    1cde:	c5 01       	movw	r24, r10
    1ce0:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

		AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1ce4:	83 e0       	ldi	r24, 0x03	; 3
    1ce6:	44 c0       	rjmp	.+136    	; 0x1d70 <HTTPServerApp_Callback+0x278>
		return;
	}

	/* Copy over the HTTP 200 response header and send it to the receiving client */
	strcpy_P(AppData, HTTP200Header);
    1ce8:	c5 01       	movw	r24, r10
    1cea:	65 e4       	ldi	r22, 0x45	; 69
    1cec:	71 e0       	ldi	r23, 0x01	; 1
    1cee:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <strcpy_P>

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
    1cf2:	c1 14       	cp	r12, r1
    1cf4:	d1 04       	cpc	r13, r1
    1cf6:	29 f1       	breq	.+74     	; 0x1d42 <HTTPServerApp_Callback+0x24a>
    1cf8:	98 ef       	ldi	r25, 0xF8	; 248
    1cfa:	e9 2e       	mov	r14, r25
    1cfc:	92 e0       	ldi	r25, 0x02	; 2
    1cfe:	f9 2e       	mov	r15, r25
    1d00:	c0 e0       	ldi	r28, 0x00	; 0
    1d02:	d0 e0       	ldi	r29, 0x00	; 0
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
		{
			if (strcmp(&Extension[1], MIMETypes[i].Extension) == 0)
    1d04:	08 94       	sec
    1d06:	c1 1c       	adc	r12, r1
    1d08:	d1 1c       	adc	r13, r1
    1d0a:	d7 01       	movw	r26, r14
    1d0c:	6d 91       	ld	r22, X+
    1d0e:	7c 91       	ld	r23, X
    1d10:	c6 01       	movw	r24, r12
    1d12:	0e 94 30 3d 	call	0x7a60	; 0x7a60 <strcmp>
    1d16:	00 97       	sbiw	r24, 0x00	; 0
    1d18:	61 f4       	brne	.+24     	; 0x1d32 <HTTPServerApp_Callback+0x23a>
			{
				strcat(AppData, MIMETypes[i].MIMEType);
    1d1a:	cc 0f       	add	r28, r28
    1d1c:	dd 1f       	adc	r29, r29
    1d1e:	cc 0f       	add	r28, r28
    1d20:	dd 1f       	adc	r29, r29
    1d22:	c8 50       	subi	r28, 0x08	; 8
    1d24:	dd 4f       	sbci	r29, 0xFD	; 253
    1d26:	6a 81       	ldd	r22, Y+2	; 0x02
    1d28:	7b 81       	ldd	r23, Y+3	; 0x03
    1d2a:	c5 01       	movw	r24, r10
    1d2c:	0e 94 1a 3d 	call	0x7a34	; 0x7a34 <strcat>
    1d30:	0d c0       	rjmp	.+26     	; 0x1d4c <HTTPServerApp_Callback+0x254>
    1d32:	21 96       	adiw	r28, 0x01	; 1
    1d34:	e4 e0       	ldi	r30, 0x04	; 4
    1d36:	f0 e0       	ldi	r31, 0x00	; 0
    1d38:	ee 0e       	add	r14, r30
    1d3a:	ff 1e       	adc	r15, r31

	/* Check to see if a MIME type for the requested file's extension was found */
	if (Extension != NULL)
	{
		/* Look through the MIME type list, copy over the required MIME type if found */
		for (uint8_t i = 0; i < (sizeof(MIMETypes) / sizeof(MIMETypes[0])); i++)
    1d3c:	ca 30       	cpi	r28, 0x0A	; 10
    1d3e:	d1 05       	cpc	r29, r1
    1d40:	21 f7       	brne	.-56     	; 0x1d0a <HTTPServerApp_Callback+0x212>

	/* Check if a MIME type was found and copied to the output buffer */
	if (!(FoundMIMEType))
	{
		/* MIME type not found - copy over the default MIME type */
		strcat_P(AppData, DefaultMIMEType);
    1d42:	c5 01       	movw	r24, r10
    1d44:	66 e3       	ldi	r22, 0x36	; 54
    1d46:	72 e0       	ldi	r23, 0x02	; 2
    1d48:	0e 94 d8 3c 	call	0x79b0	; 0x79b0 <strcat_P>
	}

	/* Add the end-of-line terminator and end-of-headers terminator after the MIME type */
	strcat_P(AppData, PSTR("\r\n\r\n"));
    1d4c:	c5 01       	movw	r24, r10
    1d4e:	65 e4       	ldi	r22, 0x45	; 69
    1d50:	72 e0       	ldi	r23, 0x02	; 2
    1d52:	0e 94 d8 3c 	call	0x79b0	; 0x79b0 <strcat_P>

	/* Send the MIME header to the receiving client */
	uip_send(AppData, strlen(AppData));
    1d56:	d5 01       	movw	r26, r10
    1d58:	0d 90       	ld	r0, X+
    1d5a:	00 20       	and	r0, r0
    1d5c:	e9 f7       	brne	.-6      	; 0x1d58 <HTTPServerApp_Callback+0x260>
    1d5e:	bd 01       	movw	r22, r26
    1d60:	61 50       	subi	r22, 0x01	; 1
    1d62:	70 40       	sbci	r23, 0x00	; 0
    1d64:	6a 19       	sub	r22, r10
    1d66:	7b 09       	sbc	r23, r11
    1d68:	c5 01       	movw	r24, r10
    1d6a:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

	/* When the MIME header is ACKed, progress to the data send stage */
	AppState->HTTPServer.NextState = WEBSERVER_STATE_SendData;
    1d6e:	82 e0       	ldi	r24, 0x02	; 2
    1d70:	f8 01       	movw	r30, r16
    1d72:	85 8f       	std	Z+29, r24	; 0x1d
    1d74:	32 c0       	rjmp	.+100    	; 0x1dda <HTTPServerApp_Callback+0x2e2>
/** HTTP Server State handler for the Data Send state. This state manages the transmission of file chunks
 *  to the receiving HTTP client.
 */
static void HTTPServerApp_SendData(void)
{
	uip_tcp_appstate_t* const AppState    = &uip_conn->appstate;
    1d76:	c0 91 32 06 	lds	r28, 0x0632
    1d7a:	d0 91 33 06 	lds	r29, 0x0633
	char*               const AppData     = (char*)uip_appdata;
    1d7e:	e0 90 30 06 	lds	r14, 0x0630
    1d82:	f0 90 31 06 	lds	r15, 0x0631

	/* Get the maximum segment size for the current packet */
	uint16_t MaxChunkSize = uip_mss();
    1d86:	ca 88       	ldd	r12, Y+18	; 0x12
    1d88:	db 88       	ldd	r13, Y+19	; 0x13

	/* Read the next chunk of data from the open file */
	f_read(&AppState->HTTPServer.FileHandle, AppData, MaxChunkSize, &AppState->HTTPServer.SentChunkSize);
    1d8a:	8e 01       	movw	r16, r28
    1d8c:	01 59       	subi	r16, 0x91	; 145
    1d8e:	1f 4f       	sbci	r17, 0xFF	; 255
    1d90:	ce 01       	movw	r24, r28
    1d92:	80 5b       	subi	r24, 0xB0	; 176
    1d94:	9f 4f       	sbci	r25, 0xFF	; 255
    1d96:	b7 01       	movw	r22, r14
    1d98:	a6 01       	movw	r20, r12
    1d9a:	98 01       	movw	r18, r16
    1d9c:	0e 94 16 23 	call	0x462c	; 0x462c <f_read>

	/* Send the next file chunk to the receiving client */
	uip_send(AppData, AppState->HTTPServer.SentChunkSize);
    1da0:	d8 01       	movw	r26, r16
    1da2:	6d 91       	ld	r22, X+
    1da4:	7c 91       	ld	r23, X
    1da6:	c7 01       	movw	r24, r14
    1da8:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

	/* Check if we are at the last chunk of the file, if so next ACK should close the connection */
	if (MaxChunkSize != AppState->HTTPServer.SentChunkSize)
    1dac:	f8 01       	movw	r30, r16
    1dae:	80 81       	ld	r24, Z
    1db0:	91 81       	ldd	r25, Z+1	; 0x01
    1db2:	c8 16       	cp	r12, r24
    1db4:	d9 06       	cpc	r13, r25
    1db6:	89 f0       	breq	.+34     	; 0x1dda <HTTPServerApp_Callback+0x2e2>
	  AppState->HTTPServer.NextState = WEBSERVER_STATE_Closing;
    1db8:	83 e0       	ldi	r24, 0x03	; 3
    1dba:	0e c0       	rjmp	.+28     	; 0x1dd8 <HTTPServerApp_Callback+0x2e0>
			case WEBSERVER_STATE_SendData:
				HTTPServerApp_SendData();
				break;
			case WEBSERVER_STATE_Closing:
				/* Connection is being terminated for some reason - close file handle */
				f_close(&AppState->HTTPServer.FileHandle);
    1dbc:	ce 01       	movw	r24, r28
    1dbe:	80 5b       	subi	r24, 0xB0	; 176
    1dc0:	9f 4f       	sbci	r25, 0xFF	; 255
    1dc2:	0e 94 71 24 	call	0x48e2	; 0x48e2 <f_close>
				AppState->HTTPServer.FileOpen = false;
    1dc6:	fe 01       	movw	r30, r28
    1dc8:	e6 59       	subi	r30, 0x96	; 150
    1dca:	ff 4f       	sbci	r31, 0xFF	; 255
    1dcc:	10 82       	st	Z, r1

				/* If connection is not already closed, close it */
				uip_close();
    1dce:	80 e1       	ldi	r24, 0x10	; 16
    1dd0:	80 93 2d 06 	sts	0x062D, r24

				AppState->HTTPServer.CurrentState = WEBSERVER_STATE_Closed;
    1dd4:	84 e0       	ldi	r24, 0x04	; 4
    1dd6:	8c 8f       	std	Y+28, r24	; 0x1c
				AppState->HTTPServer.NextState    = WEBSERVER_STATE_Closed;
    1dd8:	8d 8f       	std	Y+29, r24	; 0x1d
				break;
		}
	}
}
    1dda:	df 91       	pop	r29
    1ddc:	cf 91       	pop	r28
    1dde:	1f 91       	pop	r17
    1de0:	0f 91       	pop	r16
    1de2:	ff 90       	pop	r15
    1de4:	ef 90       	pop	r14
    1de6:	df 90       	pop	r13
    1de8:	cf 90       	pop	r12
    1dea:	bf 90       	pop	r11
    1dec:	af 90       	pop	r10
    1dee:	08 95       	ret

00001df0 <TELNETServerApp_Init>:

/** Initialization function for the simple TELNET webserver. */
void TELNETServerApp_Init(void)
{
	/* Listen on port 23 for TELNET connections from hosts */
	uip_listen(HTONS(TELNET_SERVER_PORT));
    1df0:	80 e0       	ldi	r24, 0x00	; 0
    1df2:	97 e1       	ldi	r25, 0x17	; 23
}
    1df4:	a9 c1       	rjmp	.+850    	; 0x2148 <uip_listen>

00001df6 <TELNETServerApp_Callback>:

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
    1df6:	9f 92       	push	r9
    1df8:	af 92       	push	r10
    1dfa:	bf 92       	push	r11
    1dfc:	cf 92       	push	r12
    1dfe:	df 92       	push	r13
    1e00:	ef 92       	push	r14
    1e02:	ff 92       	push	r15
    1e04:	0f 93       	push	r16
    1e06:	1f 93       	push	r17
    1e08:	cf 93       	push	r28
    1e0a:	df 93       	push	r29
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
    1e0c:	c0 90 32 06 	lds	r12, 0x0632
    1e10:	d0 90 33 06 	lds	r13, 0x0633
	char*               const AppData    = (char*)uip_appdata;
    1e14:	40 91 30 06 	lds	r20, 0x0630
    1e18:	00 91 31 06 	lds	r16, 0x0631

	if (uip_connected())
    1e1c:	80 91 2d 06 	lds	r24, 0x062D
    1e20:	90 e0       	ldi	r25, 0x00	; 0
    1e22:	86 ff       	sbrs	r24, 6
    1e24:	04 c0       	rjmp	.+8      	; 0x1e2e <TELNETServerApp_Callback+0x38>
	{
		/* New connection - initialize connection state values */
		AppState->TELNETServer.CurrentState = TELNET_STATE_SendHeader;
    1e26:	d6 01       	movw	r26, r12
    1e28:	5c 96       	adiw	r26, 0x1c	; 28
    1e2a:	1c 92       	st	X, r1
    1e2c:	5c 97       	sbiw	r26, 0x1c	; 28
	}

	if (uip_acked())
    1e2e:	80 ff       	sbrs	r24, 0
    1e30:	03 c0       	rjmp	.+6      	; 0x1e38 <TELNETServerApp_Callback+0x42>
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
    1e32:	f6 01       	movw	r30, r12
    1e34:	25 8d       	ldd	r18, Z+29	; 0x1d
    1e36:	24 8f       	std	Z+28, r18	; 0x1c
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e38:	82 fd       	sbrc	r24, 2
    1e3a:	0b c0       	rjmp	.+22     	; 0x1e52 <TELNETServerApp_Callback+0x5c>
}

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
    1e3c:	9c 01       	movw	r18, r24
    1e3e:	23 70       	andi	r18, 0x03	; 3
    1e40:	30 70       	andi	r19, 0x00	; 0
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e42:	21 15       	cp	r18, r1
    1e44:	31 05       	cpc	r19, r1
    1e46:	29 f4       	brne	.+10     	; 0x1e52 <TELNETServerApp_Callback+0x5c>
}

/** uIP stack application callback for the TELNET server. This function must be called each time the
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
    1e48:	88 74       	andi	r24, 0x48	; 72
    1e4a:	90 70       	andi	r25, 0x00	; 0
	{
		/* Progress to the next state once the current state's data has been ACKed */
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
    1e4c:	00 97       	sbiw	r24, 0x00	; 0
    1e4e:	09 f4       	brne	.+2      	; 0x1e52 <TELNETServerApp_Callback+0x5c>
    1e50:	c9 c0       	rjmp	.+402    	; 0x1fe4 <TELNETServerApp_Callback+0x1ee>
 *  TCP/IP stack needs a TCP packet to be processed.
 */
void TELNETServerApp_Callback(void)
{
	uip_tcp_appstate_t* const AppState   = &uip_conn->appstate;
	char*               const AppData    = (char*)uip_appdata;
    1e52:	e4 2e       	mov	r14, r20
    1e54:	e7 01       	movw	r28, r14
    1e56:	7e 01       	movw	r14, r28
    1e58:	f0 2e       	mov	r15, r16
    1e5a:	e7 01       	movw	r28, r14
		AppState->TELNETServer.CurrentState = AppState->TELNETServer.NextState;
	}

	if (uip_rexmit() || uip_acked() || uip_newdata() || uip_connected() || uip_poll())
	{
		switch (AppState->TELNETServer.CurrentState)
    1e5c:	d6 01       	movw	r26, r12
    1e5e:	5c 96       	adiw	r26, 0x1c	; 28
    1e60:	8c 91       	ld	r24, X
    1e62:	5c 97       	sbiw	r26, 0x1c	; 28
    1e64:	81 30       	cpi	r24, 0x01	; 1
    1e66:	61 f0       	breq	.+24     	; 0x1e80 <TELNETServerApp_Callback+0x8a>
    1e68:	81 30       	cpi	r24, 0x01	; 1
    1e6a:	30 f0       	brcs	.+12     	; 0x1e78 <TELNETServerApp_Callback+0x82>
    1e6c:	82 30       	cpi	r24, 0x02	; 2
    1e6e:	e9 f0       	breq	.+58     	; 0x1eaa <TELNETServerApp_Callback+0xb4>
    1e70:	83 30       	cpi	r24, 0x03	; 3
    1e72:	09 f0       	breq	.+2      	; 0x1e76 <TELNETServerApp_Callback+0x80>
    1e74:	b7 c0       	rjmp	.+366    	; 0x1fe4 <TELNETServerApp_Callback+0x1ee>
    1e76:	2a c0       	rjmp	.+84     	; 0x1ecc <TELNETServerApp_Callback+0xd6>
		{
			case TELNET_STATE_SendHeader:
				/* Copy over and send the TELNET welcome message upon first connection */
				strcpy_P(AppData, WelcomeHeader);
    1e78:	c7 01       	movw	r24, r14
    1e7a:	6a e4       	ldi	r22, 0x4A	; 74
    1e7c:	72 e0       	ldi	r23, 0x02	; 2
    1e7e:	9f c0       	rjmp	.+318    	; 0x1fbe <TELNETServerApp_Callback+0x1c8>

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
				break;
			case TELNET_STATE_SendMenu:
				/* Copy over and send the TELNET menu to the client */
				strcpy_P(AppData, TELNETMenu);
    1e80:	c7 01       	movw	r24, r14
    1e82:	65 ed       	ldi	r22, 0xD5	; 213
    1e84:	72 e0       	ldi	r23, 0x02	; 2
    1e86:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <strcpy_P>
				uip_send(AppData, strlen(AppData));
    1e8a:	ee 2d       	mov	r30, r14
    1e8c:	f0 2f       	mov	r31, r16
    1e8e:	df 01       	movw	r26, r30
    1e90:	0d 90       	ld	r0, X+
    1e92:	00 20       	and	r0, r0
    1e94:	e9 f7       	brne	.-6      	; 0x1e90 <TELNETServerApp_Callback+0x9a>
    1e96:	bd 01       	movw	r22, r26
    1e98:	61 50       	subi	r22, 0x01	; 1
    1e9a:	70 40       	sbci	r23, 0x00	; 0
    1e9c:	6e 1b       	sub	r22, r30
    1e9e:	7f 0b       	sbc	r23, r31
    1ea0:	ce 01       	movw	r24, r28
    1ea2:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>

				AppState->TELNETServer.NextState = TELNET_STATE_GetCommand;
    1ea6:	82 e0       	ldi	r24, 0x02	; 2
    1ea8:	9b c0       	rjmp	.+310    	; 0x1fe0 <TELNETServerApp_Callback+0x1ea>
				break;
			case TELNET_STATE_GetCommand:
				if (!(uip_datalen()))
    1eaa:	80 91 25 06 	lds	r24, 0x0625
    1eae:	90 91 26 06 	lds	r25, 0x0626
    1eb2:	00 97       	sbiw	r24, 0x00	; 0
    1eb4:	09 f4       	brne	.+2      	; 0x1eb8 <TELNETServerApp_Callback+0xc2>
    1eb6:	96 c0       	rjmp	.+300    	; 0x1fe4 <TELNETServerApp_Callback+0x1ee>
				  break;

				/* Save the issued command for later processing */
				AppState->TELNETServer.IssuedCommand = AppData[0];
    1eb8:	88 81       	ld	r24, Y
    1eba:	d6 01       	movw	r26, r12
    1ebc:	5e 96       	adiw	r26, 0x1e	; 30
    1ebe:	8c 93       	st	X, r24
    1ec0:	5e 97       	sbiw	r26, 0x1e	; 30

				AppState->TELNETServer.CurrentState  = TELNET_STATE_SendResponse;
    1ec2:	83 e0       	ldi	r24, 0x03	; 3
    1ec4:	5c 96       	adiw	r26, 0x1c	; 28
    1ec6:	8c 93       	st	X, r24
    1ec8:	5c 97       	sbiw	r26, 0x1c	; 28
				break;
    1eca:	8c c0       	rjmp	.+280    	; 0x1fe4 <TELNETServerApp_Callback+0x1ee>
			case TELNET_STATE_SendResponse:
				/* Determine which command was issued, perform command processing */
				switch (AppState->TELNETServer.IssuedCommand)
    1ecc:	f6 01       	movw	r30, r12
    1ece:	86 8d       	ldd	r24, Z+30	; 0x1e
    1ed0:	83 36       	cpi	r24, 0x63	; 99
    1ed2:	09 f0       	breq	.+2      	; 0x1ed6 <TELNETServerApp_Callback+0xe0>
    1ed4:	71 c0       	rjmp	.+226    	; 0x1fb8 <TELNETServerApp_Callback+0x1c2>
/** Sends a list of active TCP connections to the TELNET client. */
static void TELNETServerApp_DisplayTCPConnections(void)
{
	char* const AppData    = (char*)uip_appdata;

	strcpy_P(AppData, CurrentConnectionsHeader);
    1ed6:	c7 01       	movw	r24, r14
    1ed8:	6a e3       	ldi	r22, 0x3A	; 58
    1eda:	73 e0       	ldi	r23, 0x03	; 3
    1edc:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <strcpy_P>

	uint16_t ResponseLen     = strlen(AppData);
    1ee0:	ee 2d       	mov	r30, r14
    1ee2:	f0 2f       	mov	r31, r16
    1ee4:	df 01       	movw	r26, r30
    1ee6:	0d 90       	ld	r0, X+
    1ee8:	00 20       	and	r0, r0
    1eea:	e9 f7       	brne	.-6      	; 0x1ee6 <TELNETServerApp_Callback+0xf0>
    1eec:	7d 01       	movw	r14, r26
    1eee:	08 94       	sec
    1ef0:	e1 08       	sbc	r14, r1
    1ef2:	f1 08       	sbc	r15, r1
    1ef4:	ee 1a       	sub	r14, r30
    1ef6:	ff 0a       	sbc	r15, r31
    1ef8:	04 e3       	ldi	r16, 0x34	; 52
    1efa:	16 e0       	ldi	r17, 0x06	; 6
	uint8_t  ActiveConnCount = 0;
    1efc:	99 24       	eor	r9, r9

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1efe:	8e e6       	ldi	r24, 0x6E	; 110
    1f00:	a8 2e       	mov	r10, r24
    1f02:	83 e0       	ldi	r24, 0x03	; 3
    1f04:	b8 2e       	mov	r11, r24
	for (uint8_t i = 0; i < UIP_CONNS; i++)
	{
		struct uip_conn* CurrConnection = &uip_conns[i];

		/* If the connection is not closed, it is active and must be added to the out buffer */
		if (CurrConnection->tcpstateflags != UIP_CLOSED)
    1f06:	f8 01       	movw	r30, r16
    1f08:	81 8d       	ldd	r24, Z+25	; 0x19
    1f0a:	88 23       	and	r24, r24
    1f0c:	09 f4       	brne	.+2      	; 0x1f10 <TELNETServerApp_Callback+0x11a>
    1f0e:	4a c0       	rjmp	.+148    	; 0x1fa4 <TELNETServerApp_Callback+0x1ae>
		{
			/* Add the current connection's details to the out buffer */
			ResponseLen += sprintf_P(&AppData[ResponseLen], PSTR("%u) %d.%d.%d.%d (Local Port %u <=> Remote Port %u)\r\n"),
    1f10:	93 94       	inc	r9
    1f12:	8d b7       	in	r24, 0x3d	; 61
    1f14:	9e b7       	in	r25, 0x3e	; 62
    1f16:	42 97       	sbiw	r24, 0x12	; 18
    1f18:	0f b6       	in	r0, 0x3f	; 63
    1f1a:	f8 94       	cli
    1f1c:	9e bf       	out	0x3e, r25	; 62
    1f1e:	0f be       	out	0x3f, r0	; 63
    1f20:	8d bf       	out	0x3d, r24	; 61
    1f22:	ed b7       	in	r30, 0x3d	; 61
    1f24:	fe b7       	in	r31, 0x3e	; 62
    1f26:	31 96       	adiw	r30, 0x01	; 1
    1f28:	ce 01       	movw	r24, r28
    1f2a:	8e 0d       	add	r24, r14
    1f2c:	9f 1d       	adc	r25, r15
    1f2e:	ad b7       	in	r26, 0x3d	; 61
    1f30:	be b7       	in	r27, 0x3e	; 62
    1f32:	12 96       	adiw	r26, 0x02	; 2
    1f34:	9c 93       	st	X, r25
    1f36:	8e 93       	st	-X, r24
    1f38:	11 97       	sbiw	r26, 0x01	; 1
    1f3a:	b3 82       	std	Z+3, r11	; 0x03
    1f3c:	a2 82       	std	Z+2, r10	; 0x02
    1f3e:	94 82       	std	Z+4, r9	; 0x04
    1f40:	15 82       	std	Z+5, r1	; 0x05
    1f42:	d8 01       	movw	r26, r16
    1f44:	8c 91       	ld	r24, X
    1f46:	86 83       	std	Z+6, r24	; 0x06
    1f48:	17 82       	std	Z+7, r1	; 0x07
    1f4a:	11 96       	adiw	r26, 0x01	; 1
    1f4c:	8c 91       	ld	r24, X
    1f4e:	11 97       	sbiw	r26, 0x01	; 1
    1f50:	80 87       	std	Z+8, r24	; 0x08
    1f52:	11 86       	std	Z+9, r1	; 0x09
    1f54:	12 96       	adiw	r26, 0x02	; 2
    1f56:	8c 91       	ld	r24, X
    1f58:	12 97       	sbiw	r26, 0x02	; 2
    1f5a:	82 87       	std	Z+10, r24	; 0x0a
    1f5c:	13 86       	std	Z+11, r1	; 0x0b
    1f5e:	13 96       	adiw	r26, 0x03	; 3
    1f60:	8c 91       	ld	r24, X
    1f62:	13 97       	sbiw	r26, 0x03	; 3
    1f64:	84 87       	std	Z+12, r24	; 0x0c
    1f66:	15 86       	std	Z+13, r1	; 0x0d
    1f68:	14 96       	adiw	r26, 0x04	; 4
    1f6a:	8d 91       	ld	r24, X+
    1f6c:	9c 91       	ld	r25, X
    1f6e:	15 97       	sbiw	r26, 0x05	; 5
    1f70:	98 27       	eor	r25, r24
    1f72:	89 27       	eor	r24, r25
    1f74:	98 27       	eor	r25, r24
    1f76:	97 87       	std	Z+15, r25	; 0x0f
    1f78:	86 87       	std	Z+14, r24	; 0x0e
    1f7a:	16 96       	adiw	r26, 0x06	; 6
    1f7c:	8d 91       	ld	r24, X+
    1f7e:	9c 91       	ld	r25, X
    1f80:	17 97       	sbiw	r26, 0x07	; 7
    1f82:	98 27       	eor	r25, r24
    1f84:	89 27       	eor	r24, r25
    1f86:	98 27       	eor	r25, r24
    1f88:	91 8b       	std	Z+17, r25	; 0x11
    1f8a:	80 8b       	std	Z+16, r24	; 0x10
    1f8c:	0e 94 74 3d 	call	0x7ae8	; 0x7ae8 <sprintf_P>
    1f90:	e8 0e       	add	r14, r24
    1f92:	f9 1e       	adc	r15, r25
    1f94:	ed b7       	in	r30, 0x3d	; 61
    1f96:	fe b7       	in	r31, 0x3e	; 62
    1f98:	72 96       	adiw	r30, 0x12	; 18
    1f9a:	0f b6       	in	r0, 0x3f	; 63
    1f9c:	f8 94       	cli
    1f9e:	fe bf       	out	0x3e, r31	; 62
    1fa0:	0f be       	out	0x3f, r0	; 63
    1fa2:	ed bf       	out	0x3d, r30	; 61
    1fa4:	0f 58       	subi	r16, 0x8F	; 143
    1fa6:	1f 4f       	sbci	r17, 0xFF	; 255

	uint16_t ResponseLen     = strlen(AppData);
	uint8_t  ActiveConnCount = 0;

	/* Loop through the complete uIP TCP connections list, looking for active connections */
	for (uint8_t i = 0; i < UIP_CONNS; i++)
    1fa8:	f7 e0       	ldi	r31, 0x07	; 7
    1faa:	07 38       	cpi	r16, 0x87	; 135
    1fac:	1f 07       	cpc	r17, r31
    1fae:	09 f0       	breq	.+2      	; 0x1fb2 <TELNETServerApp_Callback+0x1bc>
    1fb0:	aa cf       	rjmp	.-172    	; 0x1f06 <TELNETServerApp_Callback+0x110>
			                         CurrConnection->ripaddr.u8[3],
			                         HTONS(CurrConnection->lport), HTONS(CurrConnection->rport));
		}
	}

	uip_send(AppData, ResponseLen);
    1fb2:	ce 01       	movw	r24, r28
    1fb4:	b7 01       	movw	r22, r14
    1fb6:	11 c0       	rjmp	.+34     	; 0x1fda <TELNETServerApp_Callback+0x1e4>
				{
					case 'c':
						TELNETServerApp_DisplayTCPConnections();
						break;
					default:
						strcpy_P(AppData, PSTR("Invalid Command.\r\n"));
    1fb8:	c7 01       	movw	r24, r14
    1fba:	6b e5       	ldi	r22, 0x5B	; 91
    1fbc:	73 e0       	ldi	r23, 0x03	; 3
    1fbe:	0e 94 ec 3c 	call	0x79d8	; 0x79d8 <strcpy_P>
						uip_send(AppData, strlen(AppData));
    1fc2:	ec 2f       	mov	r30, r28
    1fc4:	f0 2f       	mov	r31, r16
    1fc6:	df 01       	movw	r26, r30
    1fc8:	0d 90       	ld	r0, X+
    1fca:	00 20       	and	r0, r0
    1fcc:	e9 f7       	brne	.-6      	; 0x1fc8 <TELNETServerApp_Callback+0x1d2>
    1fce:	bd 01       	movw	r22, r26
    1fd0:	61 50       	subi	r22, 0x01	; 1
    1fd2:	70 40       	sbci	r23, 0x00	; 0
    1fd4:	6e 1b       	sub	r22, r30
    1fd6:	7f 0b       	sbc	r23, r31
    1fd8:	ce 01       	movw	r24, r28
    1fda:	0e 94 de 18 	call	0x31bc	; 0x31bc <uip_send>
						break;
				}

				AppState->TELNETServer.NextState = TELNET_STATE_SendMenu;
    1fde:	81 e0       	ldi	r24, 0x01	; 1
    1fe0:	f6 01       	movw	r30, r12
    1fe2:	85 8f       	std	Z+29, r24	; 0x1d
				break;
		}
	}
}
    1fe4:	df 91       	pop	r29
    1fe6:	cf 91       	pop	r28
    1fe8:	1f 91       	pop	r17
    1fea:	0f 91       	pop	r16
    1fec:	ff 90       	pop	r15
    1fee:	ef 90       	pop	r14
    1ff0:	df 90       	pop	r13
    1ff2:	cf 90       	pop	r12
    1ff4:	bf 90       	pop	r11
    1ff6:	af 90       	pop	r10
    1ff8:	9f 90       	pop	r9
    1ffa:	08 95       	ret

00001ffc <chksum>:

#if ! UIP_ARCH_CHKSUM
/*---------------------------------------------------------------------------*/
static u16_t
chksum(u16_t sum, const u8_t *data, u16_t len)
{
    1ffc:	9c 01       	movw	r18, r24
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;
    1ffe:	41 50       	subi	r20, 0x01	; 1
    2000:	50 40       	sbci	r21, 0x00	; 0
    2002:	46 0f       	add	r20, r22
    2004:	57 1f       	adc	r21, r23
{
  u16_t t;
  const u8_t *dataptr;
  const u8_t *last_byte;

  dataptr = data;
    2006:	db 01       	movw	r26, r22
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    2008:	10 c0       	rjmp	.+32     	; 0x202a <chksum+0x2e>
    t = (dataptr[0] << 8) + dataptr[1];
    200a:	fc 91       	ld	r31, X
    200c:	e0 e0       	ldi	r30, 0x00	; 0
    200e:	11 96       	adiw	r26, 0x01	; 1
    2010:	8c 91       	ld	r24, X
    2012:	11 97       	sbiw	r26, 0x01	; 1
    2014:	bf 01       	movw	r22, r30
    2016:	68 0f       	add	r22, r24
    2018:	71 1d       	adc	r23, r1
    sum += t;
    201a:	26 0f       	add	r18, r22
    201c:	37 1f       	adc	r19, r23
    if(sum < t) {
    201e:	26 17       	cp	r18, r22
    2020:	37 07       	cpc	r19, r23
    2022:	10 f4       	brcc	.+4      	; 0x2028 <chksum+0x2c>
      sum++;		/* carry */
    2024:	2f 5f       	subi	r18, 0xFF	; 255
    2026:	3f 4f       	sbci	r19, 0xFF	; 255
    }
    dataptr += 2;
    2028:	12 96       	adiw	r26, 0x02	; 2
  const u8_t *last_byte;

  dataptr = data;
  last_byte = data + len - 1;

  while(dataptr < last_byte) {	/* At least two more bytes */
    202a:	a4 17       	cp	r26, r20
    202c:	b5 07       	cpc	r27, r21
    202e:	68 f3       	brcs	.-38     	; 0x200a <chksum+0xe>
      sum++;		/* carry */
    }
    dataptr += 2;
  }

  if(dataptr == last_byte) {
    2030:	a4 17       	cp	r26, r20
    2032:	b5 07       	cpc	r27, r21
    2034:	49 f4       	brne	.+18     	; 0x2048 <chksum+0x4c>
    t = (dataptr[0] << 8) + 0;
    2036:	9c 91       	ld	r25, X
    2038:	80 e0       	ldi	r24, 0x00	; 0
    sum += t;
    203a:	28 0f       	add	r18, r24
    203c:	39 1f       	adc	r19, r25
    if(sum < t) {
    203e:	28 17       	cp	r18, r24
    2040:	39 07       	cpc	r19, r25
    2042:	10 f4       	brcc	.+4      	; 0x2048 <chksum+0x4c>
      sum++;		/* carry */
    2044:	2f 5f       	subi	r18, 0xFF	; 255
    2046:	3f 4f       	sbci	r19, 0xFF	; 255
    }
  }

  /* Return sum in host byte order. */
  return sum;
}
    2048:	c9 01       	movw	r24, r18
    204a:	08 95       	ret

0000204c <uip_add32>:
#endif /* UIP_LOGGING == 1 */

#if ! UIP_ARCH_ADD32
void
uip_add32(u8_t *op32, u16_t op16)
{
    204c:	fc 01       	movw	r30, r24
  uip_acc32[3] = op32[3] + (op16 & 0xff);
    204e:	43 81       	ldd	r20, Z+3	; 0x03
    2050:	46 0f       	add	r20, r22
    2052:	40 93 2c 06 	sts	0x062C, r20
  uip_acc32[2] = op32[2] + (op16 >> 8);
    2056:	87 2f       	mov	r24, r23
    2058:	99 27       	eor	r25, r25
    205a:	22 81       	ldd	r18, Z+2	; 0x02
    205c:	28 0f       	add	r18, r24
    205e:	20 93 2b 06 	sts	0x062B, r18
  uip_acc32[1] = op32[1];
    2062:	a1 81       	ldd	r26, Z+1	; 0x01
    2064:	a0 93 2a 06 	sts	0x062A, r26
  uip_acc32[0] = op32[0];
    2068:	50 81       	ld	r21, Z
    206a:	50 93 29 06 	sts	0x0629, r21

  if(uip_acc32[2] < (op16 >> 8)) {
    206e:	30 e0       	ldi	r19, 0x00	; 0
    2070:	28 17       	cp	r18, r24
    2072:	39 07       	cpc	r19, r25
    2074:	48 f4       	brcc	.+18     	; 0x2088 <uip_add32+0x3c>
    ++uip_acc32[1];
    2076:	8a 2f       	mov	r24, r26
    2078:	8f 5f       	subi	r24, 0xFF	; 255
    207a:	80 93 2a 06 	sts	0x062A, r24
    if(uip_acc32[1] == 0) {
    207e:	88 23       	and	r24, r24
    2080:	19 f4       	brne	.+6      	; 0x2088 <uip_add32+0x3c>
      ++uip_acc32[0];
    2082:	5f 5f       	subi	r21, 0xFF	; 255
    2084:	50 93 29 06 	sts	0x0629, r21
    }
  }


  if(uip_acc32[3] < (op16 & 0xff)) {
    2088:	84 2f       	mov	r24, r20
    208a:	90 e0       	ldi	r25, 0x00	; 0
    208c:	70 70       	andi	r23, 0x00	; 0
    208e:	86 17       	cp	r24, r22
    2090:	97 07       	cpc	r25, r23
    2092:	98 f4       	brcc	.+38     	; 0x20ba <uip_add32+0x6e>
    ++uip_acc32[2];
    2094:	80 91 2b 06 	lds	r24, 0x062B
    2098:	8f 5f       	subi	r24, 0xFF	; 255
    209a:	80 93 2b 06 	sts	0x062B, r24
    if(uip_acc32[2] == 0) {
    209e:	88 23       	and	r24, r24
    20a0:	61 f4       	brne	.+24     	; 0x20ba <uip_add32+0x6e>
      ++uip_acc32[1];
    20a2:	80 91 2a 06 	lds	r24, 0x062A
    20a6:	8f 5f       	subi	r24, 0xFF	; 255
    20a8:	80 93 2a 06 	sts	0x062A, r24
      if(uip_acc32[1] == 0) {
    20ac:	88 23       	and	r24, r24
    20ae:	29 f4       	brne	.+10     	; 0x20ba <uip_add32+0x6e>
	++uip_acc32[0];
    20b0:	80 91 29 06 	lds	r24, 0x0629
    20b4:	8f 5f       	subi	r24, 0xFF	; 255
    20b6:	80 93 29 06 	sts	0x0629, r24
    20ba:	08 95       	ret

000020bc <uip_add_rcv_nxt>:
}
#endif /* UIP_REASSEMBLY */
/*---------------------------------------------------------------------------*/
static void
uip_add_rcv_nxt(u16_t n)
{
    20bc:	bc 01       	movw	r22, r24
  uip_add32(uip_conn->rcv_nxt, n);
    20be:	80 91 32 06 	lds	r24, 0x0632
    20c2:	90 91 33 06 	lds	r25, 0x0633
    20c6:	08 96       	adiw	r24, 0x08	; 8
    20c8:	c1 df       	rcall	.-126    	; 0x204c <uip_add32>
  uip_conn->rcv_nxt[0] = uip_acc32[0];
    20ca:	e0 91 32 06 	lds	r30, 0x0632
    20ce:	f0 91 33 06 	lds	r31, 0x0633
    20d2:	80 91 29 06 	lds	r24, 0x0629
    20d6:	80 87       	std	Z+8, r24	; 0x08
  uip_conn->rcv_nxt[1] = uip_acc32[1];
    20d8:	80 91 2a 06 	lds	r24, 0x062A
    20dc:	81 87       	std	Z+9, r24	; 0x09
  uip_conn->rcv_nxt[2] = uip_acc32[2];
    20de:	80 91 2b 06 	lds	r24, 0x062B
    20e2:	82 87       	std	Z+10, r24	; 0x0a
  uip_conn->rcv_nxt[3] = uip_acc32[3];
    20e4:	80 91 2c 06 	lds	r24, 0x062C
    20e8:	83 87       	std	Z+11, r24	; 0x0b
}
    20ea:	08 95       	ret

000020ec <uip_init>:
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    20ec:	80 e0       	ldi	r24, 0x00	; 0
    20ee:	09 c0       	rjmp	.+18     	; 0x2102 <__stack+0x3>
    uip_listenports[c] = 0;
    20f0:	e8 2f       	mov	r30, r24
    20f2:	f0 e0       	ldi	r31, 0x00	; 0
    20f4:	ee 0f       	add	r30, r30
    20f6:	ff 1f       	adc	r31, r31
    20f8:	e9 57       	subi	r30, 0x79	; 121
    20fa:	f8 4f       	sbci	r31, 0xF8	; 248
    20fc:	11 82       	std	Z+1, r1	; 0x01
    20fe:	10 82       	st	Z, r1
    2100:	8f 5f       	subi	r24, 0xFF	; 255
#endif /* UIP_ARCH_CHKSUM */
/*---------------------------------------------------------------------------*/
void
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2102:	85 30       	cpi	r24, 0x05	; 5
    2104:	a8 f3       	brcs	.-22     	; 0x20f0 <uip_init+0x4>
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    2106:	40 e0       	ldi	r20, 0x00	; 0
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    2108:	81 e7       	ldi	r24, 0x71	; 113
    210a:	90 e0       	ldi	r25, 0x00	; 0
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    210c:	0d c0       	rjmp	.+26     	; 0x2128 <__stack+0x29>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
    210e:	24 2f       	mov	r18, r20
    2110:	30 e0       	ldi	r19, 0x00	; 0
    2112:	28 9f       	mul	r18, r24
    2114:	f0 01       	movw	r30, r0
    2116:	29 9f       	mul	r18, r25
    2118:	f0 0d       	add	r31, r0
    211a:	38 9f       	mul	r19, r24
    211c:	f0 0d       	add	r31, r0
    211e:	11 24       	eor	r1, r1
    2120:	ec 5c       	subi	r30, 0xCC	; 204
    2122:	f9 4f       	sbci	r31, 0xF9	; 249
    2124:	11 8e       	std	Z+25, r1	; 0x19
    2126:	4f 5f       	subi	r20, 0xFF	; 255
uip_init(void)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    uip_listenports[c] = 0;
  }
  for(c = 0; c < UIP_CONNS; ++c) {
    2128:	43 30       	cpi	r20, 0x03	; 3
    212a:	88 f3       	brcs	.-30     	; 0x210e <__stack+0xf>
    uip_conns[c].tcpstateflags = UIP_CLOSED;
  }
#if UIP_ACTIVE_OPEN
  lastport = 1024;
    212c:	80 e0       	ldi	r24, 0x00	; 0
    212e:	94 e0       	ldi	r25, 0x04	; 4
    2130:	90 93 6f 03 	sts	0x036F, r25
    2134:	80 93 6e 03 	sts	0x036E, r24
#endif /* UIP_ACTIVE_OPEN */

#if UIP_UDP
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    2138:	81 e0       	ldi	r24, 0x01	; 1
    213a:	80 93 6a 03 	sts	0x036A, r24
    213e:	10 92 90 0d 	sts	0x0D90, r1
    2142:	10 92 8f 0d 	sts	0x0D8F, r1
  /* IPv4 initialization. */
#if UIP_FIXEDADDR == 0
  /*  uip_hostaddr[0] = uip_hostaddr[1] = 0;*/
#endif /* UIP_FIXEDADDR */

}
    2146:	08 95       	ret

00002148 <uip_listen>:
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2148:	40 e0       	ldi	r20, 0x00	; 0
    214a:	13 c0       	rjmp	.+38     	; 0x2172 <uip_listen+0x2a>
    if(uip_listenports[c] == 0) {
    214c:	e4 2f       	mov	r30, r20
    214e:	f0 e0       	ldi	r31, 0x00	; 0
    2150:	54 2f       	mov	r21, r20
    2152:	5f 5f       	subi	r21, 0xFF	; 255
    2154:	ee 0f       	add	r30, r30
    2156:	ff 1f       	adc	r31, r31
    2158:	e9 57       	subi	r30, 0x79	; 121
    215a:	f8 4f       	sbci	r31, 0xF8	; 248
    215c:	20 81       	ld	r18, Z
    215e:	31 81       	ldd	r19, Z+1	; 0x01
    2160:	21 15       	cp	r18, r1
    2162:	31 05       	cpc	r19, r1
    2164:	29 f4       	brne	.+10     	; 0x2170 <uip_listen+0x28>
    2166:	40 93 6a 03 	sts	0x036A, r20
      uip_listenports[c] = port;
    216a:	91 83       	std	Z+1, r25	; 0x01
    216c:	80 83       	st	Z, r24
      return;
    216e:	08 95       	ret
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    if(uip_listenports[c] == 0) {
    2170:	45 2f       	mov	r20, r21
}
/*---------------------------------------------------------------------------*/
void
uip_listen(u16_t port)
{
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    2172:	45 30       	cpi	r20, 0x05	; 5
    2174:	58 f3       	brcs	.-42     	; 0x214c <uip_listen+0x4>
    2176:	40 93 6a 03 	sts	0x036A, r20
    217a:	08 95       	ret

0000217c <htons>:
}
/*---------------------------------------------------------------------------*/
u16_t
htons(u16_t val)
{
  return HTONS(val);
    217c:	38 2f       	mov	r19, r24
    217e:	29 2f       	mov	r18, r25
}
    2180:	c9 01       	movw	r24, r18
    2182:	08 95       	ret

00002184 <uip_udp_new>:
#endif /* UIP_ACTIVE_OPEN */
/*---------------------------------------------------------------------------*/
#if UIP_UDP
struct uip_udp_conn *
uip_udp_new(const uip_ipaddr_t *ripaddr, u16_t rport)
{
    2184:	cf 92       	push	r12
    2186:	df 92       	push	r13
    2188:	ef 92       	push	r14
    218a:	ff 92       	push	r15
    218c:	0f 93       	push	r16
    218e:	1f 93       	push	r17
    2190:	cf 93       	push	r28
    2192:	df 93       	push	r29
    2194:	ec 01       	movw	r28, r24
    2196:	6b 01       	movw	r12, r22
  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    2198:	e0 90 8f 0d 	lds	r14, 0x0D8F
    219c:	f0 90 90 0d 	lds	r15, 0x0D90
    21a0:	00 91 6e 03 	lds	r16, 0x036E
    21a4:	10 91 6f 03 	lds	r17, 0x036F
{
  register struct uip_udp_conn *conn;

  /* Find an unused local port. */
 again:
  ++lastport;
    21a8:	0f 5f       	subi	r16, 0xFF	; 255
    21aa:	1f 4f       	sbci	r17, 0xFF	; 255

  if(lastport >= 32000) {
    21ac:	8d e7       	ldi	r24, 0x7D	; 125
    21ae:	00 30       	cpi	r16, 0x00	; 0
    21b0:	18 07       	cpc	r17, r24
    21b2:	10 f0       	brcs	.+4      	; 0x21b8 <uip_udp_new+0x34>
    lastport = 4096;
    21b4:	00 e0       	ldi	r16, 0x00	; 0
    21b6:	10 e1       	ldi	r17, 0x10	; 16
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == htons(lastport)) {
    21b8:	c8 01       	movw	r24, r16
    21ba:	e0 df       	rcall	.-64     	; 0x217c <htons>
    21bc:	e8 16       	cp	r14, r24
    21be:	f9 06       	cpc	r15, r25
    21c0:	99 f3       	breq	.-26     	; 0x21a8 <uip_udp_new+0x24>

  if(lastport >= 32000) {
    lastport = 4096;
  }

  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    21c2:	10 93 6f 03 	sts	0x036F, r17
    21c6:	00 93 6e 03 	sts	0x036E, r16
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
    21ca:	80 91 8f 0d 	lds	r24, 0x0D8F
    21ce:	90 91 90 0d 	lds	r25, 0x0D90
    21d2:	00 97       	sbiw	r24, 0x00	; 0
    21d4:	79 f4       	brne	.+30     	; 0x21f4 <uip_udp_new+0x70>
    21d6:	10 92 6a 03 	sts	0x036A, r1

  if(conn == 0) {
    return 0;
  }

  conn->lport = HTONS(lastport);
    21da:	90 2f       	mov	r25, r16
    21dc:	81 2f       	mov	r24, r17
    21de:	90 93 90 0d 	sts	0x0D90, r25
    21e2:	80 93 8f 0d 	sts	0x0D8F, r24
  conn->rport = rport;
    21e6:	d0 92 92 0d 	sts	0x0D92, r13
    21ea:	c0 92 91 0d 	sts	0x0D91, r12
  if(ripaddr == NULL) {
    21ee:	20 97       	sbiw	r28, 0x00	; 0
    21f0:	81 f4       	brne	.+32     	; 0x2212 <uip_udp_new+0x8e>
    21f2:	06 c0       	rjmp	.+12     	; 0x2200 <uip_udp_new+0x7c>
    }
  }


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    21f4:	81 e0       	ldi	r24, 0x01	; 1
    21f6:	80 93 6a 03 	sts	0x036A, r24
      break;
    }
  }

  if(conn == 0) {
    return 0;
    21fa:	20 e0       	ldi	r18, 0x00	; 0
    21fc:	30 e0       	ldi	r19, 0x00	; 0
    21fe:	1a c0       	rjmp	.+52     	; 0x2234 <uip_udp_new+0xb0>
  }

  conn->lport = HTONS(lastport);
  conn->rport = rport;
  if(ripaddr == NULL) {
    memset(&conn->ripaddr, 0, sizeof(uip_ipaddr_t));
    2200:	10 92 8b 0d 	sts	0x0D8B, r1
    2204:	10 92 8c 0d 	sts	0x0D8C, r1
    2208:	10 92 8d 0d 	sts	0x0D8D, r1
    220c:	10 92 8e 0d 	sts	0x0D8E, r1
    2210:	0c c0       	rjmp	.+24     	; 0x222a <uip_udp_new+0xa6>
  } else {
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
    2212:	88 81       	ld	r24, Y
    2214:	99 81       	ldd	r25, Y+1	; 0x01
    2216:	aa 81       	ldd	r26, Y+2	; 0x02
    2218:	bb 81       	ldd	r27, Y+3	; 0x03
    221a:	80 93 8b 0d 	sts	0x0D8B, r24
    221e:	90 93 8c 0d 	sts	0x0D8C, r25
    2222:	a0 93 8d 0d 	sts	0x0D8D, r26
    2226:	b0 93 8e 0d 	sts	0x0D8E, r27
  }
  conn->ttl = UIP_TTL;
    222a:	80 e4       	ldi	r24, 0x40	; 64
    222c:	80 93 93 0d 	sts	0x0D93, r24


  conn = 0;
  for(c = 0; c < UIP_UDP_CONNS; ++c) {
    if(uip_udp_conns[c].lport == 0) {
      conn = &uip_udp_conns[c];
    2230:	2b e8       	ldi	r18, 0x8B	; 139
    2232:	3d e0       	ldi	r19, 0x0D	; 13
    uip_ipaddr_copy(&conn->ripaddr, ripaddr);
  }
  conn->ttl = UIP_TTL;

  return conn;
}
    2234:	c9 01       	movw	r24, r18
    2236:	df 91       	pop	r29
    2238:	cf 91       	pop	r28
    223a:	1f 91       	pop	r17
    223c:	0f 91       	pop	r16
    223e:	ff 90       	pop	r15
    2240:	ef 90       	pop	r14
    2242:	df 90       	pop	r13
    2244:	cf 90       	pop	r12
    2246:	08 95       	ret

00002248 <uip_ipchksum>:
u16_t
uip_ipchksum(void)
{
  u16_t sum;

  sum = chksum(0, &uip_buf[UIP_LLH_LEN], UIP_IPH_LEN);
    2248:	80 e0       	ldi	r24, 0x00	; 0
    224a:	90 e0       	ldi	r25, 0x00	; 0
    224c:	6b ea       	ldi	r22, 0xAB	; 171
    224e:	77 e0       	ldi	r23, 0x07	; 7
    2250:	44 e1       	ldi	r20, 0x14	; 20
    2252:	50 e0       	ldi	r21, 0x00	; 0
    2254:	d3 de       	rcall	.-602    	; 0x1ffc <chksum>
  DEBUG_PRINTF("uip_ipchksum: sum 0x%04x\n", sum);
  return (sum == 0) ? 0xffff : htons(sum);
    2256:	00 97       	sbiw	r24, 0x00	; 0
    2258:	19 f0       	breq	.+6      	; 0x2260 <uip_ipchksum+0x18>
    225a:	90 df       	rcall	.-224    	; 0x217c <htons>
    225c:	9c 01       	movw	r18, r24
    225e:	02 c0       	rjmp	.+4      	; 0x2264 <uip_ipchksum+0x1c>
    2260:	2f ef       	ldi	r18, 0xFF	; 255
    2262:	3f ef       	ldi	r19, 0xFF	; 255
}
    2264:	c9 01       	movw	r24, r18
    2266:	08 95       	ret

00002268 <uip_chksum>:
  return sum;
}
/*---------------------------------------------------------------------------*/
u16_t
uip_chksum(u16_t *data, u16_t len)
{
    2268:	9c 01       	movw	r18, r24
    226a:	ab 01       	movw	r20, r22
  return htons(chksum(0, (u8_t *)data, len));
    226c:	80 e0       	ldi	r24, 0x00	; 0
    226e:	90 e0       	ldi	r25, 0x00	; 0
    2270:	b9 01       	movw	r22, r18
    2272:	c4 de       	rcall	.-632    	; 0x1ffc <chksum>
}
    2274:	83 cf       	rjmp	.-250    	; 0x217c <htons>

00002276 <uip_tcpchksum>:
}
#endif /* UIP_CONF_IPV6 */
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
    2276:	cf 93       	push	r28
    2278:	df 93       	push	r29
  u16_t sum;

#if UIP_CONF_IPV6
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]);
#else /* UIP_CONF_IPV6 */
  upper_layer_len = (((u16_t)(BUF->len[0]) << 8) + BUF->len[1]) - UIP_IPH_LEN;
    227a:	80 91 ae 07 	lds	r24, 0x07AE
    227e:	c8 2f       	mov	r28, r24
    2280:	d0 e0       	ldi	r29, 0x00	; 0
    2282:	64 97       	sbiw	r28, 0x14	; 20
    2284:	90 91 ad 07 	lds	r25, 0x07AD
    2288:	80 e0       	ldi	r24, 0x00	; 0
    228a:	c8 0f       	add	r28, r24
    228c:	d9 1f       	adc	r29, r25
  /* First sum pseudo-header. */

  /* IP protocol and length fields. This addition cannot carry. */
  sum = upper_layer_len + proto;
  /* Sum IP source and destination addresses. */
  sum = chksum(sum, (u8_t *)&BUF->srcipaddr, 2 * sizeof(uip_ipaddr_t));
    228e:	ce 01       	movw	r24, r28
    2290:	06 96       	adiw	r24, 0x06	; 6
    2292:	67 eb       	ldi	r22, 0xB7	; 183
    2294:	77 e0       	ldi	r23, 0x07	; 7
    2296:	48 e0       	ldi	r20, 0x08	; 8
    2298:	50 e0       	ldi	r21, 0x00	; 0
    229a:	b0 de       	rcall	.-672    	; 0x1ffc <chksum>

  /* Sum TCP header and data. */
  sum = chksum(sum, &uip_buf[UIP_IPH_LEN + UIP_LLH_LEN],
    229c:	6f eb       	ldi	r22, 0xBF	; 191
    229e:	77 e0       	ldi	r23, 0x07	; 7
    22a0:	ae 01       	movw	r20, r28
    22a2:	ac de       	rcall	.-680    	; 0x1ffc <chksum>
	       upper_layer_len);

  return (sum == 0) ? 0xffff : htons(sum);
    22a4:	00 97       	sbiw	r24, 0x00	; 0
    22a6:	19 f0       	breq	.+6      	; 0x22ae <uip_tcpchksum+0x38>
    22a8:	69 df       	rcall	.-302    	; 0x217c <htons>
    22aa:	9c 01       	movw	r18, r24
    22ac:	02 c0       	rjmp	.+4      	; 0x22b2 <uip_tcpchksum+0x3c>
    22ae:	2f ef       	ldi	r18, 0xFF	; 255
    22b0:	3f ef       	ldi	r19, 0xFF	; 255
/*---------------------------------------------------------------------------*/
u16_t
uip_tcpchksum(void)
{
  return upper_layer_chksum(UIP_PROTO_TCP);
}
    22b2:	c9 01       	movw	r24, r18
    22b4:	df 91       	pop	r29
    22b6:	cf 91       	pop	r28
    22b8:	08 95       	ret

000022ba <uip_process>:
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
{
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	cf 93       	push	r28
    22c4:	df 93       	push	r29
  register struct uip_conn *uip_connr = uip_conn;
    22c6:	c0 91 32 06 	lds	r28, 0x0632
    22ca:	d0 91 33 06 	lds	r29, 0x0633

#if UIP_UDP
  if(flag == UIP_UDP_SEND_CONN) {
    22ce:	84 30       	cpi	r24, 0x04	; 4
    22d0:	09 f4       	brne	.+2      	; 0x22d4 <uip_process+0x1a>
    22d2:	6c c2       	rjmp	.+1240   	; 0x27ac <uip_process+0x4f2>
    goto udp_send;
  }
#endif /* UIP_UDP */

  uip_sappdata = uip_appdata = &uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN];
    22d4:	03 ed       	ldi	r16, 0xD3	; 211
    22d6:	17 e0       	ldi	r17, 0x07	; 7
    22d8:	10 93 31 06 	sts	0x0631, r17
    22dc:	00 93 30 06 	sts	0x0630, r16
    22e0:	10 93 28 06 	sts	0x0628, r17
    22e4:	00 93 27 06 	sts	0x0627, r16

  /* Check if we were invoked because of a poll request for a
     particular connection. */
  if(flag == UIP_POLL_REQUEST) {
    22e8:	83 30       	cpi	r24, 0x03	; 3
    22ea:	99 f4       	brne	.+38     	; 0x2312 <uip_process+0x58>
    if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED &&
    22ec:	89 8d       	ldd	r24, Y+25	; 0x19
    22ee:	8f 70       	andi	r24, 0x0F	; 15
    22f0:	83 30       	cpi	r24, 0x03	; 3
    22f2:	09 f0       	breq	.+2      	; 0x22f6 <uip_process+0x3c>
    22f4:	56 c7       	rjmp	.+3756   	; 0x31a2 <uip_process+0xee8>
    22f6:	88 89       	ldd	r24, Y+16	; 0x10
    22f8:	99 89       	ldd	r25, Y+17	; 0x11
    22fa:	00 97       	sbiw	r24, 0x00	; 0
    22fc:	09 f0       	breq	.+2      	; 0x2300 <uip_process+0x46>
    22fe:	51 c7       	rjmp	.+3746   	; 0x31a2 <uip_process+0xee8>
       !uip_outstanding(uip_connr)) {
	uip_len = uip_slen = 0;
    2300:	10 92 8a 0d 	sts	0x0D8A, r1
    2304:	10 92 89 0d 	sts	0x0D89, r1
    2308:	10 92 26 06 	sts	0x0626, r1
    230c:	10 92 25 06 	sts	0x0625, r1
    2310:	8d c0       	rjmp	.+282    	; 0x242c <uip_process+0x172>
	goto appsend;
    }
    goto drop;

    /* Check if we were invoked because of the periodic timer firing. */
  } else if(flag == UIP_TIMER) {
    2312:	82 30       	cpi	r24, 0x02	; 2
    2314:	09 f0       	breq	.+2      	; 0x2318 <uip_process+0x5e>
    2316:	8e c0       	rjmp	.+284    	; 0x2434 <uip_process+0x17a>
    if(uip_reasstmr != 0) {
      --uip_reasstmr;
    }
#endif /* UIP_REASSEMBLY */
    /* Increase the initial sequence number. */
    if(++iss[3] == 0) {
    2318:	80 91 67 03 	lds	r24, 0x0367
    231c:	8f 5f       	subi	r24, 0xFF	; 255
    231e:	80 93 67 03 	sts	0x0367, r24
    2322:	88 23       	and	r24, r24
    2324:	99 f4       	brne	.+38     	; 0x234c <uip_process+0x92>
      if(++iss[2] == 0) {
    2326:	80 91 66 03 	lds	r24, 0x0366
    232a:	8f 5f       	subi	r24, 0xFF	; 255
    232c:	80 93 66 03 	sts	0x0366, r24
    2330:	88 23       	and	r24, r24
    2332:	61 f4       	brne	.+24     	; 0x234c <uip_process+0x92>
	if(++iss[1] == 0) {
    2334:	80 91 65 03 	lds	r24, 0x0365
    2338:	8f 5f       	subi	r24, 0xFF	; 255
    233a:	80 93 65 03 	sts	0x0365, r24
    233e:	88 23       	and	r24, r24
    2340:	29 f4       	brne	.+10     	; 0x234c <uip_process+0x92>
	  ++iss[0];
    2342:	80 91 64 03 	lds	r24, 0x0364
    2346:	8f 5f       	subi	r24, 0xFF	; 255
    2348:	80 93 64 03 	sts	0x0364, r24
	}
      }
    }

    /* Reset the length variables. */
    uip_len = 0;
    234c:	10 92 26 06 	sts	0x0626, r1
    2350:	10 92 25 06 	sts	0x0625, r1
    uip_slen = 0;
    2354:	10 92 8a 0d 	sts	0x0D8A, r1
    2358:	10 92 89 0d 	sts	0x0D89, r1

    /* Check if the connection is in a state in which we simply wait
       for the connection to time out. If so, we increase the
       connection's timer and remove the connection if it times
       out. */
    if(uip_connr->tcpstateflags == UIP_TIME_WAIT ||
    235c:	89 8d       	ldd	r24, Y+25	; 0x19
    235e:	87 30       	cpi	r24, 0x07	; 7
    2360:	11 f0       	breq	.+4      	; 0x2366 <uip_process+0xac>
    2362:	85 30       	cpi	r24, 0x05	; 5
    2364:	41 f4       	brne	.+16     	; 0x2376 <uip_process+0xbc>
       uip_connr->tcpstateflags == UIP_FIN_WAIT_2) {
      ++(uip_connr->timer);
    2366:	8a 8d       	ldd	r24, Y+26	; 0x1a
    2368:	8f 5f       	subi	r24, 0xFF	; 255
    236a:	8a 8f       	std	Y+26, r24	; 0x1a
      if(uip_connr->timer == UIP_TIME_WAIT_TIMEOUT) {
    236c:	88 37       	cpi	r24, 0x78	; 120
    236e:	09 f0       	breq	.+2      	; 0x2372 <uip_process+0xb8>
    2370:	18 c7       	rjmp	.+3632   	; 0x31a2 <uip_process+0xee8>
	uip_connr->tcpstateflags = UIP_CLOSED;
    2372:	19 8e       	std	Y+25, r1	; 0x19
    2374:	16 c7       	rjmp	.+3628   	; 0x31a2 <uip_process+0xee8>
      }
    } else if(uip_connr->tcpstateflags != UIP_CLOSED) {
    2376:	88 23       	and	r24, r24
    2378:	09 f4       	brne	.+2      	; 0x237c <uip_process+0xc2>
    237a:	13 c7       	rjmp	.+3622   	; 0x31a2 <uip_process+0xee8>
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
    237c:	28 89       	ldd	r18, Y+16	; 0x10
    237e:	39 89       	ldd	r19, Y+17	; 0x11
    2380:	21 15       	cp	r18, r1
    2382:	31 05       	cpc	r19, r1
    2384:	09 f4       	brne	.+2      	; 0x2388 <uip_process+0xce>
    2386:	4e c0       	rjmp	.+156    	; 0x2424 <uip_process+0x16a>
	if(uip_connr->timer-- == 0) {
    2388:	9a 8d       	ldd	r25, Y+26	; 0x1a
    238a:	29 2f       	mov	r18, r25
    238c:	21 50       	subi	r18, 0x01	; 1
    238e:	2a 8f       	std	Y+26, r18	; 0x1a
    2390:	99 23       	and	r25, r25
    2392:	09 f0       	breq	.+2      	; 0x2396 <uip_process+0xdc>
    2394:	06 c7       	rjmp	.+3596   	; 0x31a2 <uip_process+0xee8>
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    2396:	9b 8d       	ldd	r25, Y+27	; 0x1b
    2398:	98 30       	cpi	r25, 0x08	; 8
    239a:	31 f0       	breq	.+12     	; 0x23a8 <uip_process+0xee>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
    239c:	28 2f       	mov	r18, r24
    239e:	21 50       	subi	r18, 0x01	; 1
      /* If the connection has outstanding data, we increase the
	 connection's timer and see if it has reached the RTO value
	 in which case we retransmit. */
      if(uip_outstanding(uip_connr)) {
	if(uip_connr->timer-- == 0) {
	  if(uip_connr->nrtx == UIP_MAXRTX ||
    23a0:	22 30       	cpi	r18, 0x02	; 2
    23a2:	48 f4       	brcc	.+18     	; 0x23b6 <uip_process+0xfc>
	     ((uip_connr->tcpstateflags == UIP_SYN_SENT ||
	       uip_connr->tcpstateflags == UIP_SYN_RCVD) &&
    23a4:	95 30       	cpi	r25, 0x05	; 5
    23a6:	39 f4       	brne	.+14     	; 0x23b6 <uip_process+0xfc>
	      uip_connr->nrtx == UIP_MAXSYNRTX)) {
	    uip_connr->tcpstateflags = UIP_CLOSED;
    23a8:	19 8e       	std	Y+25, r1	; 0x19

	    /* We call UIP_APPCALL() with uip_flags set to
	       UIP_TIMEDOUT to inform the application that the
	       connection has timed out. */
	    uip_flags = UIP_TIMEDOUT;
    23aa:	80 e8       	ldi	r24, 0x80	; 128
    23ac:	80 93 2d 06 	sts	0x062D, r24
	    UIP_APPCALL();
    23b0:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
    23b4:	d1 c5       	rjmp	.+2978   	; 0x2f58 <uip_process+0xc9e>
	    BUF->flags = TCP_RST | TCP_ACK;
	    goto tcp_send_nodata;
	  }

	  /* Exponential back-off. */
	  uip_connr->timer = UIP_RTO << (uip_connr->nrtx > 4?
    23b6:	95 30       	cpi	r25, 0x05	; 5
    23b8:	48 f4       	brcc	.+18     	; 0x23cc <uip_process+0x112>
    23ba:	23 e0       	ldi	r18, 0x03	; 3
    23bc:	30 e0       	ldi	r19, 0x00	; 0
    23be:	09 2e       	mov	r0, r25
    23c0:	02 c0       	rjmp	.+4      	; 0x23c6 <uip_process+0x10c>
    23c2:	22 0f       	add	r18, r18
    23c4:	33 1f       	adc	r19, r19
    23c6:	0a 94       	dec	r0
    23c8:	e2 f7       	brpl	.-8      	; 0x23c2 <uip_process+0x108>
    23ca:	01 c0       	rjmp	.+2      	; 0x23ce <uip_process+0x114>
    23cc:	20 e3       	ldi	r18, 0x30	; 48
    23ce:	2a 8f       	std	Y+26, r18	; 0x1a
					 4:
					 uip_connr->nrtx);
	  ++(uip_connr->nrtx);
    23d0:	9f 5f       	subi	r25, 0xFF	; 255
    23d2:	9b 8f       	std	Y+27, r25	; 0x1b
	     call upon the application so that it may prepare the
	     data for the retransmit. In SYN_RCVD, we resend the
	     SYNACK that we sent earlier and in LAST_ACK we have to
	     retransmit our FINACK. */
	  UIP_STAT(++uip_stat.tcp.rexmit);
	  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    23d4:	90 e0       	ldi	r25, 0x00	; 0
    23d6:	8f 70       	andi	r24, 0x0F	; 15
    23d8:	90 70       	andi	r25, 0x00	; 0
    23da:	83 30       	cpi	r24, 0x03	; 3
    23dc:	91 05       	cpc	r25, r1
    23de:	e1 f0       	breq	.+56     	; 0x2418 <uip_process+0x15e>
    23e0:	84 30       	cpi	r24, 0x04	; 4
    23e2:	91 05       	cpc	r25, r1
    23e4:	4c f4       	brge	.+18     	; 0x23f8 <uip_process+0x13e>
    23e6:	81 30       	cpi	r24, 0x01	; 1
    23e8:	91 05       	cpc	r25, r1
    23ea:	09 f4       	brne	.+2      	; 0x23ee <uip_process+0x134>
    23ec:	b7 c3       	rjmp	.+1902   	; 0x2b5c <uip_process+0x8a2>
    23ee:	82 30       	cpi	r24, 0x02	; 2
    23f0:	91 05       	cpc	r25, r1
    23f2:	09 f0       	breq	.+2      	; 0x23f6 <uip_process+0x13c>
    23f4:	d6 c6       	rjmp	.+3500   	; 0x31a2 <uip_process+0xee8>
    23f6:	0d c0       	rjmp	.+26     	; 0x2412 <uip_process+0x158>
    23f8:	86 30       	cpi	r24, 0x06	; 6
    23fa:	91 05       	cpc	r25, r1
    23fc:	09 f4       	brne	.+2      	; 0x2400 <uip_process+0x146>
    23fe:	49 c5       	rjmp	.+2706   	; 0x2e92 <uip_process+0xbd8>
    2400:	88 30       	cpi	r24, 0x08	; 8
    2402:	91 05       	cpc	r25, r1
    2404:	09 f4       	brne	.+2      	; 0x2408 <uip_process+0x14e>
    2406:	45 c5       	rjmp	.+2698   	; 0x2e92 <uip_process+0xbd8>
    2408:	84 30       	cpi	r24, 0x04	; 4
    240a:	91 05       	cpc	r25, r1
    240c:	09 f0       	breq	.+2      	; 0x2410 <uip_process+0x156>
    240e:	c9 c6       	rjmp	.+3474   	; 0x31a2 <uip_process+0xee8>
    2410:	40 c5       	rjmp	.+2688   	; 0x2e92 <uip_process+0xbd8>
	    goto tcp_send_synack;

#if UIP_ACTIVE_OPEN
	  case UIP_SYN_SENT:
	    /* In the SYN_SENT state, we retransmit out SYN. */
	    BUF->flags = 0;
    2412:	10 92 cc 07 	sts	0x07CC, r1
	    goto tcp_send_syn;
    2416:	a5 c3       	rjmp	.+1866   	; 0x2b62 <uip_process+0x8a8>
	  case UIP_ESTABLISHED:
	    /* In the ESTABLISHED state, we call upon the application
               to do the actual retransmit after which we jump into
               the code for sending out the packet (the apprexmit
               label). */
	    uip_flags = UIP_REXMIT;
    2418:	84 e0       	ldi	r24, 0x04	; 4
    241a:	80 93 2d 06 	sts	0x062D, r24
	    UIP_APPCALL();
    241e:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
	    goto apprexmit;
    2422:	cc c5       	rjmp	.+2968   	; 0x2fbc <uip_process+0xd02>
	    /* In all these states we should retransmit a FINACK. */
	    goto tcp_send_finack;

	  }
	}
      } else if((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_ESTABLISHED) {
    2424:	8f 70       	andi	r24, 0x0F	; 15
    2426:	83 30       	cpi	r24, 0x03	; 3
    2428:	09 f0       	breq	.+2      	; 0x242c <uip_process+0x172>
    242a:	bb c6       	rjmp	.+3446   	; 0x31a2 <uip_process+0xee8>
	/* If there was no need for a retransmission, we poll the
           application for new data. */
	uip_len = uip_slen = 0;
	uip_flags = UIP_POLL;
    242c:	88 e0       	ldi	r24, 0x08	; 8
    242e:	80 93 2d 06 	sts	0x062D, r24
    2432:	87 c5       	rjmp	.+2830   	; 0x2f42 <uip_process+0xc88>
      }
    }
    goto drop;
  }
#if UIP_UDP
  if(flag == UIP_UDP_TIMER) {
    2434:	85 30       	cpi	r24, 0x05	; 5
    2436:	19 f5       	brne	.+70     	; 0x247e <uip_process+0x1c4>
    if(uip_udp_conn->lport != 0) {
    2438:	e0 91 2e 06 	lds	r30, 0x062E
    243c:	f0 91 2f 06 	lds	r31, 0x062F
    2440:	84 81       	ldd	r24, Z+4	; 0x04
    2442:	95 81       	ldd	r25, Z+5	; 0x05
    2444:	00 97       	sbiw	r24, 0x00	; 0
    2446:	09 f4       	brne	.+2      	; 0x244a <uip_process+0x190>
    2448:	ac c6       	rjmp	.+3416   	; 0x31a2 <uip_process+0xee8>
      uip_conn = NULL;
    244a:	10 92 33 06 	sts	0x0633, r1
    244e:	10 92 32 06 	sts	0x0632, r1
      uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    2452:	0c 50       	subi	r16, 0x0C	; 12
    2454:	10 40       	sbci	r17, 0x00	; 0
    2456:	10 93 31 06 	sts	0x0631, r17
    245a:	00 93 30 06 	sts	0x0630, r16
    245e:	10 93 28 06 	sts	0x0628, r17
    2462:	00 93 27 06 	sts	0x0627, r16
      uip_len = uip_slen = 0;
    2466:	10 92 8a 0d 	sts	0x0D8A, r1
    246a:	10 92 89 0d 	sts	0x0D89, r1
    246e:	10 92 26 06 	sts	0x0626, r1
    2472:	10 92 25 06 	sts	0x0625, r1
      uip_flags = UIP_POLL;
    2476:	88 e0       	ldi	r24, 0x08	; 8
    2478:	80 93 2d 06 	sts	0x062D, r24
    247c:	95 c1       	rjmp	.+810    	; 0x27a8 <uip_process+0x4ee>
    UIP_LOG("ipv6: invalid version.");
    goto drop;
  }
#else /* UIP_CONF_IPV6 */
  /* Check validity of the IP header. */
  if(BUF->vhl != 0x45)  { /* IP version and header length. */
    247e:	08 52       	subi	r16, 0x28	; 40
    2480:	10 40       	sbci	r17, 0x00	; 0
    2482:	80 91 ab 07 	lds	r24, 0x07AB
    2486:	85 34       	cpi	r24, 0x45	; 69
    2488:	09 f0       	breq	.+2      	; 0x248c <uip_process+0x1d2>
    248a:	8b c6       	rjmp	.+3350   	; 0x31a2 <uip_process+0xee8>
     that the packet has been corrupted in transit. If the size of
     uip_len is larger than the size reported in the IP packet header,
     the packet has been padded and we set uip_len to the correct
     value.. */

  if((BUF->len[0] << 8) + BUF->len[1] <= uip_len) {
    248c:	90 91 ad 07 	lds	r25, 0x07AD
    2490:	80 e0       	ldi	r24, 0x00	; 0
    2492:	20 91 ae 07 	lds	r18, 0x07AE
    2496:	7c 01       	movw	r14, r24
    2498:	e2 0e       	add	r14, r18
    249a:	f1 1c       	adc	r15, r1
    249c:	80 91 25 06 	lds	r24, 0x0625
    24a0:	90 91 26 06 	lds	r25, 0x0626
    24a4:	8e 15       	cp	r24, r14
    24a6:	9f 05       	cpc	r25, r15
    24a8:	08 f4       	brcc	.+2      	; 0x24ac <uip_process+0x1f2>
    24aa:	7b c6       	rjmp	.+3318   	; 0x31a2 <uip_process+0xee8>
    uip_len = (BUF->len[0] << 8) + BUF->len[1];
    24ac:	f0 92 26 06 	sts	0x0626, r15
    24b0:	e0 92 25 06 	sts	0x0625, r14
    goto drop;
  }

#if !UIP_CONF_IPV6
  /* Check the fragment flag. */
  if((BUF->ipoffset[0] & 0x3f) != 0 ||
    24b4:	80 91 b1 07 	lds	r24, 0x07B1
    24b8:	90 e0       	ldi	r25, 0x00	; 0
    24ba:	8f 73       	andi	r24, 0x3F	; 63
    24bc:	90 70       	andi	r25, 0x00	; 0
    24be:	00 97       	sbiw	r24, 0x00	; 0
    24c0:	09 f0       	breq	.+2      	; 0x24c4 <uip_process+0x20a>
    24c2:	6f c6       	rjmp	.+3294   	; 0x31a2 <uip_process+0xee8>
    24c4:	80 91 b2 07 	lds	r24, 0x07B2
    24c8:	88 23       	and	r24, r24
    24ca:	09 f0       	breq	.+2      	; 0x24ce <uip_process+0x214>
    24cc:	6a c6       	rjmp	.+3284   	; 0x31a2 <uip_process+0xee8>
    goto drop;
#endif /* UIP_REASSEMBLY */
  }
#endif /* UIP_CONF_IPV6 */

  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    24ce:	80 91 99 07 	lds	r24, 0x0799
    24d2:	90 91 9a 07 	lds	r25, 0x079A
    24d6:	20 91 24 03 	lds	r18, 0x0324
    24da:	30 91 25 03 	lds	r19, 0x0325
    24de:	82 17       	cp	r24, r18
    24e0:	93 07       	cpc	r25, r19
    24e2:	61 f4       	brne	.+24     	; 0x24fc <uip_process+0x242>
    24e4:	60 91 9b 07 	lds	r22, 0x079B
    24e8:	70 91 9c 07 	lds	r23, 0x079C
    24ec:	40 91 26 03 	lds	r20, 0x0326
    24f0:	50 91 27 03 	lds	r21, 0x0327
    24f4:	64 17       	cp	r22, r20
    24f6:	75 07       	cpc	r23, r21
    24f8:	09 f4       	brne	.+2      	; 0x24fc <uip_process+0x242>
    24fa:	4b c0       	rjmp	.+150    	; 0x2592 <uip_process+0x2d8>
  } else {
    /* If IP broadcast support is configured, we check for a broadcast
       UDP packet, which may be destined to us. */
#if UIP_BROADCAST
    DEBUG_PRINTF("UDP IP checksum 0x%04x\n", uip_ipchksum());
    if(BUF->proto == UIP_PROTO_UDP &&
    24fc:	40 91 b4 07 	lds	r20, 0x07B4
    2500:	41 31       	cpi	r20, 0x11	; 17
    2502:	99 f5       	brne	.+102    	; 0x256a <uip_process+0x2b0>
    2504:	60 91 bb 07 	lds	r22, 0x07BB
    2508:	70 91 bc 07 	lds	r23, 0x07BC
    250c:	40 91 20 03 	lds	r20, 0x0320
    2510:	50 91 21 03 	lds	r21, 0x0321
    2514:	64 17       	cp	r22, r20
    2516:	75 07       	cpc	r23, r21
    2518:	41 f5       	brne	.+80     	; 0x256a <uip_process+0x2b0>
       uip_ipaddr_cmp(&BUF->destipaddr, &uip_broadcast_addr))
    251a:	60 91 bd 07 	lds	r22, 0x07BD
    251e:	70 91 be 07 	lds	r23, 0x07BE
    2522:	40 91 22 03 	lds	r20, 0x0322
    2526:	50 91 23 03 	lds	r21, 0x0323
    252a:	64 17       	cp	r22, r20
    252c:	75 07       	cpc	r23, r21
    252e:	e9 f4       	brne	.+58     	; 0x256a <uip_process+0x2b0>
	{
		if (uip_ipaddr_cmp(&BUF->srcipaddr, &uip_all_zeroes_addr))
    2530:	e7 eb       	ldi	r30, 0xB7	; 183
    2532:	f7 e0       	ldi	r31, 0x07	; 7
    2534:	80 91 b7 07 	lds	r24, 0x07B7
    2538:	90 91 b8 07 	lds	r25, 0x07B8
    253c:	82 17       	cp	r24, r18
    253e:	93 07       	cpc	r25, r19
    2540:	09 f0       	breq	.+2      	; 0x2544 <uip_process+0x28a>
    2542:	70 c0       	rjmp	.+224    	; 0x2624 <uip_process+0x36a>
    2544:	20 91 b9 07 	lds	r18, 0x07B9
    2548:	30 91 ba 07 	lds	r19, 0x07BA
    254c:	80 91 26 03 	lds	r24, 0x0326
    2550:	90 91 27 03 	lds	r25, 0x0327
    2554:	28 17       	cp	r18, r24
    2556:	39 07       	cpc	r19, r25
    2558:	09 f0       	breq	.+2      	; 0x255c <uip_process+0x2a2>
    255a:	64 c0       	rjmp	.+200    	; 0x2624 <uip_process+0x36a>
		  uip_ipaddr_copy(&BUF->srcipaddr, &uip_broadcast_addr);
    255c:	8f ef       	ldi	r24, 0xFF	; 255
    255e:	80 93 b7 07 	sts	0x07B7, r24
    2562:	81 83       	std	Z+1, r24	; 0x01
    2564:	82 83       	std	Z+2, r24	; 0x02
    2566:	83 83       	std	Z+3, r24	; 0x03
    2568:	5d c0       	rjmp	.+186    	; 0x2624 <uip_process+0x36a>
    }
#endif /* UIP_BROADCAST */

    /* Check if the packet is destined for our IP address. */
#if !UIP_CONF_IPV6
    if(!uip_ipaddr_cmp(&BUF->destipaddr, &uip_hostaddr)) {
    256a:	20 91 bb 07 	lds	r18, 0x07BB
    256e:	30 91 bc 07 	lds	r19, 0x07BC
    2572:	28 17       	cp	r18, r24
    2574:	39 07       	cpc	r19, r25
    2576:	09 f0       	breq	.+2      	; 0x257a <uip_process+0x2c0>
    2578:	14 c6       	rjmp	.+3112   	; 0x31a2 <uip_process+0xee8>
    257a:	20 91 bd 07 	lds	r18, 0x07BD
    257e:	30 91 be 07 	lds	r19, 0x07BE
    2582:	80 91 9b 07 	lds	r24, 0x079B
    2586:	90 91 9c 07 	lds	r25, 0x079C
    258a:	28 17       	cp	r18, r24
    258c:	39 07       	cpc	r19, r25
    258e:	09 f0       	breq	.+2      	; 0x2592 <uip_process+0x2d8>
    2590:	08 c6       	rjmp	.+3088   	; 0x31a2 <uip_process+0xee8>
    }
#endif /* UIP_CONF_IPV6 */
  }

#if !UIP_CONF_IPV6
  if(uip_ipchksum() != 0xffff) { /* Compute and check the IP header
    2592:	5a de       	rcall	.-844    	; 0x2248 <uip_ipchksum>
    2594:	2f ef       	ldi	r18, 0xFF	; 255
    2596:	8f 3f       	cpi	r24, 0xFF	; 255
    2598:	92 07       	cpc	r25, r18
    259a:	09 f0       	breq	.+2      	; 0x259e <uip_process+0x2e4>
    259c:	02 c6       	rjmp	.+3076   	; 0x31a2 <uip_process+0xee8>
    UIP_LOG("ip: bad checksum.");
    goto drop;
  }
#endif /* UIP_CONF_IPV6 */

  if(BUF->proto == UIP_PROTO_TCP) { /* Check for TCP packet. If so,
    259e:	80 91 b4 07 	lds	r24, 0x07B4
    25a2:	86 30       	cpi	r24, 0x06	; 6
    25a4:	09 f4       	brne	.+2      	; 0x25a8 <uip_process+0x2ee>
    25a6:	4e c1       	rjmp	.+668    	; 0x2844 <uip_process+0x58a>
				       processing. */
    goto tcp_input;
  }

#if UIP_UDP
  if(BUF->proto == UIP_PROTO_UDP) {
    25a8:	81 31       	cpi	r24, 0x11	; 17
    25aa:	e1 f1       	breq	.+120    	; 0x2624 <uip_process+0x36a>
  }
#endif /* UIP_UDP */

#if !UIP_CONF_IPV6
  /* ICMPv4 processing code follows. */
  if(BUF->proto != UIP_PROTO_ICMP) { /* We only allow ICMP packets from
    25ac:	81 30       	cpi	r24, 0x01	; 1
    25ae:	09 f0       	breq	.+2      	; 0x25b2 <uip_process+0x2f8>
    25b0:	f8 c5       	rjmp	.+3056   	; 0x31a2 <uip_process+0xee8>
  UIP_STAT(++uip_stat.icmp.recv);

  /* ICMP echo (i.e., ping) processing. This is simple, we only change
     the ICMP type from ECHO to ECHO_REPLY and adjust the ICMP
     checksum before we return the packet. */
  if(ICMPBUF->type != ICMP_ECHO) {
    25b2:	eb ea       	ldi	r30, 0xAB	; 171
    25b4:	f7 e0       	ldi	r31, 0x07	; 7
    25b6:	80 91 bf 07 	lds	r24, 0x07BF
    25ba:	88 30       	cpi	r24, 0x08	; 8
    25bc:	09 f0       	breq	.+2      	; 0x25c0 <uip_process+0x306>
    25be:	f1 c5       	rjmp	.+3042   	; 0x31a2 <uip_process+0xee8>
  if(uip_ipaddr_cmp(&uip_hostaddr, &uip_all_zeroes_addr)) {
    uip_hostaddr = BUF->destipaddr;
  }
#endif /* UIP_PINGADDRCONF */

  ICMPBUF->type = ICMP_ECHO_REPLY;
    25c0:	14 8a       	std	Z+20, r1	; 0x14

  if(ICMPBUF->icmpchksum >= HTONS(0xffff - (ICMP_ECHO << 8))) {
    25c2:	80 91 c1 07 	lds	r24, 0x07C1
    25c6:	90 91 c2 07 	lds	r25, 0x07C2
    25ca:	6f ef       	ldi	r22, 0xFF	; 255
    25cc:	87 3f       	cpi	r24, 0xF7	; 247
    25ce:	96 07       	cpc	r25, r22
    25d0:	10 f0       	brcs	.+4      	; 0x25d6 <uip_process+0x31c>
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8) + 1;
    25d2:	09 96       	adiw	r24, 0x09	; 9
    25d4:	01 c0       	rjmp	.+2      	; 0x25d8 <uip_process+0x31e>
  } else {
    ICMPBUF->icmpchksum += HTONS(ICMP_ECHO << 8);
    25d6:	08 96       	adiw	r24, 0x08	; 8
    25d8:	97 8b       	std	Z+23, r25	; 0x17
    25da:	86 8b       	std	Z+22, r24	; 0x16
  }

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    25dc:	80 91 b7 07 	lds	r24, 0x07B7
    25e0:	90 91 b8 07 	lds	r25, 0x07B8
    25e4:	a0 91 b9 07 	lds	r26, 0x07B9
    25e8:	b0 91 ba 07 	lds	r27, 0x07BA
    25ec:	80 93 bb 07 	sts	0x07BB, r24
    25f0:	90 93 bc 07 	sts	0x07BC, r25
    25f4:	a0 93 bd 07 	sts	0x07BD, r26
    25f8:	b0 93 be 07 	sts	0x07BE, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    25fc:	80 91 99 07 	lds	r24, 0x0799
    2600:	90 91 9a 07 	lds	r25, 0x079A
    2604:	a0 91 9b 07 	lds	r26, 0x079B
    2608:	b0 91 9c 07 	lds	r27, 0x079C
    260c:	80 93 b7 07 	sts	0x07B7, r24
    2610:	90 93 b8 07 	sts	0x07B8, r25
    2614:	a0 93 b9 07 	sts	0x07B9, r26
    2618:	b0 93 ba 07 	sts	0x07BA, r27

  UIP_STAT(++uip_stat.icmp.sent);
  BUF->ttl = UIP_TTL;
    261c:	80 e4       	ldi	r24, 0x40	; 64
    261e:	f8 01       	movw	r30, r16
    2620:	80 87       	std	Z+8, r24	; 0x08
  goto ip_send_nolen;
    2622:	a4 c5       	rjmp	.+2888   	; 0x316c <uip_process+0xeb2>
    UIP_STAT(++uip_stat.udp.chkerr);
    UIP_LOG("udp: bad checksum.");
    goto drop;
  }
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
    2624:	c7 01       	movw	r24, r14
    2626:	4c 97       	sbiw	r24, 0x1c	; 28
    2628:	90 93 26 06 	sts	0x0626, r25
    262c:	80 93 25 06 	sts	0x0625, r24
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    2630:	8b e8       	ldi	r24, 0x8B	; 139
    2632:	9d e0       	ldi	r25, 0x0D	; 13
    2634:	90 93 2f 06 	sts	0x062F, r25
    2638:	80 93 2e 06 	sts	0x062E, r24
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    263c:	a0 91 24 03 	lds	r26, 0x0324
    2640:	b0 91 25 03 	lds	r27, 0x0325
    2644:	60 91 26 03 	lds	r22, 0x0326
    2648:	70 91 27 03 	lds	r23, 0x0327
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    264c:	40 91 20 03 	lds	r20, 0x0320
    2650:	50 91 21 03 	lds	r21, 0x0321
    2654:	20 91 22 03 	lds	r18, 0x0322
    2658:	30 91 23 03 	lds	r19, 0x0323
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    265c:	40 c0       	rjmp	.+128    	; 0x26de <uip_process+0x424>
       destination port number in the received packet. If the two port
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
    265e:	84 81       	ldd	r24, Z+4	; 0x04
    2660:	95 81       	ldd	r25, Z+5	; 0x05
    2662:	00 97       	sbiw	r24, 0x00	; 0
    2664:	b9 f1       	breq	.+110    	; 0x26d4 <uip_process+0x41a>
    2666:	c0 91 c1 07 	lds	r28, 0x07C1
    266a:	d0 91 c2 07 	lds	r29, 0x07C2
    266e:	c8 17       	cp	r28, r24
    2670:	d9 07       	cpc	r29, r25
    2672:	81 f5       	brne	.+96     	; 0x26d4 <uip_process+0x41a>
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
    2674:	86 81       	ldd	r24, Z+6	; 0x06
    2676:	97 81       	ldd	r25, Z+7	; 0x07
       numbers match, the remote port number is checked if the
       connection is bound to a remote port. Finally, if the
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
    2678:	00 97       	sbiw	r24, 0x00	; 0
    267a:	39 f0       	breq	.+14     	; 0x268a <uip_process+0x3d0>
       (uip_udp_conn->rport == 0 ||
    267c:	c0 91 bf 07 	lds	r28, 0x07BF
    2680:	d0 91 c0 07 	lds	r29, 0x07C0
    2684:	c8 17       	cp	r28, r24
    2686:	d9 07       	cpc	r29, r25
    2688:	29 f5       	brne	.+74     	; 0x26d4 <uip_process+0x41a>
        UDPBUF->srcport == uip_udp_conn->rport) &&
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    268a:	80 81       	ld	r24, Z
    268c:	91 81       	ldd	r25, Z+1	; 0x01
       connection is bound to a remote IP address, the source IP
       address of the packet is checked. */
    if(uip_udp_conn->lport != 0 &&
       UDPBUF->destport == uip_udp_conn->lport &&
       (uip_udp_conn->rport == 0 ||
        UDPBUF->srcport == uip_udp_conn->rport) &&
    268e:	8a 17       	cp	r24, r26
    2690:	9b 07       	cpc	r25, r27
    2692:	31 f4       	brne	.+12     	; 0x26a0 <uip_process+0x3e6>
       (uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_all_zeroes_addr) ||
    2694:	c2 81       	ldd	r28, Z+2	; 0x02
    2696:	d3 81       	ldd	r29, Z+3	; 0x03
    2698:	c6 17       	cp	r28, r22
    269a:	d7 07       	cpc	r29, r23
    269c:	09 f4       	brne	.+2      	; 0x26a0 <uip_process+0x3e6>
    269e:	6f c0       	rjmp	.+222    	; 0x277e <uip_process+0x4c4>
    26a0:	84 17       	cp	r24, r20
    26a2:	95 07       	cpc	r25, r21
    26a4:	31 f4       	brne	.+12     	; 0x26b2 <uip_process+0x3f8>
	uip_ipaddr_cmp(&uip_udp_conn->ripaddr, &uip_broadcast_addr) ||
    26a6:	c2 81       	ldd	r28, Z+2	; 0x02
    26a8:	d3 81       	ldd	r29, Z+3	; 0x03
    26aa:	c2 17       	cp	r28, r18
    26ac:	d3 07       	cpc	r29, r19
    26ae:	09 f4       	brne	.+2      	; 0x26b2 <uip_process+0x3f8>
    26b0:	66 c0       	rjmp	.+204    	; 0x277e <uip_process+0x4c4>
    26b2:	c0 91 b7 07 	lds	r28, 0x07B7
    26b6:	d0 91 b8 07 	lds	r29, 0x07B8
    26ba:	c8 17       	cp	r28, r24
    26bc:	d9 07       	cpc	r29, r25
    26be:	51 f4       	brne	.+20     	; 0x26d4 <uip_process+0x41a>
	uip_ipaddr_cmp(&BUF->srcipaddr, &uip_udp_conn->ripaddr))) {
    26c0:	c0 91 b9 07 	lds	r28, 0x07B9
    26c4:	d0 91 ba 07 	lds	r29, 0x07BA
    26c8:	82 81       	ldd	r24, Z+2	; 0x02
    26ca:	93 81       	ldd	r25, Z+3	; 0x03
    26cc:	c8 17       	cp	r28, r24
    26ce:	d9 07       	cpc	r29, r25
    26d0:	09 f4       	brne	.+2      	; 0x26d4 <uip_process+0x41a>
    26d2:	55 c0       	rjmp	.+170    	; 0x277e <uip_process+0x4c4>
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
      ++uip_udp_conn) {
    26d4:	7e 96       	adiw	r30, 0x1e	; 30
    26d6:	f0 93 2f 06 	sts	0x062F, r31
    26da:	e0 93 2e 06 	sts	0x062E, r30
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
      uip_udp_conn < &uip_udp_conns[UIP_UDP_CONNS];
    26de:	e0 91 2e 06 	lds	r30, 0x062E
    26e2:	f0 91 2f 06 	lds	r31, 0x062F
#else /* UIP_UDP_CHECKSUMS */
  uip_len = uip_len - UIP_IPUDPH_LEN;
#endif /* UIP_UDP_CHECKSUMS */

  /* Demultiplex this UDP packet between the UDP "connections". */
  for(uip_udp_conn = &uip_udp_conns[0];
    26e6:	8d e0       	ldi	r24, 0x0D	; 13
    26e8:	e9 3a       	cpi	r30, 0xA9	; 169
    26ea:	f8 07       	cpc	r31, r24
    26ec:	08 f4       	brcc	.+2      	; 0x26f0 <uip_process+0x436>
    26ee:	b7 cf       	rjmp	.-146    	; 0x265e <uip_process+0x3a4>
    }
  }
  UIP_LOG("udp: no matching connection found");
#if UIP_CONF_ICMP_DEST_UNREACH && !UIP_CONF_IPV6
  /* Copy fields from packet header into payload of this ICMP packet. */
  memcpy(&(ICMPBUF->payload[0]), ICMPBUF, UIP_IPH_LEN + 8);
    26f0:	e7 ec       	ldi	r30, 0xC7	; 199
    26f2:	f7 e0       	ldi	r31, 0x07	; 7
    26f4:	df 01       	movw	r26, r30
    26f6:	5c 97       	sbiw	r26, 0x1c	; 28
    26f8:	8c e1       	ldi	r24, 0x1C	; 28
    26fa:	0d 90       	ld	r0, X+
    26fc:	01 92       	st	Z+, r0
    26fe:	81 50       	subi	r24, 0x01	; 1
    2700:	e1 f7       	brne	.-8      	; 0x26fa <uip_process+0x440>

  /* Set the ICMP type and code. */
  ICMPBUF->type = ICMP_DEST_UNREACHABLE;
    2702:	cb ea       	ldi	r28, 0xAB	; 171
    2704:	d7 e0       	ldi	r29, 0x07	; 7
    2706:	83 e0       	ldi	r24, 0x03	; 3
    2708:	8c 8b       	std	Y+20, r24	; 0x14
  ICMPBUF->icode = ICMP_PORT_UNREACHABLE;
    270a:	8d 8b       	std	Y+21, r24	; 0x15

  /* Calculate the ICMP checksum. */
  ICMPBUF->icmpchksum = 0;
    270c:	1f 8a       	std	Y+23, r1	; 0x17
    270e:	1e 8a       	std	Y+22, r1	; 0x16
  ICMPBUF->icmpchksum = ~uip_chksum((u16_t *)&(ICMPBUF->type), 36);
    2710:	ce 01       	movw	r24, r28
    2712:	44 96       	adiw	r24, 0x14	; 20
    2714:	64 e2       	ldi	r22, 0x24	; 36
    2716:	70 e0       	ldi	r23, 0x00	; 0
    2718:	a7 dd       	rcall	.-1202   	; 0x2268 <uip_chksum>
    271a:	80 95       	com	r24
    271c:	90 95       	com	r25
    271e:	9f 8b       	std	Y+23, r25	; 0x17
    2720:	8e 8b       	std	Y+22, r24	; 0x16

  /* Set the IP destination address to be the source address of the
     original packet. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2722:	80 91 b7 07 	lds	r24, 0x07B7
    2726:	90 91 b8 07 	lds	r25, 0x07B8
    272a:	a0 91 b9 07 	lds	r26, 0x07B9
    272e:	b0 91 ba 07 	lds	r27, 0x07BA
    2732:	80 93 bb 07 	sts	0x07BB, r24
    2736:	90 93 bc 07 	sts	0x07BC, r25
    273a:	a0 93 bd 07 	sts	0x07BD, r26
    273e:	b0 93 be 07 	sts	0x07BE, r27

  /* Set our IP address as the source address. */
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2742:	80 91 99 07 	lds	r24, 0x0799
    2746:	90 91 9a 07 	lds	r25, 0x079A
    274a:	a0 91 9b 07 	lds	r26, 0x079B
    274e:	b0 91 9c 07 	lds	r27, 0x079C
    2752:	80 93 b7 07 	sts	0x07B7, r24
    2756:	90 93 b8 07 	sts	0x07B8, r25
    275a:	a0 93 b9 07 	sts	0x07B9, r26
    275e:	b0 93 ba 07 	sts	0x07BA, r27

  /* The size of the ICMP destination unreachable packet is 36 + the
     size of the IP header (20) = 56. */
  uip_len = 36 + UIP_IPH_LEN;
    2762:	88 e3       	ldi	r24, 0x38	; 56
    2764:	90 e0       	ldi	r25, 0x00	; 0
    2766:	90 93 26 06 	sts	0x0626, r25
    276a:	80 93 25 06 	sts	0x0625, r24
  ICMPBUF->len[0] = 0;
    276e:	1a 82       	std	Y+2, r1	; 0x02
  ICMPBUF->len[1] = (u8_t)uip_len;
    2770:	88 e3       	ldi	r24, 0x38	; 56
    2772:	8b 83       	std	Y+3, r24	; 0x03
  ICMPBUF->ttl = UIP_TTL;
    2774:	80 e4       	ldi	r24, 0x40	; 64
    2776:	88 87       	std	Y+8, r24	; 0x08
  ICMPBUF->proto = UIP_PROTO_ICMP;
    2778:	81 e0       	ldi	r24, 0x01	; 1
    277a:	89 87       	std	Y+9, r24	; 0x09

  goto ip_send_nolen;
    277c:	f7 c4       	rjmp	.+2542   	; 0x316c <uip_process+0xeb2>
#else /* UIP_CONF_ICMP_DEST_UNREACH */
  goto drop;
#endif /* UIP_CONF_ICMP_DEST_UNREACH */

 udp_found:
  uip_conn = NULL;
    277e:	10 92 33 06 	sts	0x0633, r1
    2782:	10 92 32 06 	sts	0x0632, r1
  uip_flags = UIP_NEWDATA;
    2786:	82 e0       	ldi	r24, 0x02	; 2
    2788:	80 93 2d 06 	sts	0x062D, r24
  uip_sappdata = uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPUDPH_LEN];
    278c:	87 ec       	ldi	r24, 0xC7	; 199
    278e:	97 e0       	ldi	r25, 0x07	; 7
    2790:	90 93 31 06 	sts	0x0631, r25
    2794:	80 93 30 06 	sts	0x0630, r24
    2798:	90 93 28 06 	sts	0x0628, r25
    279c:	80 93 27 06 	sts	0x0627, r24
  uip_slen = 0;
    27a0:	10 92 8a 0d 	sts	0x0D8A, r1
    27a4:	10 92 89 0d 	sts	0x0D89, r1
  UIP_UDP_APPCALL();
    27a8:	0e 94 86 09 	call	0x130c	; 0x130c <uIPManagement_UDPCallback>

 udp_send:
  if(uip_slen == 0) {
    27ac:	80 91 89 0d 	lds	r24, 0x0D89
    27b0:	90 91 8a 0d 	lds	r25, 0x0D8A
    27b4:	00 97       	sbiw	r24, 0x00	; 0
    27b6:	09 f4       	brne	.+2      	; 0x27ba <uip_process+0x500>
    27b8:	f4 c4       	rjmp	.+2536   	; 0x31a2 <uip_process+0xee8>
    goto drop;
  }
  uip_len = uip_slen + UIP_IPUDPH_LEN;
    27ba:	9c 01       	movw	r18, r24
    27bc:	24 5e       	subi	r18, 0xE4	; 228
    27be:	3f 4f       	sbci	r19, 0xFF	; 255
    27c0:	30 93 26 06 	sts	0x0626, r19
    27c4:	20 93 25 06 	sts	0x0625, r18
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    27c8:	eb ea       	ldi	r30, 0xAB	; 171
    27ca:	f7 e0       	ldi	r31, 0x07	; 7
    27cc:	32 83       	std	Z+2, r19	; 0x02
  BUF->len[1] = (uip_len & 0xff);
    27ce:	23 83       	std	Z+3, r18	; 0x03
#endif /* UIP_CONF_IPV6 */

  BUF->ttl = uip_udp_conn->ttl;
    27d0:	c0 91 2e 06 	lds	r28, 0x062E
    27d4:	d0 91 2f 06 	lds	r29, 0x062F
    27d8:	28 85       	ldd	r18, Y+8	; 0x08
    27da:	20 87       	std	Z+8, r18	; 0x08
  BUF->proto = UIP_PROTO_UDP;
    27dc:	21 e1       	ldi	r18, 0x11	; 17
    27de:	21 87       	std	Z+9, r18	; 0x09

  UDPBUF->udplen = HTONS(uip_slen + UIP_UDPH_LEN);
    27e0:	08 96       	adiw	r24, 0x08	; 8
    27e2:	98 27       	eor	r25, r24
    27e4:	89 27       	eor	r24, r25
    27e6:	98 27       	eor	r25, r24
    27e8:	91 8f       	std	Z+25, r25	; 0x19
    27ea:	80 8f       	std	Z+24, r24	; 0x18
  UDPBUF->udpchksum = 0;
    27ec:	13 8e       	std	Z+27, r1	; 0x1b
    27ee:	12 8e       	std	Z+26, r1	; 0x1a

  BUF->srcport  = uip_udp_conn->lport;
    27f0:	8c 81       	ldd	r24, Y+4	; 0x04
    27f2:	9d 81       	ldd	r25, Y+5	; 0x05
    27f4:	95 8b       	std	Z+21, r25	; 0x15
    27f6:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = uip_udp_conn->rport;
    27f8:	8e 81       	ldd	r24, Y+6	; 0x06
    27fa:	9f 81       	ldd	r25, Y+7	; 0x07
    27fc:	97 8b       	std	Z+23, r25	; 0x17
    27fe:	86 8b       	std	Z+22, r24	; 0x16

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    2800:	80 91 99 07 	lds	r24, 0x0799
    2804:	90 91 9a 07 	lds	r25, 0x079A
    2808:	a0 91 9b 07 	lds	r26, 0x079B
    280c:	b0 91 9c 07 	lds	r27, 0x079C
    2810:	80 93 b7 07 	sts	0x07B7, r24
    2814:	90 93 b8 07 	sts	0x07B8, r25
    2818:	a0 93 b9 07 	sts	0x07B9, r26
    281c:	b0 93 ba 07 	sts	0x07BA, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_udp_conn->ripaddr);
    2820:	88 81       	ld	r24, Y
    2822:	99 81       	ldd	r25, Y+1	; 0x01
    2824:	aa 81       	ldd	r26, Y+2	; 0x02
    2826:	bb 81       	ldd	r27, Y+3	; 0x03
    2828:	80 93 bb 07 	sts	0x07BB, r24
    282c:	90 93 bc 07 	sts	0x07BC, r25
    2830:	a0 93 bd 07 	sts	0x07BD, r26
    2834:	b0 93 be 07 	sts	0x07BE, r27

  uip_appdata = &uip_buf[UIP_LLH_LEN + UIP_IPTCPH_LEN];
    2838:	b8 96       	adiw	r30, 0x28	; 40
    283a:	f0 93 31 06 	sts	0x0631, r31
    283e:	e0 93 30 06 	sts	0x0630, r30
  if(UDPBUF->udpchksum == 0) {
    UDPBUF->udpchksum = 0xffff;
  }
#endif /* UIP_UDP_CHECKSUMS */

  goto ip_send_nolen;
    2842:	94 c4       	rjmp	.+2344   	; 0x316c <uip_process+0xeb2>
 tcp_input:
  UIP_STAT(++uip_stat.tcp.recv);

  /* Start of TCP input header processing code. */

  if(uip_tcpchksum() != 0xffff) {   /* Compute and check the TCP
    2844:	18 dd       	rcall	.-1488   	; 0x2276 <uip_tcpchksum>
    2846:	ef ef       	ldi	r30, 0xFF	; 255
    2848:	8f 3f       	cpi	r24, 0xFF	; 255
    284a:	9e 07       	cpc	r25, r30
    284c:	09 f0       	breq	.+2      	; 0x2850 <uip_process+0x596>
    284e:	a9 c4       	rjmp	.+2386   	; 0x31a2 <uip_process+0xee8>
  uip_conn->rcv_nxt[2] = uip_acc32[2];
  uip_conn->rcv_nxt[3] = uip_acc32[3];
}
/*---------------------------------------------------------------------------*/
void
uip_process(u8_t flag)
    2850:	c4 e3       	ldi	r28, 0x34	; 52
    2852:	d6 e0       	ldi	r29, 0x06	; 6

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    if(uip_connr->tcpstateflags != UIP_CLOSED &&
    2854:	49 8d       	ldd	r20, Y+25	; 0x19
    2856:	44 23       	and	r20, r20
    2858:	29 f1       	breq	.+74     	; 0x28a4 <uip_process+0x5ea>
    285a:	20 91 c1 07 	lds	r18, 0x07C1
    285e:	30 91 c2 07 	lds	r19, 0x07C2
    2862:	8c 81       	ldd	r24, Y+4	; 0x04
    2864:	9d 81       	ldd	r25, Y+5	; 0x05
    2866:	28 17       	cp	r18, r24
    2868:	39 07       	cpc	r19, r25
    286a:	e1 f4       	brne	.+56     	; 0x28a4 <uip_process+0x5ea>
       BUF->destport == uip_connr->lport &&
    286c:	20 91 bf 07 	lds	r18, 0x07BF
    2870:	30 91 c0 07 	lds	r19, 0x07C0
    2874:	8e 81       	ldd	r24, Y+6	; 0x06
    2876:	9f 81       	ldd	r25, Y+7	; 0x07
    2878:	28 17       	cp	r18, r24
    287a:	39 07       	cpc	r19, r25
    287c:	99 f4       	brne	.+38     	; 0x28a4 <uip_process+0x5ea>
       BUF->srcport == uip_connr->rport &&
    287e:	20 91 b7 07 	lds	r18, 0x07B7
    2882:	30 91 b8 07 	lds	r19, 0x07B8
    2886:	88 81       	ld	r24, Y
    2888:	99 81       	ldd	r25, Y+1	; 0x01
    288a:	28 17       	cp	r18, r24
    288c:	39 07       	cpc	r19, r25
    288e:	51 f4       	brne	.+20     	; 0x28a4 <uip_process+0x5ea>
       uip_ipaddr_cmp(&BUF->srcipaddr, &uip_connr->ripaddr)) {
    2890:	20 91 b9 07 	lds	r18, 0x07B9
    2894:	30 91 ba 07 	lds	r19, 0x07BA
    2898:	8a 81       	ldd	r24, Y+2	; 0x02
    289a:	9b 81       	ldd	r25, Y+3	; 0x03
    289c:	28 17       	cp	r18, r24
    289e:	39 07       	cpc	r19, r25
    28a0:	09 f4       	brne	.+2      	; 0x28a4 <uip_process+0x5ea>
    28a2:	76 c1       	rjmp	.+748    	; 0x2b90 <uip_process+0x8d6>
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
      ++uip_connr) {
    28a4:	cf 58       	subi	r28, 0x8F	; 143
    28a6:	df 4f       	sbci	r29, 0xFF	; 255
    goto drop;
  }

  /* Demultiplex this segment. */
  /* First check any active connections. */
  for(uip_connr = &uip_conns[0]; uip_connr <= &uip_conns[UIP_CONNS - 1];
    28a8:	f7 e0       	ldi	r31, 0x07	; 7
    28aa:	c7 38       	cpi	r28, 0x87	; 135
    28ac:	df 07       	cpc	r29, r31
    28ae:	91 f6       	brne	.-92     	; 0x2854 <uip_process+0x59a>

  /* If we didn't find and active connection that expected the packet,
     either this packet is an old duplicate, or this is a SYN packet
     destined for a connection in LISTEN. If the SYN flag isn't set,
     it is an old packet and we send a RST. */
  if((BUF->flags & TCP_CTL) != TCP_SYN) {
    28b0:	80 91 cc 07 	lds	r24, 0x07CC
    28b4:	8f 73       	andi	r24, 0x3F	; 63
    28b6:	82 30       	cpi	r24, 0x02	; 2
    28b8:	d9 f4       	brne	.+54     	; 0x28f0 <uip_process+0x636>
    goto reset;
  }

  tmp16 = BUF->destport;
    28ba:	80 91 c1 07 	lds	r24, 0x07C1
    28be:	90 91 c2 07 	lds	r25, 0x07C2
    28c2:	90 93 69 03 	sts	0x0369, r25
    28c6:	80 93 68 03 	sts	0x0368, r24
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    28ca:	40 e0       	ldi	r20, 0x00	; 0
    28cc:	0d c0       	rjmp	.+26     	; 0x28e8 <uip_process+0x62e>
    if(tmp16 == uip_listenports[c]) {
    28ce:	e4 2f       	mov	r30, r20
    28d0:	f0 e0       	ldi	r31, 0x00	; 0
    28d2:	ee 0f       	add	r30, r30
    28d4:	ff 1f       	adc	r31, r31
    28d6:	e9 57       	subi	r30, 0x79	; 121
    28d8:	f8 4f       	sbci	r31, 0xF8	; 248
    28da:	20 81       	ld	r18, Z
    28dc:	31 81       	ldd	r19, Z+1	; 0x01
    28de:	4f 5f       	subi	r20, 0xFF	; 255
    28e0:	82 17       	cp	r24, r18
    28e2:	93 07       	cpc	r25, r19
    28e4:	09 f4       	brne	.+2      	; 0x28e8 <uip_process+0x62e>
    28e6:	6e c0       	rjmp	.+220    	; 0x29c4 <uip_process+0x70a>
    goto reset;
  }

  tmp16 = BUF->destport;
  /* Next, check listening connections. */
  for(c = 0; c < UIP_LISTENPORTS; ++c) {
    28e8:	45 30       	cpi	r20, 0x05	; 5
    28ea:	88 f3       	brcs	.-30     	; 0x28ce <uip_process+0x614>
    28ec:	40 93 6a 03 	sts	0x036A, r20
  /* No matching connection found, so we send a RST packet. */
  UIP_STAT(++uip_stat.tcp.synrst);

 reset:
  /* We do not send resets in response to resets. */
  if(BUF->flags & TCP_RST) {
    28f0:	80 91 cc 07 	lds	r24, 0x07CC
    28f4:	82 fd       	sbrc	r24, 2
    28f6:	55 c4       	rjmp	.+2218   	; 0x31a2 <uip_process+0xee8>
    goto drop;
  }

  UIP_STAT(++uip_stat.tcp.rst);

  BUF->flags = TCP_RST | TCP_ACK;
    28f8:	84 e1       	ldi	r24, 0x14	; 20
    28fa:	f8 01       	movw	r30, r16
    28fc:	81 a3       	std	Z+33, r24	; 0x21
  uip_len = UIP_IPTCPH_LEN;
    28fe:	88 e2       	ldi	r24, 0x28	; 40
    2900:	90 e0       	ldi	r25, 0x00	; 0
    2902:	90 93 26 06 	sts	0x0626, r25
    2906:	80 93 25 06 	sts	0x0625, r24
  BUF->tcpoffset = 5 << 4;
    290a:	80 e5       	ldi	r24, 0x50	; 80
    290c:	80 a3       	std	Z+32, r24	; 0x20

  /* Flip the seqno and ackno fields in the TCP header. */
  c = BUF->seqno[3];
    290e:	80 91 c6 07 	lds	r24, 0x07C6
  BUF->seqno[3] = BUF->ackno[3];
    2912:	90 91 ca 07 	lds	r25, 0x07CA
    2916:	93 8f       	std	Z+27, r25	; 0x1b
  BUF->ackno[3] = c;

  c = BUF->seqno[2];
    2918:	30 91 c5 07 	lds	r19, 0x07C5
  BUF->seqno[2] = BUF->ackno[2];
    291c:	90 91 c9 07 	lds	r25, 0x07C9
    2920:	92 8f       	std	Z+26, r25	; 0x1a
  BUF->ackno[2] = c;
    2922:	36 8f       	std	Z+30, r19	; 0x1e

  c = BUF->seqno[1];
    2924:	20 91 c4 07 	lds	r18, 0x07C4
  BUF->seqno[1] = BUF->ackno[1];
    2928:	90 91 c8 07 	lds	r25, 0x07C8
    292c:	91 8f       	std	Z+25, r25	; 0x19
  BUF->ackno[1] = c;
    292e:	25 8f       	std	Z+29, r18	; 0x1d

  c = BUF->seqno[0];
    2930:	90 91 c3 07 	lds	r25, 0x07C3
    2934:	90 93 6a 03 	sts	0x036A, r25
  BUF->seqno[0] = BUF->ackno[0];
    2938:	40 91 c7 07 	lds	r20, 0x07C7
    293c:	40 8f       	std	Z+24, r20	; 0x18
  BUF->ackno[0] = c;
    293e:	94 8f       	std	Z+28, r25	; 0x1c

  /* We also have to increase the sequence number we are
     acknowledging. If the least significant byte overflowed, we need
     to propagate the carry to the other bytes as well. */
  if(++BUF->ackno[3] == 0) {
    2940:	8f 5f       	subi	r24, 0xFF	; 255
    2942:	87 8f       	std	Z+31, r24	; 0x1f
    2944:	88 23       	and	r24, r24
    2946:	61 f4       	brne	.+24     	; 0x2960 <uip_process+0x6a6>
    if(++BUF->ackno[2] == 0) {
    2948:	83 2f       	mov	r24, r19
    294a:	8f 5f       	subi	r24, 0xFF	; 255
    294c:	86 8f       	std	Z+30, r24	; 0x1e
    294e:	88 23       	and	r24, r24
    2950:	39 f4       	brne	.+14     	; 0x2960 <uip_process+0x6a6>
      if(++BUF->ackno[1] == 0) {
    2952:	82 2f       	mov	r24, r18
    2954:	8f 5f       	subi	r24, 0xFF	; 255
    2956:	85 8f       	std	Z+29, r24	; 0x1d
    2958:	88 23       	and	r24, r24
    295a:	11 f4       	brne	.+4      	; 0x2960 <uip_process+0x6a6>
	++BUF->ackno[0];
    295c:	9f 5f       	subi	r25, 0xFF	; 255
    295e:	94 8f       	std	Z+28, r25	; 0x1c
      }
    }
  }

  /* Swap port numbers. */
  tmp16 = BUF->srcport;
    2960:	80 91 bf 07 	lds	r24, 0x07BF
    2964:	90 91 c0 07 	lds	r25, 0x07C0
    2968:	90 93 69 03 	sts	0x0369, r25
    296c:	80 93 68 03 	sts	0x0368, r24
  BUF->srcport = BUF->destport;
    2970:	20 91 c1 07 	lds	r18, 0x07C1
    2974:	30 91 c2 07 	lds	r19, 0x07C2
    2978:	f8 01       	movw	r30, r16
    297a:	35 8b       	std	Z+21, r19	; 0x15
    297c:	24 8b       	std	Z+20, r18	; 0x14
  BUF->destport = tmp16;
    297e:	97 8b       	std	Z+23, r25	; 0x17
    2980:	86 8b       	std	Z+22, r24	; 0x16

  /* Swap IP addresses. */
  uip_ipaddr_copy(&BUF->destipaddr, &BUF->srcipaddr);
    2982:	80 91 b7 07 	lds	r24, 0x07B7
    2986:	90 91 b8 07 	lds	r25, 0x07B8
    298a:	a0 91 b9 07 	lds	r26, 0x07B9
    298e:	b0 91 ba 07 	lds	r27, 0x07BA
    2992:	80 93 bb 07 	sts	0x07BB, r24
    2996:	90 93 bc 07 	sts	0x07BC, r25
    299a:	a0 93 bd 07 	sts	0x07BD, r26
    299e:	b0 93 be 07 	sts	0x07BE, r27
  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    29a2:	80 91 99 07 	lds	r24, 0x0799
    29a6:	90 91 9a 07 	lds	r25, 0x079A
    29aa:	a0 91 9b 07 	lds	r26, 0x079B
    29ae:	b0 91 9c 07 	lds	r27, 0x079C
    29b2:	80 93 b7 07 	sts	0x07B7, r24
    29b6:	90 93 b8 07 	sts	0x07B8, r25
    29ba:	a0 93 b9 07 	sts	0x07B9, r26
    29be:	b0 93 ba 07 	sts	0x07BA, r27

  /* And send out the RST packet! */
  goto tcp_send_noconn;
    29c2:	c1 c3       	rjmp	.+1922   	; 0x3146 <uip_process+0xe8c>
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    29c4:	10 92 6a 03 	sts	0x036A, r1
    29c8:	40 e0       	ldi	r20, 0x00	; 0
     connections are kept in the same table as used connections, but
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
    29ca:	c0 e0       	ldi	r28, 0x00	; 0
    29cc:	d0 e0       	ldi	r29, 0x00	; 0
  for(c = 0; c < UIP_CONNS; ++c) {
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    29ce:	81 e7       	ldi	r24, 0x71	; 113
    29d0:	90 e0       	ldi	r25, 0x00	; 0
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    29d2:	26 c0       	rjmp	.+76     	; 0x2a20 <uip_process+0x766>
    if(uip_conns[c].tcpstateflags == UIP_CLOSED) {
    29d4:	24 2f       	mov	r18, r20
    29d6:	30 e0       	ldi	r19, 0x00	; 0
    29d8:	28 9f       	mul	r18, r24
    29da:	f0 01       	movw	r30, r0
    29dc:	29 9f       	mul	r18, r25
    29de:	f0 0d       	add	r31, r0
    29e0:	38 9f       	mul	r19, r24
    29e2:	f0 0d       	add	r31, r0
    29e4:	11 24       	eor	r1, r1
    29e6:	ec 5c       	subi	r30, 0xCC	; 204
    29e8:	f9 4f       	sbci	r31, 0xF9	; 249
    29ea:	21 8d       	ldd	r18, Z+25	; 0x19
    29ec:	22 23       	and	r18, r18
    29ee:	21 f4       	brne	.+8      	; 0x29f8 <uip_process+0x73e>
    29f0:	40 93 6a 03 	sts	0x036A, r20
      uip_connr = &uip_conns[c];
    29f4:	ef 01       	movw	r28, r30
      break;
    29f6:	18 c0       	rjmp	.+48     	; 0x2a28 <uip_process+0x76e>
    }
    if(uip_conns[c].tcpstateflags == UIP_TIME_WAIT) {
    29f8:	27 30       	cpi	r18, 0x07	; 7
    29fa:	89 f4       	brne	.+34     	; 0x2a1e <uip_process+0x764>
      if(uip_connr == 0 ||
    29fc:	20 97       	sbiw	r28, 0x00	; 0
    29fe:	21 f0       	breq	.+8      	; 0x2a08 <uip_process+0x74e>
    2a00:	32 8d       	ldd	r19, Z+26	; 0x1a
    2a02:	2a 8d       	ldd	r18, Y+26	; 0x1a
    2a04:	23 17       	cp	r18, r19
    2a06:	58 f4       	brcc	.+22     	; 0x2a1e <uip_process+0x764>
	 uip_conns[c].timer > uip_connr->timer) {
	uip_connr = &uip_conns[c];
    2a08:	24 2f       	mov	r18, r20
    2a0a:	30 e0       	ldi	r19, 0x00	; 0
    2a0c:	28 9f       	mul	r18, r24
    2a0e:	e0 01       	movw	r28, r0
    2a10:	29 9f       	mul	r18, r25
    2a12:	d0 0d       	add	r29, r0
    2a14:	38 9f       	mul	r19, r24
    2a16:	d0 0d       	add	r29, r0
    2a18:	11 24       	eor	r1, r1
    2a1a:	cc 5c       	subi	r28, 0xCC	; 204
    2a1c:	d9 4f       	sbci	r29, 0xF9	; 249
    2a1e:	4f 5f       	subi	r20, 0xFF	; 255
     unused ones have the tcpstate set to CLOSED. Also, connections in
     TIME_WAIT are kept track of and we'll use the oldest one if no
     CLOSED connections are found. Thanks to Eddie C. Dost for a very
     nice algorithm for the TIME_WAIT search. */
  uip_connr = 0;
  for(c = 0; c < UIP_CONNS; ++c) {
    2a20:	43 30       	cpi	r20, 0x03	; 3
    2a22:	c0 f2       	brcs	.-80     	; 0x29d4 <uip_process+0x71a>
    2a24:	40 93 6a 03 	sts	0x036A, r20
	uip_connr = &uip_conns[c];
      }
    }
  }

  if(uip_connr == 0) {
    2a28:	20 97       	sbiw	r28, 0x00	; 0
    2a2a:	09 f4       	brne	.+2      	; 0x2a2e <uip_process+0x774>
    2a2c:	ba c3       	rjmp	.+1908   	; 0x31a2 <uip_process+0xee8>
       have more spare connections. */
    UIP_STAT(++uip_stat.tcp.syndrop);
    UIP_LOG("tcp: found no unused connections.");
    goto drop;
  }
  uip_conn = uip_connr;
    2a2e:	d0 93 33 06 	sts	0x0633, r29
    2a32:	c0 93 32 06 	sts	0x0632, r28

  /* Fill in the necessary fields for the new connection. */
  uip_connr->rto = uip_connr->timer = UIP_RTO;
    2a36:	83 e0       	ldi	r24, 0x03	; 3
    2a38:	8a 8f       	std	Y+26, r24	; 0x1a
    2a3a:	88 8f       	std	Y+24, r24	; 0x18
  uip_connr->sa = 0;
    2a3c:	1e 8a       	std	Y+22, r1	; 0x16
  uip_connr->sv = 4;
    2a3e:	84 e0       	ldi	r24, 0x04	; 4
    2a40:	8f 8b       	std	Y+23, r24	; 0x17
  uip_connr->nrtx = 0;
    2a42:	1b 8e       	std	Y+27, r1	; 0x1b
  uip_connr->lport = BUF->destport;
    2a44:	80 91 c1 07 	lds	r24, 0x07C1
    2a48:	90 91 c2 07 	lds	r25, 0x07C2
    2a4c:	9d 83       	std	Y+5, r25	; 0x05
    2a4e:	8c 83       	std	Y+4, r24	; 0x04
  uip_connr->rport = BUF->srcport;
    2a50:	80 91 bf 07 	lds	r24, 0x07BF
    2a54:	90 91 c0 07 	lds	r25, 0x07C0
    2a58:	9f 83       	std	Y+7, r25	; 0x07
    2a5a:	8e 83       	std	Y+6, r24	; 0x06
  uip_ipaddr_copy(&uip_connr->ripaddr, &BUF->srcipaddr);
    2a5c:	80 91 b7 07 	lds	r24, 0x07B7
    2a60:	90 91 b8 07 	lds	r25, 0x07B8
    2a64:	a0 91 b9 07 	lds	r26, 0x07B9
    2a68:	b0 91 ba 07 	lds	r27, 0x07BA
    2a6c:	88 83       	st	Y, r24
    2a6e:	99 83       	std	Y+1, r25	; 0x01
    2a70:	aa 83       	std	Y+2, r26	; 0x02
    2a72:	bb 83       	std	Y+3, r27	; 0x03
  uip_connr->tcpstateflags = UIP_SYN_RCVD;
    2a74:	81 e0       	ldi	r24, 0x01	; 1
    2a76:	89 8f       	std	Y+25, r24	; 0x19

  uip_connr->snd_nxt[0] = iss[0];
    2a78:	80 91 64 03 	lds	r24, 0x0364
    2a7c:	8c 87       	std	Y+12, r24	; 0x0c
  uip_connr->snd_nxt[1] = iss[1];
    2a7e:	80 91 65 03 	lds	r24, 0x0365
    2a82:	8d 87       	std	Y+13, r24	; 0x0d
  uip_connr->snd_nxt[2] = iss[2];
    2a84:	80 91 66 03 	lds	r24, 0x0366
    2a88:	8e 87       	std	Y+14, r24	; 0x0e
  uip_connr->snd_nxt[3] = iss[3];
    2a8a:	80 91 67 03 	lds	r24, 0x0367
    2a8e:	8f 87       	std	Y+15, r24	; 0x0f
  uip_connr->len = 1;
    2a90:	81 e0       	ldi	r24, 0x01	; 1
    2a92:	90 e0       	ldi	r25, 0x00	; 0
    2a94:	99 8b       	std	Y+17, r25	; 0x11
    2a96:	88 8b       	std	Y+16, r24	; 0x10

  /* rcv_nxt should be the seqno from the incoming packet + 1. */
  uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2a98:	80 91 c6 07 	lds	r24, 0x07C6
    2a9c:	8b 87       	std	Y+11, r24	; 0x0b
  uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2a9e:	80 91 c5 07 	lds	r24, 0x07C5
    2aa2:	8a 87       	std	Y+10, r24	; 0x0a
  uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2aa4:	80 91 c4 07 	lds	r24, 0x07C4
    2aa8:	89 87       	std	Y+9, r24	; 0x09
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2aaa:	80 91 c3 07 	lds	r24, 0x07C3
    2aae:	88 87       	std	Y+8, r24	; 0x08
  uip_add_rcv_nxt(1);
    2ab0:	81 e0       	ldi	r24, 0x01	; 1
    2ab2:	90 e0       	ldi	r25, 0x00	; 0
    2ab4:	03 db       	rcall	.-2554   	; 0x20bc <uip_add_rcv_nxt>

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    2ab6:	80 91 cb 07 	lds	r24, 0x07CB
    2aba:	28 2f       	mov	r18, r24
    2abc:	30 e0       	ldi	r19, 0x00	; 0
    2abe:	20 7f       	andi	r18, 0xF0	; 240
    2ac0:	30 70       	andi	r19, 0x00	; 0
    2ac2:	21 35       	cpi	r18, 0x51	; 81
    2ac4:	31 05       	cpc	r19, r1
    2ac6:	0c f4       	brge	.+2      	; 0x2aca <uip_process+0x810>
    2ac8:	49 c0       	rjmp	.+146    	; 0x2b5c <uip_process+0x8a2>
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2aca:	82 95       	swap	r24
    2acc:	8f 70       	andi	r24, 0x0F	; 15
    2ace:	90 e0       	ldi	r25, 0x00	; 0
    2ad0:	05 97       	sbiw	r24, 0x05	; 5
    2ad2:	88 0f       	add	r24, r24
    2ad4:	99 1f       	adc	r25, r25
    2ad6:	88 0f       	add	r24, r24
    2ad8:	99 1f       	adc	r25, r25
    2ada:	50 91 6b 03 	lds	r21, 0x036B
    2ade:	40 e0       	ldi	r20, 0x00	; 0
    2ae0:	34 c0       	rjmp	.+104    	; 0x2b4a <uip_process+0x890>
      opt = uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + c];
    2ae2:	f9 01       	movw	r30, r18
    2ae4:	e3 56       	subi	r30, 0x63	; 99
    2ae6:	f8 4f       	sbci	r31, 0xF8	; 248
    2ae8:	56 a9       	ldd	r21, Z+54	; 0x36
      if(opt == TCP_OPT_END) {
    2aea:	55 23       	and	r21, r21
    2aec:	29 f4       	brne	.+10     	; 0x2af8 <uip_process+0x83e>
    2aee:	40 93 6a 03 	sts	0x036A, r20
    2af2:	10 92 6b 03 	sts	0x036B, r1
    2af6:	32 c0       	rjmp	.+100    	; 0x2b5c <uip_process+0x8a2>
	/* End of options. */
	break;
      } else if(opt == TCP_OPT_NOOP) {
    2af8:	51 30       	cpi	r21, 0x01	; 1
    2afa:	11 f4       	brne	.+4      	; 0x2b00 <uip_process+0x846>
	++c;
    2afc:	4f 5f       	subi	r20, 0xFF	; 255
    2afe:	25 c0       	rjmp	.+74     	; 0x2b4a <uip_process+0x890>
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
    2b00:	52 30       	cpi	r21, 0x02	; 2
    2b02:	e1 f4       	brne	.+56     	; 0x2b3c <uip_process+0x882>
    2b04:	67 a9       	ldd	r22, Z+55	; 0x37
    2b06:	64 30       	cpi	r22, 0x04	; 4
    2b08:	c9 f4       	brne	.+50     	; 0x2b3c <uip_process+0x882>
    2b0a:	40 93 6a 03 	sts	0x036A, r20
    2b0e:	50 93 6b 03 	sts	0x036B, r21
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2b12:	30 ad       	ldd	r19, Z+56	; 0x38
    2b14:	20 e0       	ldi	r18, 0x00	; 0
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
    2b16:	81 ad       	ldd	r24, Z+57	; 0x39
    2b18:	90 e0       	ldi	r25, 0x00	; 0
	++c;
	/* NOP option. */
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2b1a:	82 2b       	or	r24, r18
    2b1c:	93 2b       	or	r25, r19
    2b1e:	90 93 69 03 	sts	0x0369, r25
    2b22:	80 93 68 03 	sts	0x0368, r24
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2b26:	f5 e0       	ldi	r31, 0x05	; 5
    2b28:	85 3b       	cpi	r24, 0xB5	; 181
    2b2a:	9f 07       	cpc	r25, r31
    2b2c:	10 f0       	brcs	.+4      	; 0x2b32 <uip_process+0x878>
    2b2e:	84 eb       	ldi	r24, 0xB4	; 180
    2b30:	95 e0       	ldi	r25, 0x05	; 5
      } else if(opt == TCP_OPT_MSS &&
		uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	/* An MSS option with the right option length. */
	tmp16 = ((u16_t)uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	  (u16_t)uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + 3 + c];
	uip_connr->initialmss = uip_connr->mss =
    2b32:	9b 8b       	std	Y+19, r25	; 0x13
    2b34:	8a 8b       	std	Y+18, r24	; 0x12
    2b36:	9d 8b       	std	Y+21, r25	; 0x15
    2b38:	8c 8b       	std	Y+20, r24	; 0x14
	  tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	/* And we are done processing options. */
	break;
    2b3a:	10 c0       	rjmp	.+32     	; 0x2b5c <uip_process+0x8a2>
      } else {
	/* All other options have a length field, so that we easily
	   can skip past them. */
	if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2b3c:	23 56       	subi	r18, 0x63	; 99
    2b3e:	38 4f       	sbci	r19, 0xF8	; 248
    2b40:	f9 01       	movw	r30, r18
    2b42:	27 a9       	ldd	r18, Z+55	; 0x37
    2b44:	22 23       	and	r18, r18
    2b46:	31 f0       	breq	.+12     	; 0x2b54 <uip_process+0x89a>
	  /* If the length field is zero, the options are malformed
	     and we don't process them further. */
	  break;
	}
	c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2b48:	42 0f       	add	r20, r18
  uip_connr->rcv_nxt[0] = BUF->seqno[0];
  uip_add_rcv_nxt(1);

  /* Parse the TCP MSS option, if present. */
  if((BUF->tcpoffset & 0xf0) > 0x50) {
    for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2b4a:	24 2f       	mov	r18, r20
    2b4c:	30 e0       	ldi	r19, 0x00	; 0
    2b4e:	28 17       	cp	r18, r24
    2b50:	39 07       	cpc	r19, r25
    2b52:	3c f2       	brlt	.-114    	; 0x2ae2 <uip_process+0x828>
    2b54:	40 93 6a 03 	sts	0x036A, r20
    2b58:	50 93 6b 03 	sts	0x036B, r21
  }

  /* Our response will be a SYNACK. */
#if UIP_ACTIVE_OPEN
 tcp_send_synack:
  BUF->flags = TCP_ACK;
    2b5c:	80 e1       	ldi	r24, 0x10	; 16
    2b5e:	80 93 cc 07 	sts	0x07CC, r24

 tcp_send_syn:
  BUF->flags |= TCP_SYN;
    2b62:	eb ea       	ldi	r30, 0xAB	; 171
    2b64:	f7 e0       	ldi	r31, 0x07	; 7
    2b66:	80 91 cc 07 	lds	r24, 0x07CC
    2b6a:	82 60       	ori	r24, 0x02	; 2
    2b6c:	81 a3       	std	Z+33, r24	; 0x21
  BUF->flags = TCP_SYN | TCP_ACK;
#endif /* UIP_ACTIVE_OPEN */

  /* We send out the TCP Maximum Segment Size option with our
     SYNACK. */
  BUF->optdata[0] = TCP_OPT_MSS;
    2b6e:	82 e0       	ldi	r24, 0x02	; 2
    2b70:	80 a7       	std	Z+40, r24	; 0x28
  BUF->optdata[1] = TCP_OPT_MSS_LEN;
    2b72:	84 e0       	ldi	r24, 0x04	; 4
    2b74:	81 a7       	std	Z+41, r24	; 0x29
  BUF->optdata[2] = (UIP_TCP_MSS) / 256;
    2b76:	85 e0       	ldi	r24, 0x05	; 5
    2b78:	82 a7       	std	Z+42, r24	; 0x2a
  BUF->optdata[3] = (UIP_TCP_MSS) & 255;
    2b7a:	84 eb       	ldi	r24, 0xB4	; 180
    2b7c:	83 a7       	std	Z+43, r24	; 0x2b
  uip_len = UIP_IPTCPH_LEN + TCP_OPT_MSS_LEN;
    2b7e:	8c e2       	ldi	r24, 0x2C	; 44
    2b80:	90 e0       	ldi	r25, 0x00	; 0
    2b82:	90 93 26 06 	sts	0x0626, r25
    2b86:	80 93 25 06 	sts	0x0625, r24
  BUF->tcpoffset = ((UIP_TCPH_LEN + TCP_OPT_MSS_LEN) / 4) << 4;
    2b8a:	80 e6       	ldi	r24, 0x60	; 96
    2b8c:	80 a3       	std	Z+32, r24	; 0x20
  goto tcp_send;
    2b8e:	99 c2       	rjmp	.+1330   	; 0x30c2 <uip_process+0xe08>

  /* This label will be jumped to if we found an active connection. */
 found:
  uip_conn = uip_connr;
    2b90:	d0 93 33 06 	sts	0x0633, r29
    2b94:	c0 93 32 06 	sts	0x0632, r28
  uip_flags = 0;
    2b98:	10 92 2d 06 	sts	0x062D, r1
  /* We do a very naive form of TCP reset processing; we just accept
     any RST and kill our connection. We should in fact check if the
     sequence number of this reset is within our advertised window
     before we accept the reset. */
  if(BUF->flags & TCP_RST) {
    2b9c:	80 91 cc 07 	lds	r24, 0x07CC
    2ba0:	90 e0       	ldi	r25, 0x00	; 0
    2ba2:	82 ff       	sbrs	r24, 2
    2ba4:	03 c0       	rjmp	.+6      	; 0x2bac <uip_process+0x8f2>
    uip_connr->tcpstateflags = UIP_CLOSED;
    2ba6:	19 8e       	std	Y+25, r1	; 0x19
    UIP_LOG("tcp: got reset, aborting connection.");
    uip_flags = UIP_ABORT;
    2ba8:	80 e2       	ldi	r24, 0x20	; 32
    2baa:	35 c2       	rjmp	.+1130   	; 0x3016 <uip_process+0xd5c>
    UIP_APPCALL();
    goto drop;
  }
  /* Calculate the length of the data, if the application has sent
     any data to us. */
  c = (BUF->tcpoffset >> 4) << 2;
    2bac:	20 91 cb 07 	lds	r18, 0x07CB
    2bb0:	22 95       	swap	r18
    2bb2:	2f 70       	andi	r18, 0x0F	; 15
    2bb4:	22 0f       	add	r18, r18
    2bb6:	22 0f       	add	r18, r18
    2bb8:	20 93 6a 03 	sts	0x036A, r18
  /* uip_len will contain the length of the actual TCP data. This is
     calculated by subtracing the length of the TCP header (in
     c) and the length of the IP header (20 bytes). */
  uip_len = uip_len - c - UIP_IPH_LEN;
    2bbc:	b7 01       	movw	r22, r14
    2bbe:	62 1b       	sub	r22, r18
    2bc0:	71 09       	sbc	r23, r1
    2bc2:	9b 01       	movw	r18, r22
    2bc4:	24 51       	subi	r18, 0x14	; 20
    2bc6:	30 40       	sbci	r19, 0x00	; 0
    2bc8:	30 93 26 06 	sts	0x0626, r19
    2bcc:	20 93 25 06 	sts	0x0625, r18

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2bd0:	4f 70       	andi	r20, 0x0F	; 15
    2bd2:	42 30       	cpi	r20, 0x02	; 2
    2bd4:	31 f4       	brne	.+12     	; 0x2be2 <uip_process+0x928>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    2bd6:	ac 01       	movw	r20, r24
    2bd8:	4f 73       	andi	r20, 0x3F	; 63
    2bda:	50 70       	andi	r21, 0x00	; 0
  uip_len = uip_len - c - UIP_IPH_LEN;

  /* First, check if the sequence number of the incoming packet is
     what we're expecting next. If not, we send out an ACK with the
     correct numbers in. */
  if(!(((uip_connr->tcpstateflags & UIP_TS_MASK) == UIP_SYN_SENT) &&
    2bdc:	42 31       	cpi	r20, 0x12	; 18
    2bde:	51 05       	cpc	r21, r1
    2be0:	09 f1       	breq	.+66     	; 0x2c24 <uip_process+0x96a>
       ((BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)))) {
    if((uip_len > 0 || ((BUF->flags & (TCP_SYN | TCP_FIN)) != 0)) &&
    2be2:	21 15       	cp	r18, r1
    2be4:	31 05       	cpc	r19, r1
    2be6:	31 f4       	brne	.+12     	; 0x2bf4 <uip_process+0x93a>
    2be8:	9c 01       	movw	r18, r24
    2bea:	23 70       	andi	r18, 0x03	; 3
    2bec:	30 70       	andi	r19, 0x00	; 0
    2bee:	21 15       	cp	r18, r1
    2bf0:	31 05       	cpc	r19, r1
    2bf2:	c1 f0       	breq	.+48     	; 0x2c24 <uip_process+0x96a>
    2bf4:	30 91 c3 07 	lds	r19, 0x07C3
    2bf8:	28 85       	ldd	r18, Y+8	; 0x08
    2bfa:	32 17       	cp	r19, r18
    2bfc:	09 f0       	breq	.+2      	; 0x2c00 <uip_process+0x946>
    2bfe:	55 c2       	rjmp	.+1194   	; 0x30aa <uip_process+0xdf0>
       (BUF->seqno[0] != uip_connr->rcv_nxt[0] ||
    2c00:	30 91 c4 07 	lds	r19, 0x07C4
    2c04:	29 85       	ldd	r18, Y+9	; 0x09
    2c06:	32 17       	cp	r19, r18
    2c08:	09 f0       	breq	.+2      	; 0x2c0c <uip_process+0x952>
    2c0a:	4f c2       	rjmp	.+1182   	; 0x30aa <uip_process+0xdf0>
	BUF->seqno[1] != uip_connr->rcv_nxt[1] ||
    2c0c:	30 91 c5 07 	lds	r19, 0x07C5
    2c10:	2a 85       	ldd	r18, Y+10	; 0x0a
    2c12:	32 17       	cp	r19, r18
    2c14:	09 f0       	breq	.+2      	; 0x2c18 <uip_process+0x95e>
    2c16:	49 c2       	rjmp	.+1170   	; 0x30aa <uip_process+0xdf0>
	BUF->seqno[2] != uip_connr->rcv_nxt[2] ||
    2c18:	30 91 c6 07 	lds	r19, 0x07C6
    2c1c:	2b 85       	ldd	r18, Y+11	; 0x0b
    2c1e:	32 17       	cp	r19, r18
    2c20:	09 f0       	breq	.+2      	; 0x2c24 <uip_process+0x96a>
    2c22:	43 c2       	rjmp	.+1158   	; 0x30aa <uip_process+0xdf0>

  /* Next, check if the incoming segment acknowledges any outstanding
     data. If so, we update the sequence number, reset the length of
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    2c24:	84 ff       	sbrs	r24, 4
    2c26:	49 c0       	rjmp	.+146    	; 0x2cba <uip_process+0xa00>
    2c28:	68 89       	ldd	r22, Y+16	; 0x10
    2c2a:	79 89       	ldd	r23, Y+17	; 0x11
    2c2c:	61 15       	cp	r22, r1
    2c2e:	71 05       	cpc	r23, r1
    2c30:	09 f4       	brne	.+2      	; 0x2c34 <uip_process+0x97a>
    2c32:	43 c0       	rjmp	.+134    	; 0x2cba <uip_process+0xa00>
    uip_add32(uip_connr->snd_nxt, uip_connr->len);
    2c34:	ce 01       	movw	r24, r28
    2c36:	0c 96       	adiw	r24, 0x0c	; 12
    2c38:	09 da       	rcall	.-3054   	; 0x204c <uip_add32>

    if(BUF->ackno[0] == uip_acc32[0] &&
    2c3a:	30 91 c7 07 	lds	r19, 0x07C7
    2c3e:	80 91 29 06 	lds	r24, 0x0629
    2c42:	38 17       	cp	r19, r24
    2c44:	d1 f5       	brne	.+116    	; 0x2cba <uip_process+0xa00>
       BUF->ackno[1] == uip_acc32[1] &&
    2c46:	20 91 c8 07 	lds	r18, 0x07C8
     the outstanding data, calculate RTT estimations, and reset the
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
    2c4a:	80 91 2a 06 	lds	r24, 0x062A
    2c4e:	28 17       	cp	r18, r24
    2c50:	a1 f5       	brne	.+104    	; 0x2cba <uip_process+0xa00>
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2c52:	90 91 c9 07 	lds	r25, 0x07C9
     retransmission timer. */
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
    2c56:	80 91 2b 06 	lds	r24, 0x062B
    2c5a:	98 17       	cp	r25, r24
    2c5c:	71 f5       	brne	.+92     	; 0x2cba <uip_process+0xa00>
       BUF->ackno[2] == uip_acc32[2] &&
       BUF->ackno[3] == uip_acc32[3]) {
    2c5e:	80 91 ca 07 	lds	r24, 0x07CA
  if((BUF->flags & TCP_ACK) && uip_outstanding(uip_connr)) {
    uip_add32(uip_connr->snd_nxt, uip_connr->len);

    if(BUF->ackno[0] == uip_acc32[0] &&
       BUF->ackno[1] == uip_acc32[1] &&
       BUF->ackno[2] == uip_acc32[2] &&
    2c62:	40 91 2c 06 	lds	r20, 0x062C
    2c66:	84 17       	cp	r24, r20
    2c68:	41 f5       	brne	.+80     	; 0x2cba <uip_process+0xa00>
       BUF->ackno[3] == uip_acc32[3]) {
      /* Update sequence number. */
      uip_connr->snd_nxt[0] = uip_acc32[0];
    2c6a:	3c 87       	std	Y+12, r19	; 0x0c
      uip_connr->snd_nxt[1] = uip_acc32[1];
    2c6c:	2d 87       	std	Y+13, r18	; 0x0d
      uip_connr->snd_nxt[2] = uip_acc32[2];
    2c6e:	9e 87       	std	Y+14, r25	; 0x0e
      uip_connr->snd_nxt[3] = uip_acc32[3];
    2c70:	8f 87       	std	Y+15, r24	; 0x0f

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
    2c72:	8b 8d       	ldd	r24, Y+27	; 0x1b
    2c74:	88 23       	and	r24, r24
    2c76:	d1 f4       	brne	.+52     	; 0x2cac <uip_process+0x9f2>
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2c78:	2e 89       	ldd	r18, Y+22	; 0x16
      uip_connr->snd_nxt[3] = uip_acc32[3];

      /* Do RTT estimation, unless we have done retransmissions. */
      if(uip_connr->nrtx == 0) {
	signed char m;
	m = uip_connr->rto - uip_connr->timer;
    2c7a:	88 8d       	ldd	r24, Y+24	; 0x18
    2c7c:	9a 8d       	ldd	r25, Y+26	; 0x1a
    2c7e:	89 1b       	sub	r24, r25
	/* This is taken directly from VJs original code in his paper */
	m = m - (uip_connr->sa >> 3);
    2c80:	92 2f       	mov	r25, r18
    2c82:	96 95       	lsr	r25
    2c84:	96 95       	lsr	r25
    2c86:	96 95       	lsr	r25
    2c88:	89 1b       	sub	r24, r25
	uip_connr->sa += m;
    2c8a:	28 0f       	add	r18, r24
    2c8c:	2e 8b       	std	Y+22, r18	; 0x16
	if(m < 0) {
	  m = -m;
    2c8e:	87 fd       	sbrc	r24, 7
    2c90:	81 95       	neg	r24
	}
	m = m - (uip_connr->sv >> 2);
    2c92:	9f 89       	ldd	r25, Y+23	; 0x17
    2c94:	39 2f       	mov	r19, r25
    2c96:	36 95       	lsr	r19
    2c98:	36 95       	lsr	r19
    2c9a:	93 1b       	sub	r25, r19
	uip_connr->sv += m;
    2c9c:	98 0f       	add	r25, r24
    2c9e:	9f 8b       	std	Y+23, r25	; 0x17
	uip_connr->rto = (uip_connr->sa >> 3) + uip_connr->sv;
    2ca0:	82 2f       	mov	r24, r18
    2ca2:	86 95       	lsr	r24
    2ca4:	86 95       	lsr	r24
    2ca6:	86 95       	lsr	r24
    2ca8:	89 0f       	add	r24, r25
    2caa:	88 8f       	std	Y+24, r24	; 0x18

      }
      /* Set the acknowledged flag. */
      uip_flags = UIP_ACKDATA;
    2cac:	81 e0       	ldi	r24, 0x01	; 1
    2cae:	80 93 2d 06 	sts	0x062D, r24
      /* Reset the retransmission timer. */
      uip_connr->timer = uip_connr->rto;
    2cb2:	88 8d       	ldd	r24, Y+24	; 0x18
    2cb4:	8a 8f       	std	Y+26, r24	; 0x1a

      /* Reset length of outstanding data. */
      uip_connr->len = 0;
    2cb6:	19 8a       	std	Y+17, r1	; 0x11
    2cb8:	18 8a       	std	Y+16, r1	; 0x10
    }

  }

  /* Do different things depending on in what state the connection is. */
  switch(uip_connr->tcpstateflags & UIP_TS_MASK) {
    2cba:	29 8d       	ldd	r18, Y+25	; 0x19
    2cbc:	30 e0       	ldi	r19, 0x00	; 0
    2cbe:	c9 01       	movw	r24, r18
    2cc0:	8f 70       	andi	r24, 0x0F	; 15
    2cc2:	90 70       	andi	r25, 0x00	; 0
    2cc4:	84 30       	cpi	r24, 0x04	; 4
    2cc6:	91 05       	cpc	r25, r1
    2cc8:	09 f4       	brne	.+2      	; 0x2ccc <uip_process+0xa12>
    2cca:	aa c1       	rjmp	.+852    	; 0x3020 <uip_process+0xd66>
    2ccc:	85 30       	cpi	r24, 0x05	; 5
    2cce:	91 05       	cpc	r25, r1
    2cd0:	64 f4       	brge	.+24     	; 0x2cea <uip_process+0xa30>
    2cd2:	82 30       	cpi	r24, 0x02	; 2
    2cd4:	91 05       	cpc	r25, r1
    2cd6:	89 f1       	breq	.+98     	; 0x2d3a <uip_process+0xa80>
    2cd8:	83 30       	cpi	r24, 0x03	; 3
    2cda:	91 05       	cpc	r25, r1
    2cdc:	0c f0       	brlt	.+2      	; 0x2ce0 <uip_process+0xa26>
    2cde:	b0 c0       	rjmp	.+352    	; 0x2e40 <uip_process+0xb86>
    2ce0:	81 30       	cpi	r24, 0x01	; 1
    2ce2:	91 05       	cpc	r25, r1
    2ce4:	09 f0       	breq	.+2      	; 0x2ce8 <uip_process+0xa2e>
    2ce6:	5d c2       	rjmp	.+1210   	; 0x31a2 <uip_process+0xee8>
    2ce8:	11 c0       	rjmp	.+34     	; 0x2d0c <uip_process+0xa52>
    2cea:	86 30       	cpi	r24, 0x06	; 6
    2cec:	91 05       	cpc	r25, r1
    2cee:	09 f4       	brne	.+2      	; 0x2cf2 <uip_process+0xa38>
    2cf0:	d4 c1       	rjmp	.+936    	; 0x309a <uip_process+0xde0>
    2cf2:	86 30       	cpi	r24, 0x06	; 6
    2cf4:	91 05       	cpc	r25, r1
    2cf6:	0c f4       	brge	.+2      	; 0x2cfa <uip_process+0xa40>
    2cf8:	b2 c1       	rjmp	.+868    	; 0x305e <uip_process+0xda4>
    2cfa:	87 30       	cpi	r24, 0x07	; 7
    2cfc:	91 05       	cpc	r25, r1
    2cfe:	09 f4       	brne	.+2      	; 0x2d02 <uip_process+0xa48>
    2d00:	d4 c1       	rjmp	.+936    	; 0x30aa <uip_process+0xdf0>
    2d02:	88 30       	cpi	r24, 0x08	; 8
    2d04:	91 05       	cpc	r25, r1
    2d06:	09 f0       	breq	.+2      	; 0x2d0a <uip_process+0xa50>
    2d08:	4c c2       	rjmp	.+1176   	; 0x31a2 <uip_process+0xee8>
    2d0a:	7f c1       	rjmp	.+766    	; 0x300a <uip_process+0xd50>
  case UIP_SYN_RCVD:
    /* In SYN_RCVD we have sent out a SYNACK in response to a SYN, and
       we are waiting for an ACK that acknowledges the data we sent
       out the last time. Therefore, we want to have the UIP_ACKDATA
       flag set. If so, we enter the ESTABLISHED state. */
    if(uip_flags & UIP_ACKDATA) {
    2d0c:	80 91 2d 06 	lds	r24, 0x062D
    2d10:	80 ff       	sbrs	r24, 0
    2d12:	47 c2       	rjmp	.+1166   	; 0x31a2 <uip_process+0xee8>
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2d14:	83 e0       	ldi	r24, 0x03	; 3
    2d16:	89 8f       	std	Y+25, r24	; 0x19
      uip_flags = UIP_CONNECTED;
    2d18:	80 e4       	ldi	r24, 0x40	; 64
    2d1a:	80 93 2d 06 	sts	0x062D, r24
      uip_connr->len = 0;
    2d1e:	19 8a       	std	Y+17, r1	; 0x11
    2d20:	18 8a       	std	Y+16, r1	; 0x10
      if(uip_len > 0) {
    2d22:	80 91 25 06 	lds	r24, 0x0625
    2d26:	90 91 26 06 	lds	r25, 0x0626
    2d2a:	00 97       	sbiw	r24, 0x00	; 0
    2d2c:	09 f4       	brne	.+2      	; 0x2d30 <uip_process+0xa76>
    2d2e:	05 c1       	rjmp	.+522    	; 0x2f3a <uip_process+0xc80>
        uip_flags |= UIP_NEWDATA;
    2d30:	22 e4       	ldi	r18, 0x42	; 66
    2d32:	20 93 2d 06 	sts	0x062D, r18
        uip_add_rcv_nxt(uip_len);
    2d36:	c2 d9       	rcall	.-3196   	; 0x20bc <uip_add_rcv_nxt>
    2d38:	00 c1       	rjmp	.+512    	; 0x2f3a <uip_process+0xc80>
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2d3a:	80 91 2d 06 	lds	r24, 0x062D
    2d3e:	80 ff       	sbrs	r24, 0
    2d40:	74 c0       	rjmp	.+232    	; 0x2e2a <uip_process+0xb70>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {
    2d42:	80 91 cc 07 	lds	r24, 0x07CC
    2d46:	8f 73       	andi	r24, 0x3F	; 63
  case UIP_SYN_SENT:
    /* In SYN_SENT, we wait for a SYNACK that is sent in response to
       our SYN. The rcv_nxt is set to sequence number in the SYNACK
       plus one, and we send an ACK. We move into the ESTABLISHED
       state. */
    if((uip_flags & UIP_ACKDATA) &&
    2d48:	82 31       	cpi	r24, 0x12	; 18
    2d4a:	09 f0       	breq	.+2      	; 0x2d4e <uip_process+0xa94>
    2d4c:	6e c0       	rjmp	.+220    	; 0x2e2a <uip_process+0xb70>
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
    2d4e:	80 91 cb 07 	lds	r24, 0x07CB
    2d52:	28 2f       	mov	r18, r24
    2d54:	30 e0       	ldi	r19, 0x00	; 0
    2d56:	20 7f       	andi	r18, 0xF0	; 240
    2d58:	30 70       	andi	r19, 0x00	; 0
    2d5a:	21 35       	cpi	r18, 0x51	; 81
    2d5c:	31 05       	cpc	r19, r1
    2d5e:	0c f4       	brge	.+2      	; 0x2d62 <uip_process+0xaa8>
    2d60:	49 c0       	rjmp	.+146    	; 0x2df4 <uip_process+0xb3a>
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2d62:	82 95       	swap	r24
    2d64:	8f 70       	andi	r24, 0x0F	; 15
    2d66:	90 e0       	ldi	r25, 0x00	; 0
    2d68:	05 97       	sbiw	r24, 0x05	; 5
    2d6a:	88 0f       	add	r24, r24
    2d6c:	99 1f       	adc	r25, r25
    2d6e:	88 0f       	add	r24, r24
    2d70:	99 1f       	adc	r25, r25
    2d72:	50 91 6b 03 	lds	r21, 0x036B
    2d76:	40 e0       	ldi	r20, 0x00	; 0
    2d78:	34 c0       	rjmp	.+104    	; 0x2de2 <uip_process+0xb28>
	  opt = uip_buf[UIP_IPTCPH_LEN + UIP_LLH_LEN + c];
    2d7a:	f9 01       	movw	r30, r18
    2d7c:	e3 56       	subi	r30, 0x63	; 99
    2d7e:	f8 4f       	sbci	r31, 0xF8	; 248
    2d80:	56 a9       	ldd	r21, Z+54	; 0x36
	  if(opt == TCP_OPT_END) {
    2d82:	55 23       	and	r21, r21
    2d84:	29 f4       	brne	.+10     	; 0x2d90 <uip_process+0xad6>
    2d86:	40 93 6a 03 	sts	0x036A, r20
    2d8a:	10 92 6b 03 	sts	0x036B, r1
    2d8e:	32 c0       	rjmp	.+100    	; 0x2df4 <uip_process+0xb3a>
	    /* End of options. */
	    break;
	  } else if(opt == TCP_OPT_NOOP) {
    2d90:	51 30       	cpi	r21, 0x01	; 1
    2d92:	11 f4       	brne	.+4      	; 0x2d98 <uip_process+0xade>
	    ++c;
    2d94:	4f 5f       	subi	r20, 0xFF	; 255
    2d96:	25 c0       	rjmp	.+74     	; 0x2de2 <uip_process+0xb28>
	    /* NOP option. */
	  } else if(opt == TCP_OPT_MSS &&
    2d98:	52 30       	cpi	r21, 0x02	; 2
    2d9a:	e1 f4       	brne	.+56     	; 0x2dd4 <uip_process+0xb1a>
    2d9c:	67 a9       	ldd	r22, Z+55	; 0x37
    2d9e:	64 30       	cpi	r22, 0x04	; 4
    2da0:	c9 f4       	brne	.+50     	; 0x2dd4 <uip_process+0xb1a>
    2da2:	40 93 6a 03 	sts	0x036A, r20
    2da6:	50 93 6b 03 	sts	0x036B, r21
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
    2daa:	30 ad       	ldd	r19, Z+56	; 0x38
    2dac:	20 e0       	ldi	r18, 0x00	; 0
    2dae:	81 ad       	ldd	r24, Z+57	; 0x39
    2db0:	90 e0       	ldi	r25, 0x00	; 0
    2db2:	82 2b       	or	r24, r18
    2db4:	93 2b       	or	r25, r19
    2db6:	90 93 69 03 	sts	0x0369, r25
    2dba:	80 93 68 03 	sts	0x0368, r24
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;
    2dbe:	75 e0       	ldi	r23, 0x05	; 5
    2dc0:	85 3b       	cpi	r24, 0xB5	; 181
    2dc2:	97 07       	cpc	r25, r23
    2dc4:	10 f0       	brcs	.+4      	; 0x2dca <uip_process+0xb10>
    2dc6:	84 eb       	ldi	r24, 0xB4	; 180
    2dc8:	95 e0       	ldi	r25, 0x05	; 5
    2dca:	9b 8b       	std	Y+19, r25	; 0x13
    2dcc:	8a 8b       	std	Y+18, r24	; 0x12
	  } else if(opt == TCP_OPT_MSS &&
		    uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == TCP_OPT_MSS_LEN) {
	    /* An MSS option with the right option length. */
	    tmp16 = (uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 2 + c] << 8) |
	      uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 3 + c];
	    uip_connr->initialmss =
    2dce:	9d 8b       	std	Y+21, r25	; 0x15
    2dd0:	8c 8b       	std	Y+20, r24	; 0x14
	      uip_connr->mss = tmp16 > UIP_TCP_MSS? UIP_TCP_MSS: tmp16;

	    /* And we are done processing options. */
	    break;
    2dd2:	10 c0       	rjmp	.+32     	; 0x2df4 <uip_process+0xb3a>
	  } else {
	    /* All other options have a length field, so that we easily
	       can skip past them. */
	    if(uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c] == 0) {
    2dd4:	23 56       	subi	r18, 0x63	; 99
    2dd6:	38 4f       	sbci	r19, 0xF8	; 248
    2dd8:	f9 01       	movw	r30, r18
    2dda:	27 a9       	ldd	r18, Z+55	; 0x37
    2ddc:	22 23       	and	r18, r18
    2dde:	31 f0       	breq	.+12     	; 0x2dec <uip_process+0xb32>
	      /* If the length field is zero, the options are malformed
		 and we don't process them further. */
	      break;
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
    2de0:	42 0f       	add	r20, r18
    if((uip_flags & UIP_ACKDATA) &&
       (BUF->flags & TCP_CTL) == (TCP_SYN | TCP_ACK)) {

      /* Parse the TCP MSS option, if present. */
      if((BUF->tcpoffset & 0xf0) > 0x50) {
	for(c = 0; c < ((BUF->tcpoffset >> 4) - 5) << 2 ;) {
    2de2:	24 2f       	mov	r18, r20
    2de4:	30 e0       	ldi	r19, 0x00	; 0
    2de6:	28 17       	cp	r18, r24
    2de8:	39 07       	cpc	r19, r25
    2dea:	3c f2       	brlt	.-114    	; 0x2d7a <uip_process+0xac0>
    2dec:	40 93 6a 03 	sts	0x036A, r20
    2df0:	50 93 6b 03 	sts	0x036B, r21
	    }
	    c += uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN + 1 + c];
	  }
	}
      }
      uip_connr->tcpstateflags = UIP_ESTABLISHED;
    2df4:	83 e0       	ldi	r24, 0x03	; 3
    2df6:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->rcv_nxt[0] = BUF->seqno[0];
    2df8:	80 91 c3 07 	lds	r24, 0x07C3
    2dfc:	88 87       	std	Y+8, r24	; 0x08
      uip_connr->rcv_nxt[1] = BUF->seqno[1];
    2dfe:	80 91 c4 07 	lds	r24, 0x07C4
    2e02:	89 87       	std	Y+9, r24	; 0x09
      uip_connr->rcv_nxt[2] = BUF->seqno[2];
    2e04:	80 91 c5 07 	lds	r24, 0x07C5
    2e08:	8a 87       	std	Y+10, r24	; 0x0a
      uip_connr->rcv_nxt[3] = BUF->seqno[3];
    2e0a:	80 91 c6 07 	lds	r24, 0x07C6
    2e0e:	8b 87       	std	Y+11, r24	; 0x0b
      uip_add_rcv_nxt(1);
    2e10:	81 e0       	ldi	r24, 0x01	; 1
    2e12:	90 e0       	ldi	r25, 0x00	; 0
    2e14:	53 d9       	rcall	.-3418   	; 0x20bc <uip_add_rcv_nxt>
      uip_flags = UIP_CONNECTED | UIP_NEWDATA;
    2e16:	82 e4       	ldi	r24, 0x42	; 66
    2e18:	80 93 2d 06 	sts	0x062D, r24
      uip_connr->len = 0;
    2e1c:	19 8a       	std	Y+17, r1	; 0x11
    2e1e:	18 8a       	std	Y+16, r1	; 0x10
      uip_len = 0;
    2e20:	10 92 26 06 	sts	0x0626, r1
    2e24:	10 92 25 06 	sts	0x0625, r1
    2e28:	88 c0       	rjmp	.+272    	; 0x2f3a <uip_process+0xc80>
      uip_slen = 0;
      UIP_APPCALL();
      goto appsend;
    }
    /* Inform the application that the connection failed */
    uip_flags = UIP_ABORT;
    2e2a:	80 e2       	ldi	r24, 0x20	; 32
    2e2c:	80 93 2d 06 	sts	0x062D, r24
    UIP_APPCALL();
    2e30:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
    /* The connection is closed after we send the RST */
    uip_conn->tcpstateflags = UIP_CLOSED;
    2e34:	e0 91 32 06 	lds	r30, 0x0632
    2e38:	f0 91 33 06 	lds	r31, 0x0633
    2e3c:	11 8e       	std	Z+25, r1	; 0x19
    goto reset;
    2e3e:	58 cd       	rjmp	.-1360   	; 0x28f0 <uip_process+0x636>
    If the incoming packet is a FIN, we should close the connection on
    this side as well, and we send out a FIN and enter the LAST_ACK
    state. We require that there is no outstanding data; otherwise the
    sequence numbers will be screwed up. */

    if(BUF->flags & TCP_FIN && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2e40:	80 91 cc 07 	lds	r24, 0x07CC
    2e44:	80 ff       	sbrs	r24, 0
    2e46:	29 c0       	rjmp	.+82     	; 0x2e9a <uip_process+0xbe0>
    2e48:	24 fd       	sbrc	r18, 4
    2e4a:	27 c0       	rjmp	.+78     	; 0x2e9a <uip_process+0xbe0>
      if(uip_outstanding(uip_connr)) {
    2e4c:	88 89       	ldd	r24, Y+16	; 0x10
    2e4e:	99 89       	ldd	r25, Y+17	; 0x11
    2e50:	00 97       	sbiw	r24, 0x00	; 0
    2e52:	09 f0       	breq	.+2      	; 0x2e56 <uip_process+0xb9c>
    2e54:	a6 c1       	rjmp	.+844    	; 0x31a2 <uip_process+0xee8>
	goto drop;
      }
      uip_add_rcv_nxt(1 + uip_len);
    2e56:	80 91 25 06 	lds	r24, 0x0625
    2e5a:	90 91 26 06 	lds	r25, 0x0626
    2e5e:	01 96       	adiw	r24, 0x01	; 1
    2e60:	2d d9       	rcall	.-3494   	; 0x20bc <uip_add_rcv_nxt>
      uip_flags |= UIP_CLOSE;
    2e62:	20 91 2d 06 	lds	r18, 0x062D
    2e66:	82 2f       	mov	r24, r18
    2e68:	80 61       	ori	r24, 0x10	; 16
    2e6a:	80 93 2d 06 	sts	0x062D, r24
      if(uip_len > 0) {
    2e6e:	80 91 25 06 	lds	r24, 0x0625
    2e72:	90 91 26 06 	lds	r25, 0x0626
    2e76:	00 97       	sbiw	r24, 0x00	; 0
    2e78:	19 f0       	breq	.+6      	; 0x2e80 <uip_process+0xbc6>
	uip_flags |= UIP_NEWDATA;
    2e7a:	22 61       	ori	r18, 0x12	; 18
    2e7c:	20 93 2d 06 	sts	0x062D, r18
      }
      UIP_APPCALL();
    2e80:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
      uip_connr->len = 1;
    2e84:	81 e0       	ldi	r24, 0x01	; 1
    2e86:	90 e0       	ldi	r25, 0x00	; 0
    2e88:	99 8b       	std	Y+17, r25	; 0x11
    2e8a:	88 8b       	std	Y+16, r24	; 0x10
      uip_connr->tcpstateflags = UIP_LAST_ACK;
    2e8c:	88 e0       	ldi	r24, 0x08	; 8
    2e8e:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->nrtx = 0;
    2e90:	1b 8e       	std	Y+27, r1	; 0x1b
    tcp_send_finack:
      BUF->flags = TCP_FIN | TCP_ACK;
    2e92:	81 e1       	ldi	r24, 0x11	; 17
    2e94:	80 93 cc 07 	sts	0x07CC, r24
      goto tcp_send_nodata;
    2e98:	0b c1       	rjmp	.+534    	; 0x30b0 <uip_process+0xdf6>
    }

    /* Check the URG flag. If this is set, the segment carries urgent
       data that we must pass to the application. */
    if((BUF->flags & TCP_URG) != 0) {
    2e9a:	85 ff       	sbrs	r24, 5
    2e9c:	1c c0       	rjmp	.+56     	; 0x2ed6 <uip_process+0xc1c>
      uip_urgdata = uip_appdata;
      uip_appdata += uip_urglen;
    } else {
      uip_urglen = 0;
#else /* UIP_URGDATA > 0 */
      uip_appdata = ((char *)uip_appdata) + ((BUF->urgp[0] << 8) | BUF->urgp[1]);
    2e9e:	50 91 d1 07 	lds	r21, 0x07D1
    2ea2:	40 e0       	ldi	r20, 0x00	; 0
    2ea4:	80 91 d2 07 	lds	r24, 0x07D2
    2ea8:	90 e0       	ldi	r25, 0x00	; 0
    2eaa:	84 2b       	or	r24, r20
    2eac:	95 2b       	or	r25, r21
    2eae:	40 91 30 06 	lds	r20, 0x0630
    2eb2:	50 91 31 06 	lds	r21, 0x0631
    2eb6:	48 0f       	add	r20, r24
    2eb8:	59 1f       	adc	r21, r25
    2eba:	50 93 31 06 	sts	0x0631, r21
    2ebe:	40 93 30 06 	sts	0x0630, r20
      uip_len -= (BUF->urgp[0] << 8) | BUF->urgp[1];
    2ec2:	40 91 25 06 	lds	r20, 0x0625
    2ec6:	50 91 26 06 	lds	r21, 0x0626
    2eca:	48 1b       	sub	r20, r24
    2ecc:	59 0b       	sbc	r21, r25
    2ece:	50 93 26 06 	sts	0x0626, r21
    2ed2:	40 93 25 06 	sts	0x0625, r20
    /* If uip_len > 0 we have TCP data in the packet, and we flag this
       by setting the UIP_NEWDATA flag and update the sequence number
       we acknowledge. If the application has stopped the dataflow
       using uip_stop(), we must not accept any data packets from the
       remote host. */
    if(uip_len > 0 && !(uip_connr->tcpstateflags & UIP_STOPPED)) {
    2ed6:	80 91 25 06 	lds	r24, 0x0625
    2eda:	90 91 26 06 	lds	r25, 0x0626
    2ede:	00 97       	sbiw	r24, 0x00	; 0
    2ee0:	41 f0       	breq	.+16     	; 0x2ef2 <uip_process+0xc38>
    2ee2:	24 fd       	sbrc	r18, 4
    2ee4:	06 c0       	rjmp	.+12     	; 0x2ef2 <uip_process+0xc38>
      uip_flags |= UIP_NEWDATA;
    2ee6:	20 91 2d 06 	lds	r18, 0x062D
    2eea:	22 60       	ori	r18, 0x02	; 2
    2eec:	20 93 2d 06 	sts	0x062D, r18
      uip_add_rcv_nxt(uip_len);
    2ef0:	e5 d8       	rcall	.-3638   	; 0x20bc <uip_add_rcv_nxt>
       the initial MSS so that the application will send an entire MSS
       of data. This data will not be acknowledged by the receiver,
       and the application will retransmit it. This is called the
       "persistent timer" and uses the retransmission mechanism.
    */
    tmp16 = ((u16_t)BUF->wnd[0] << 8) + (u16_t)BUF->wnd[1];
    2ef2:	90 91 cd 07 	lds	r25, 0x07CD
    2ef6:	80 e0       	ldi	r24, 0x00	; 0
    2ef8:	20 91 ce 07 	lds	r18, 0x07CE
    2efc:	82 0f       	add	r24, r18
    2efe:	91 1d       	adc	r25, r1
    2f00:	90 93 69 03 	sts	0x0369, r25
    2f04:	80 93 68 03 	sts	0x0368, r24
    if(tmp16 > uip_connr->initialmss ||
    2f08:	2c 89       	ldd	r18, Y+20	; 0x14
    2f0a:	3d 89       	ldd	r19, Y+21	; 0x15
    2f0c:	28 17       	cp	r18, r24
    2f0e:	39 07       	cpc	r19, r25
    2f10:	10 f0       	brcs	.+4      	; 0x2f16 <uip_process+0xc5c>
    2f12:	00 97       	sbiw	r24, 0x00	; 0
    2f14:	21 f4       	brne	.+8      	; 0x2f1e <uip_process+0xc64>
       tmp16 == 0) {
      tmp16 = uip_connr->initialmss;
    2f16:	30 93 69 03 	sts	0x0369, r19
    2f1a:	20 93 68 03 	sts	0x0368, r18
    }
    uip_connr->mss = tmp16;
    2f1e:	80 91 68 03 	lds	r24, 0x0368
    2f22:	90 91 69 03 	lds	r25, 0x0369
    2f26:	9b 8b       	std	Y+19, r25	; 0x13
    2f28:	8a 8b       	std	Y+18, r24	; 0x12

       If the application wishes to send any data, this data should be
       put into the uip_appdata and the length of the data should be
       put into uip_len. If the application don't have any data to
       send, uip_len must be set to 0. */
    if(uip_flags & (UIP_NEWDATA | UIP_ACKDATA)) {
    2f2a:	80 91 2d 06 	lds	r24, 0x062D
    2f2e:	90 e0       	ldi	r25, 0x00	; 0
    2f30:	83 70       	andi	r24, 0x03	; 3
    2f32:	90 70       	andi	r25, 0x00	; 0
    2f34:	00 97       	sbiw	r24, 0x00	; 0
    2f36:	09 f4       	brne	.+2      	; 0x2f3a <uip_process+0xc80>
    2f38:	34 c1       	rjmp	.+616    	; 0x31a2 <uip_process+0xee8>
      uip_slen = 0;
    2f3a:	10 92 8a 0d 	sts	0x0D8A, r1
    2f3e:	10 92 89 0d 	sts	0x0D89, r1
      UIP_APPCALL();
    2f42:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>

    appsend:

      if(uip_flags & UIP_ABORT) {
    2f46:	80 91 2d 06 	lds	r24, 0x062D
    2f4a:	85 ff       	sbrs	r24, 5
    2f4c:	07 c0       	rjmp	.+14     	; 0x2f5c <uip_process+0xca2>
	uip_slen = 0;
    2f4e:	10 92 8a 0d 	sts	0x0D8A, r1
    2f52:	10 92 89 0d 	sts	0x0D89, r1
	uip_connr->tcpstateflags = UIP_CLOSED;
    2f56:	19 8e       	std	Y+25, r1	; 0x19
	BUF->flags = TCP_RST | TCP_ACK;
    2f58:	84 e1       	ldi	r24, 0x14	; 20
    2f5a:	9c cf       	rjmp	.-200    	; 0x2e94 <uip_process+0xbda>
	goto tcp_send_nodata;
      }

      if(uip_flags & UIP_CLOSE) {
    2f5c:	84 ff       	sbrs	r24, 4
    2f5e:	0a c0       	rjmp	.+20     	; 0x2f74 <uip_process+0xcba>
	uip_slen = 0;
    2f60:	10 92 8a 0d 	sts	0x0D8A, r1
    2f64:	10 92 89 0d 	sts	0x0D89, r1
	uip_connr->len = 1;
    2f68:	81 e0       	ldi	r24, 0x01	; 1
    2f6a:	90 e0       	ldi	r25, 0x00	; 0
    2f6c:	99 8b       	std	Y+17, r25	; 0x11
    2f6e:	88 8b       	std	Y+16, r24	; 0x10
	uip_connr->tcpstateflags = UIP_FIN_WAIT_1;
    2f70:	84 e0       	ldi	r24, 0x04	; 4
    2f72:	8d cf       	rjmp	.-230    	; 0x2e8e <uip_process+0xbd4>
	BUF->flags = TCP_FIN | TCP_ACK;
	goto tcp_send_nodata;
      }

      /* If uip_slen > 0, the application has data to be sent. */
      if(uip_slen > 0) {
    2f74:	20 91 89 0d 	lds	r18, 0x0D89
    2f78:	30 91 8a 0d 	lds	r19, 0x0D8A
    2f7c:	21 15       	cp	r18, r1
    2f7e:	31 05       	cpc	r19, r1
    2f80:	e1 f0       	breq	.+56     	; 0x2fba <uip_process+0xd00>

	/* If the connection has acknowledged data, the contents of
	   the ->len variable should be discarded. */
	if((uip_flags & UIP_ACKDATA) != 0) {
    2f82:	80 ff       	sbrs	r24, 0
    2f84:	02 c0       	rjmp	.+4      	; 0x2f8a <uip_process+0xcd0>
	  uip_connr->len = 0;
    2f86:	19 8a       	std	Y+17, r1	; 0x11
    2f88:	18 8a       	std	Y+16, r1	; 0x10
	}

	/* If the ->len variable is non-zero the connection has
	   already data in transit and cannot send anymore right
	   now. */
	if(uip_connr->len == 0) {
    2f8a:	88 89       	ldd	r24, Y+16	; 0x10
    2f8c:	99 89       	ldd	r25, Y+17	; 0x11
    2f8e:	00 97       	sbiw	r24, 0x00	; 0
    2f90:	81 f4       	brne	.+32     	; 0x2fb2 <uip_process+0xcf8>

	  /* The application cannot send more than what is allowed by
	     the mss (the minumum of the MSS and the available
	     window). */
	  if(uip_slen > uip_connr->mss) {
    2f92:	8a 89       	ldd	r24, Y+18	; 0x12
    2f94:	9b 89       	ldd	r25, Y+19	; 0x13
    2f96:	82 17       	cp	r24, r18
    2f98:	93 07       	cpc	r25, r19
    2f9a:	20 f4       	brcc	.+8      	; 0x2fa4 <uip_process+0xcea>
	    uip_slen = uip_connr->mss;
    2f9c:	90 93 8a 0d 	sts	0x0D8A, r25
    2fa0:	80 93 89 0d 	sts	0x0D89, r24
	  }

	  /* Remember how much data we send out now so that we know
	     when everything has been acknowledged. */
	  uip_connr->len = uip_slen;
    2fa4:	80 91 89 0d 	lds	r24, 0x0D89
    2fa8:	90 91 8a 0d 	lds	r25, 0x0D8A
    2fac:	99 8b       	std	Y+17, r25	; 0x11
    2fae:	88 8b       	std	Y+16, r24	; 0x10
    2fb0:	04 c0       	rjmp	.+8      	; 0x2fba <uip_process+0xd00>
	} else {

	  /* If the application already had unacknowledged data, we
	     make sure that the application does not send (i.e.,
	     retransmit) out more than it previously sent out. */
	  uip_slen = uip_connr->len;
    2fb2:	90 93 8a 0d 	sts	0x0D8A, r25
    2fb6:	80 93 89 0d 	sts	0x0D89, r24
	}
      }
      uip_connr->nrtx = 0;
    2fba:	1b 8e       	std	Y+27, r1	; 0x1b
    apprexmit:
      uip_appdata = uip_sappdata;
    2fbc:	80 91 27 06 	lds	r24, 0x0627
    2fc0:	90 91 28 06 	lds	r25, 0x0628
    2fc4:	90 93 31 06 	sts	0x0631, r25
    2fc8:	80 93 30 06 	sts	0x0630, r24

      /* If the application has data to be sent, or if the incoming
         packet had new data in it, we must send out a packet. */
      if(uip_slen > 0 && uip_connr->len > 0) {
    2fcc:	80 91 89 0d 	lds	r24, 0x0D89
    2fd0:	90 91 8a 0d 	lds	r25, 0x0D8A
    2fd4:	00 97       	sbiw	r24, 0x00	; 0
    2fd6:	59 f0       	breq	.+22     	; 0x2fee <uip_process+0xd34>
    2fd8:	88 89       	ldd	r24, Y+16	; 0x10
    2fda:	99 89       	ldd	r25, Y+17	; 0x11
    2fdc:	00 97       	sbiw	r24, 0x00	; 0
    2fde:	39 f0       	breq	.+14     	; 0x2fee <uip_process+0xd34>
	/* Add the length of the IP and TCP headers. */
	uip_len = uip_connr->len + UIP_TCPIP_HLEN;
    2fe0:	88 96       	adiw	r24, 0x28	; 40
    2fe2:	90 93 26 06 	sts	0x0626, r25
    2fe6:	80 93 25 06 	sts	0x0625, r24
	/* We always set the ACK flag in response packets. */
	BUF->flags = TCP_ACK | TCP_PSH;
    2fea:	88 e1       	ldi	r24, 0x18	; 24
    2fec:	0b c0       	rjmp	.+22     	; 0x3004 <uip_process+0xd4a>
	/* Send the packet. */
	goto tcp_send_noopts;
      }
      /* If there is no data to send, just send out a pure ACK if
	 there is newdata. */
      if(uip_flags & UIP_NEWDATA) {
    2fee:	80 91 2d 06 	lds	r24, 0x062D
    2ff2:	81 ff       	sbrs	r24, 1
    2ff4:	d6 c0       	rjmp	.+428    	; 0x31a2 <uip_process+0xee8>
	uip_len = UIP_TCPIP_HLEN;
    2ff6:	88 e2       	ldi	r24, 0x28	; 40
    2ff8:	90 e0       	ldi	r25, 0x00	; 0
    2ffa:	90 93 26 06 	sts	0x0626, r25
    2ffe:	80 93 25 06 	sts	0x0625, r24
	BUF->flags = TCP_ACK;
    3002:	80 e1       	ldi	r24, 0x10	; 16
    3004:	80 93 cc 07 	sts	0x07CC, r24
	goto tcp_send_noopts;
    3008:	59 c0       	rjmp	.+178    	; 0x30bc <uip_process+0xe02>
    }
    goto drop;
  case UIP_LAST_ACK:
    /* We can close this connection if the peer has acknowledged our
       FIN. This is indicated by the UIP_ACKDATA flag. */
    if(uip_flags & UIP_ACKDATA) {
    300a:	80 91 2d 06 	lds	r24, 0x062D
    300e:	80 ff       	sbrs	r24, 0
    3010:	c8 c0       	rjmp	.+400    	; 0x31a2 <uip_process+0xee8>
      uip_connr->tcpstateflags = UIP_CLOSED;
    3012:	19 8e       	std	Y+25, r1	; 0x19
      uip_flags = UIP_CLOSE;
    3014:	80 e1       	ldi	r24, 0x10	; 16
    3016:	80 93 2d 06 	sts	0x062D, r24
      UIP_APPCALL();
    301a:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
    301e:	c1 c0       	rjmp	.+386    	; 0x31a2 <uip_process+0xee8>

  case UIP_FIN_WAIT_1:
    /* The application has closed the connection, but the remote host
       hasn't closed its end yet. Thus we do nothing but wait for a
       FIN from the other side. */
    if(uip_len > 0) {
    3020:	80 91 25 06 	lds	r24, 0x0625
    3024:	90 91 26 06 	lds	r25, 0x0626
    3028:	00 97       	sbiw	r24, 0x00	; 0
    302a:	09 f0       	breq	.+2      	; 0x302e <uip_process+0xd74>
      uip_add_rcv_nxt(uip_len);
    302c:	47 d8       	rcall	.-3954   	; 0x20bc <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    302e:	90 91 cc 07 	lds	r25, 0x07CC
    3032:	80 91 2d 06 	lds	r24, 0x062D
    3036:	90 ff       	sbrs	r25, 0
    3038:	0b c0       	rjmp	.+22     	; 0x3050 <uip_process+0xd96>
      if(uip_flags & UIP_ACKDATA) {
    303a:	80 ff       	sbrs	r24, 0
    303c:	06 c0       	rjmp	.+12     	; 0x304a <uip_process+0xd90>
	uip_connr->tcpstateflags = UIP_TIME_WAIT;
    303e:	87 e0       	ldi	r24, 0x07	; 7
    3040:	89 8f       	std	Y+25, r24	; 0x19
	uip_connr->timer = 0;
    3042:	1a 8e       	std	Y+26, r1	; 0x1a
	uip_connr->len = 0;
    3044:	19 8a       	std	Y+17, r1	; 0x11
    3046:	18 8a       	std	Y+16, r1	; 0x10
    3048:	18 c0       	rjmp	.+48     	; 0x307a <uip_process+0xdc0>
      } else {
	uip_connr->tcpstateflags = UIP_CLOSING;
    304a:	86 e0       	ldi	r24, 0x06	; 6
    304c:	89 8f       	std	Y+25, r24	; 0x19
    304e:	15 c0       	rjmp	.+42     	; 0x307a <uip_process+0xdc0>
      }
      uip_add_rcv_nxt(1);
      uip_flags = UIP_CLOSE;
      UIP_APPCALL();
      goto tcp_send_ack;
    } else if(uip_flags & UIP_ACKDATA) {
    3050:	80 ff       	sbrs	r24, 0
    3052:	1c c0       	rjmp	.+56     	; 0x308c <uip_process+0xdd2>
      uip_connr->tcpstateflags = UIP_FIN_WAIT_2;
    3054:	85 e0       	ldi	r24, 0x05	; 5
    3056:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->len = 0;
    3058:	19 8a       	std	Y+17, r1	; 0x11
    305a:	18 8a       	std	Y+16, r1	; 0x10
      goto drop;
    305c:	a2 c0       	rjmp	.+324    	; 0x31a2 <uip_process+0xee8>
      goto tcp_send_ack;
    }
    goto drop;

  case UIP_FIN_WAIT_2:
    if(uip_len > 0) {
    305e:	80 91 25 06 	lds	r24, 0x0625
    3062:	90 91 26 06 	lds	r25, 0x0626
    3066:	00 97       	sbiw	r24, 0x00	; 0
    3068:	09 f0       	breq	.+2      	; 0x306c <uip_process+0xdb2>
      uip_add_rcv_nxt(uip_len);
    306a:	28 d8       	rcall	.-4016   	; 0x20bc <uip_add_rcv_nxt>
    }
    if(BUF->flags & TCP_FIN) {
    306c:	80 91 cc 07 	lds	r24, 0x07CC
    3070:	80 ff       	sbrs	r24, 0
    3072:	0c c0       	rjmp	.+24     	; 0x308c <uip_process+0xdd2>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    3074:	87 e0       	ldi	r24, 0x07	; 7
    3076:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    3078:	1a 8e       	std	Y+26, r1	; 0x1a
      uip_add_rcv_nxt(1);
    307a:	81 e0       	ldi	r24, 0x01	; 1
    307c:	90 e0       	ldi	r25, 0x00	; 0
    307e:	1e d8       	rcall	.-4036   	; 0x20bc <uip_add_rcv_nxt>
      uip_flags = UIP_CLOSE;
    3080:	80 e1       	ldi	r24, 0x10	; 16
    3082:	80 93 2d 06 	sts	0x062D, r24
      UIP_APPCALL();
    3086:	0e 94 75 09 	call	0x12ea	; 0x12ea <uIPManagement_TCPCallback>
      goto tcp_send_ack;
    308a:	0f c0       	rjmp	.+30     	; 0x30aa <uip_process+0xdf0>
    }
    if(uip_len > 0) {
    308c:	80 91 25 06 	lds	r24, 0x0625
    3090:	90 91 26 06 	lds	r25, 0x0626
    3094:	00 97       	sbiw	r24, 0x00	; 0
    3096:	49 f4       	brne	.+18     	; 0x30aa <uip_process+0xdf0>
    3098:	84 c0       	rjmp	.+264    	; 0x31a2 <uip_process+0xee8>

  case UIP_TIME_WAIT:
    goto tcp_send_ack;

  case UIP_CLOSING:
    if(uip_flags & UIP_ACKDATA) {
    309a:	80 91 2d 06 	lds	r24, 0x062D
    309e:	80 ff       	sbrs	r24, 0
    30a0:	80 c0       	rjmp	.+256    	; 0x31a2 <uip_process+0xee8>
      uip_connr->tcpstateflags = UIP_TIME_WAIT;
    30a2:	87 e0       	ldi	r24, 0x07	; 7
    30a4:	89 8f       	std	Y+25, r24	; 0x19
      uip_connr->timer = 0;
    30a6:	1a 8e       	std	Y+26, r1	; 0x1a
    30a8:	7c c0       	rjmp	.+248    	; 0x31a2 <uip_process+0xee8>
  goto drop;

  /* We jump here when we are ready to send the packet, and just want
     to set the appropriate TCP sequence numbers in the TCP header. */
 tcp_send_ack:
  BUF->flags = TCP_ACK;
    30aa:	80 e1       	ldi	r24, 0x10	; 16
    30ac:	f8 01       	movw	r30, r16
    30ae:	81 a3       	std	Z+33, r24	; 0x21

 tcp_send_nodata:
  uip_len = UIP_IPTCPH_LEN;
    30b0:	88 e2       	ldi	r24, 0x28	; 40
    30b2:	90 e0       	ldi	r25, 0x00	; 0
    30b4:	90 93 26 06 	sts	0x0626, r25
    30b8:	80 93 25 06 	sts	0x0625, r24

 tcp_send_noopts:
  BUF->tcpoffset = (UIP_TCPH_LEN / 4) << 4;
    30bc:	80 e5       	ldi	r24, 0x50	; 80
    30be:	80 93 cb 07 	sts	0x07CB, r24
  /* We're done with the input processing. We are now ready to send a
     reply. Our job is to fill in all the fields of the TCP and IP
     headers before calculating the checksum and finally send the
     packet. */
 tcp_send:
  BUF->ackno[0] = uip_connr->rcv_nxt[0];
    30c2:	eb ea       	ldi	r30, 0xAB	; 171
    30c4:	f7 e0       	ldi	r31, 0x07	; 7
    30c6:	88 85       	ldd	r24, Y+8	; 0x08
    30c8:	84 8f       	std	Z+28, r24	; 0x1c
  BUF->ackno[1] = uip_connr->rcv_nxt[1];
    30ca:	89 85       	ldd	r24, Y+9	; 0x09
    30cc:	85 8f       	std	Z+29, r24	; 0x1d
  BUF->ackno[2] = uip_connr->rcv_nxt[2];
    30ce:	8a 85       	ldd	r24, Y+10	; 0x0a
    30d0:	86 8f       	std	Z+30, r24	; 0x1e
  BUF->ackno[3] = uip_connr->rcv_nxt[3];
    30d2:	8b 85       	ldd	r24, Y+11	; 0x0b
    30d4:	87 8f       	std	Z+31, r24	; 0x1f

  BUF->seqno[0] = uip_connr->snd_nxt[0];
    30d6:	8c 85       	ldd	r24, Y+12	; 0x0c
    30d8:	80 8f       	std	Z+24, r24	; 0x18
  BUF->seqno[1] = uip_connr->snd_nxt[1];
    30da:	8d 85       	ldd	r24, Y+13	; 0x0d
    30dc:	81 8f       	std	Z+25, r24	; 0x19
  BUF->seqno[2] = uip_connr->snd_nxt[2];
    30de:	8e 85       	ldd	r24, Y+14	; 0x0e
    30e0:	82 8f       	std	Z+26, r24	; 0x1a
  BUF->seqno[3] = uip_connr->snd_nxt[3];
    30e2:	8f 85       	ldd	r24, Y+15	; 0x0f
    30e4:	83 8f       	std	Z+27, r24	; 0x1b

  BUF->proto = UIP_PROTO_TCP;
    30e6:	86 e0       	ldi	r24, 0x06	; 6
    30e8:	81 87       	std	Z+9, r24	; 0x09

  BUF->srcport  = uip_connr->lport;
    30ea:	8c 81       	ldd	r24, Y+4	; 0x04
    30ec:	9d 81       	ldd	r25, Y+5	; 0x05
    30ee:	95 8b       	std	Z+21, r25	; 0x15
    30f0:	84 8b       	std	Z+20, r24	; 0x14
  BUF->destport = uip_connr->rport;
    30f2:	8e 81       	ldd	r24, Y+6	; 0x06
    30f4:	9f 81       	ldd	r25, Y+7	; 0x07
    30f6:	97 8b       	std	Z+23, r25	; 0x17
    30f8:	86 8b       	std	Z+22, r24	; 0x16

  uip_ipaddr_copy(&BUF->srcipaddr, &uip_hostaddr);
    30fa:	80 91 99 07 	lds	r24, 0x0799
    30fe:	90 91 9a 07 	lds	r25, 0x079A
    3102:	a0 91 9b 07 	lds	r26, 0x079B
    3106:	b0 91 9c 07 	lds	r27, 0x079C
    310a:	80 93 b7 07 	sts	0x07B7, r24
    310e:	90 93 b8 07 	sts	0x07B8, r25
    3112:	a0 93 b9 07 	sts	0x07B9, r26
    3116:	b0 93 ba 07 	sts	0x07BA, r27
  uip_ipaddr_copy(&BUF->destipaddr, &uip_connr->ripaddr);
    311a:	88 81       	ld	r24, Y
    311c:	99 81       	ldd	r25, Y+1	; 0x01
    311e:	aa 81       	ldd	r26, Y+2	; 0x02
    3120:	bb 81       	ldd	r27, Y+3	; 0x03
    3122:	80 93 bb 07 	sts	0x07BB, r24
    3126:	90 93 bc 07 	sts	0x07BC, r25
    312a:	a0 93 bd 07 	sts	0x07BD, r26
    312e:	b0 93 be 07 	sts	0x07BE, r27

  if(uip_connr->tcpstateflags & UIP_STOPPED) {
    3132:	89 8d       	ldd	r24, Y+25	; 0x19
    3134:	84 ff       	sbrs	r24, 4
    3136:	03 c0       	rjmp	.+6      	; 0x313e <uip_process+0xe84>
    /* If the connection has issued uip_stop(), we advertise a zero
       window so that the remote host will stop sending data. */
    BUF->wnd[0] = BUF->wnd[1] = 0;
    3138:	13 a2       	std	Z+35, r1	; 0x23
    313a:	12 a2       	std	Z+34, r1	; 0x22
    313c:	04 c0       	rjmp	.+8      	; 0x3146 <uip_process+0xe8c>
  } else {
    BUF->wnd[0] = ((UIP_RECEIVE_WINDOW) >> 8);
    313e:	85 e0       	ldi	r24, 0x05	; 5
    3140:	82 a3       	std	Z+34, r24	; 0x22
    BUF->wnd[1] = ((UIP_RECEIVE_WINDOW) & 0xff);
    3142:	84 eb       	ldi	r24, 0xB4	; 180
    3144:	83 a3       	std	Z+35, r24	; 0x23
  }

 tcp_send_noconn:
  BUF->ttl = UIP_TTL;
    3146:	cb ea       	ldi	r28, 0xAB	; 171
    3148:	d7 e0       	ldi	r29, 0x07	; 7
    314a:	80 e4       	ldi	r24, 0x40	; 64
    314c:	88 87       	std	Y+8, r24	; 0x08
  /* For IPv6, the IP length field does not include the IPv6 IP header
     length. */
  BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
  BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
  BUF->len[0] = (uip_len >> 8);
    314e:	80 91 25 06 	lds	r24, 0x0625
    3152:	90 91 26 06 	lds	r25, 0x0626
    3156:	9a 83       	std	Y+2, r25	; 0x02
  BUF->len[1] = (uip_len & 0xff);
    3158:	8b 83       	std	Y+3, r24	; 0x03
#endif /* UIP_CONF_IPV6 */

  BUF->urgp[0] = BUF->urgp[1] = 0;
    315a:	1f a2       	std	Y+39, r1	; 0x27
    315c:	1e a2       	std	Y+38, r1	; 0x26

  /* Calculate TCP checksum. */
  BUF->tcpchksum = 0;
    315e:	1d a2       	std	Y+37, r1	; 0x25
    3160:	1c a2       	std	Y+36, r1	; 0x24
  BUF->tcpchksum = ~(uip_tcpchksum());
    3162:	89 d8       	rcall	.-3822   	; 0x2276 <uip_tcpchksum>
    3164:	80 95       	com	r24
    3166:	90 95       	com	r25
    3168:	9d a3       	std	Y+37, r25	; 0x25
    316a:	8c a3       	std	Y+36, r24	; 0x24
#if UIP_CONF_IPV6
  BUF->vtc = 0x60;
  BUF->tcflow = 0x00;
  BUF->flow = 0x00;
#else /* UIP_CONF_IPV6 */
  BUF->vhl = 0x45;
    316c:	cb ea       	ldi	r28, 0xAB	; 171
    316e:	d7 e0       	ldi	r29, 0x07	; 7
    3170:	85 e4       	ldi	r24, 0x45	; 69
    3172:	80 93 ab 07 	sts	0x07AB, r24
  BUF->tos = 0;
    3176:	19 82       	std	Y+1, r1	; 0x01
  BUF->ipoffset[0] = BUF->ipoffset[1] = 0;
    3178:	1f 82       	std	Y+7, r1	; 0x07
    317a:	1e 82       	std	Y+6, r1	; 0x06
  ++ipid;
    317c:	80 91 6c 03 	lds	r24, 0x036C
    3180:	90 91 6d 03 	lds	r25, 0x036D
    3184:	01 96       	adiw	r24, 0x01	; 1
    3186:	90 93 6d 03 	sts	0x036D, r25
    318a:	80 93 6c 03 	sts	0x036C, r24
  BUF->ipid[0] = ipid >> 8;
    318e:	9c 83       	std	Y+4, r25	; 0x04
  BUF->ipid[1] = ipid & 0xff;
    3190:	8d 83       	std	Y+5, r24	; 0x05
  /* Calculate IP checksum. */
  BUF->ipchksum = 0;
    3192:	1b 86       	std	Y+11, r1	; 0x0b
    3194:	1a 86       	std	Y+10, r1	; 0x0a
  BUF->ipchksum = ~(uip_ipchksum());
    3196:	58 d8       	rcall	.-3920   	; 0x2248 <uip_ipchksum>
    3198:	80 95       	com	r24
    319a:	90 95       	com	r25
    319c:	9b 87       	std	Y+11, r25	; 0x0b
    319e:	8a 87       	std	Y+10, r24	; 0x0a
    31a0:	04 c0       	rjmp	.+8      	; 0x31aa <uip_process+0xef0>
  /* Return and let the caller do the actual transmission. */
  uip_flags = 0;
  return;

 drop:
  uip_len = 0;
    31a2:	10 92 26 06 	sts	0x0626, r1
    31a6:	10 92 25 06 	sts	0x0625, r1
  uip_flags = 0;
    31aa:	10 92 2d 06 	sts	0x062D, r1
  return;
}
    31ae:	df 91       	pop	r29
    31b0:	cf 91       	pop	r28
    31b2:	1f 91       	pop	r17
    31b4:	0f 91       	pop	r16
    31b6:	ff 90       	pop	r15
    31b8:	ef 90       	pop	r14
    31ba:	08 95       	ret

000031bc <uip_send>:
  return HTONL(val);
}
/*---------------------------------------------------------------------------*/
void
uip_send(const void *data, int len)
{
    31bc:	ac 01       	movw	r20, r24
  int copylen;
#define MIN(a,b) ((a) < (b)? (a): (b))
  copylen = MIN(len, UIP_BUFSIZE - UIP_LLH_LEN - UIP_TCPIP_HLEN -
    31be:	e0 91 27 06 	lds	r30, 0x0627
    31c2:	f0 91 28 06 	lds	r31, 0x0628
    31c6:	88 27       	eor	r24, r24
    31c8:	99 27       	eor	r25, r25
    31ca:	8e 1b       	sub	r24, r30
    31cc:	9f 0b       	sbc	r25, r31
    31ce:	89 57       	subi	r24, 0x79	; 121
    31d0:	92 4f       	sbci	r25, 0xF2	; 242
    31d2:	26 2f       	mov	r18, r22
    31d4:	37 2f       	mov	r19, r23
    31d6:	82 17       	cp	r24, r18
    31d8:	93 07       	cpc	r25, r19
    31da:	0c f4       	brge	.+2      	; 0x31de <uip_send+0x22>
    31dc:	9c 01       	movw	r18, r24
		(int)((char *)uip_sappdata - (char *)&uip_buf[UIP_LLH_LEN + UIP_TCPIP_HLEN]));
  if(copylen > 0) {
    31de:	12 16       	cp	r1, r18
    31e0:	13 06       	cpc	r1, r19
    31e2:	64 f4       	brge	.+24     	; 0x31fc <uip_send+0x40>
    uip_slen = copylen;
    31e4:	20 93 89 0d 	sts	0x0D89, r18
    31e8:	30 93 8a 0d 	sts	0x0D8A, r19
    if(data != uip_sappdata) {
    31ec:	4e 17       	cp	r20, r30
    31ee:	5f 07       	cpc	r21, r31
    31f0:	29 f0       	breq	.+10     	; 0x31fc <uip_send+0x40>
      memcpy(uip_sappdata, (data), uip_slen);
    31f2:	cf 01       	movw	r24, r30
    31f4:	ba 01       	movw	r22, r20
    31f6:	a9 01       	movw	r20, r18
    31f8:	0c 94 0a 3d 	jmp	0x7a14	; 0x7a14 <memcpy>
    31fc:	08 95       	ret

000031fe <uip_arp_update>:

}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
    31fe:	cf 92       	push	r12
    3200:	df 92       	push	r13
    3202:	ff 92       	push	r15
    3204:	0f 93       	push	r16
    3206:	1f 93       	push	r17
    3208:	cf 93       	push	r28
    320a:	df 93       	push	r29
    320c:	fc 01       	movw	r30, r24
    320e:	f7 2e       	mov	r15, r23
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3210:	10 92 74 03 	sts	0x0374, r1

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3214:	c0 91 24 03 	lds	r28, 0x0324
    3218:	d0 91 25 03 	lds	r29, 0x0325
    321c:	c0 90 26 03 	lds	r12, 0x0326
    3220:	d0 90 27 03 	lds	r13, 0x0327
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3224:	70 e0       	ldi	r23, 0x00	; 0
}
/*-----------------------------------------------------------------------------------*/
static void
uip_arp_update(uip_ipaddr_t *ipaddr, struct uip_eth_addr *ethaddr)
{
  register struct arp_entry *tabptr = NULL;
    3226:	a0 e0       	ldi	r26, 0x00	; 0
    3228:	b0 e0       	ldi	r27, 0x00	; 0
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    322a:	2b e0       	ldi	r18, 0x0B	; 11
    322c:	30 e0       	ldi	r19, 0x00	; 0
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    322e:	56 c0       	rjmp	.+172    	; 0x32dc <uip_arp_update+0xde>

    tabptr = &arp_table[i];
    3230:	87 2f       	mov	r24, r23
    3232:	90 e0       	ldi	r25, 0x00	; 0
    /* Only check those entries that are actually in use. */
    if(!uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3234:	82 9f       	mul	r24, r18
    3236:	d0 01       	movw	r26, r0
    3238:	83 9f       	mul	r24, r19
    323a:	b0 0d       	add	r27, r0
    323c:	92 9f       	mul	r25, r18
    323e:	b0 0d       	add	r27, r0
    3240:	11 24       	eor	r1, r1
    3242:	ab 58       	subi	r26, 0x8B	; 139
    3244:	bc 4f       	sbci	r27, 0xFC	; 252
    3246:	4d 91       	ld	r20, X+
    3248:	5c 91       	ld	r21, X
    324a:	11 97       	sbiw	r26, 0x01	; 1
    324c:	4c 17       	cp	r20, r28
    324e:	5d 07       	cpc	r21, r29
    3250:	39 f4       	brne	.+14     	; 0x3260 <uip_arp_update+0x62>
    3252:	12 96       	adiw	r26, 0x02	; 2
    3254:	0d 90       	ld	r0, X+
    3256:	bc 91       	ld	r27, X
    3258:	a0 2d       	mov	r26, r0
    325a:	ac 15       	cp	r26, r12
    325c:	bd 05       	cpc	r27, r13
    325e:	a1 f1       	breq	.+104    	; 0x32c8 <uip_arp_update+0xca>

      /* Check if the source IP address of the incoming packet matches
         the IP address in this ARP table entry. */
      if(uip_ipaddr_cmp(ipaddr, &tabptr->ipaddr)) {
    3260:	a0 81       	ld	r26, Z
    3262:	b1 81       	ldd	r27, Z+1	; 0x01
    3264:	a4 17       	cp	r26, r20
    3266:	b5 07       	cpc	r27, r21
    3268:	79 f5       	brne	.+94     	; 0x32c8 <uip_arp_update+0xca>
    326a:	82 9f       	mul	r24, r18
    326c:	a0 01       	movw	r20, r0
    326e:	83 9f       	mul	r24, r19
    3270:	50 0d       	add	r21, r0
    3272:	92 9f       	mul	r25, r18
    3274:	50 0d       	add	r21, r0
    3276:	11 24       	eor	r1, r1
    3278:	da 01       	movw	r26, r20
    327a:	ab 58       	subi	r26, 0x8B	; 139
    327c:	bc 4f       	sbci	r27, 0xFC	; 252
    327e:	02 81       	ldd	r16, Z+2	; 0x02
    3280:	13 81       	ldd	r17, Z+3	; 0x03
    3282:	12 96       	adiw	r26, 0x02	; 2
    3284:	0d 90       	ld	r0, X+
    3286:	bc 91       	ld	r27, X
    3288:	a0 2d       	mov	r26, r0
    328a:	0a 17       	cp	r16, r26
    328c:	1b 07       	cpc	r17, r27
    328e:	e1 f4       	brne	.+56     	; 0x32c8 <uip_arp_update+0xca>
    3290:	70 93 74 03 	sts	0x0374, r23

	/* An old entry found, update this and return. */
	memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    3294:	fa 01       	movw	r30, r20
    3296:	e7 58       	subi	r30, 0x87	; 135
    3298:	fc 4f       	sbci	r31, 0xFC	; 252
    329a:	26 2f       	mov	r18, r22
    329c:	3f 2d       	mov	r19, r15
    329e:	d9 01       	movw	r26, r18
    32a0:	26 e0       	ldi	r18, 0x06	; 6
    32a2:	0d 90       	ld	r0, X+
    32a4:	01 92       	st	Z+, r0
    32a6:	21 50       	subi	r18, 0x01	; 1
    32a8:	e1 f7       	brne	.-8      	; 0x32a2 <uip_arp_update+0xa4>
	tabptr->time = arptime;
    32aa:	2b e0       	ldi	r18, 0x0B	; 11
    32ac:	30 e0       	ldi	r19, 0x00	; 0
    32ae:	82 9f       	mul	r24, r18
    32b0:	f0 01       	movw	r30, r0
    32b2:	83 9f       	mul	r24, r19
    32b4:	f0 0d       	add	r31, r0
    32b6:	92 9f       	mul	r25, r18
    32b8:	f0 0d       	add	r31, r0
    32ba:	11 24       	eor	r1, r1
    32bc:	eb 58       	subi	r30, 0x8B	; 139
    32be:	fc 4f       	sbci	r31, 0xFC	; 252
    32c0:	80 91 cd 03 	lds	r24, 0x03CD
    32c4:	82 87       	std	Z+10, r24	; 0x0a

	return;
    32c6:	87 c0       	rjmp	.+270    	; 0x33d6 <uip_arp_update+0x1d8>
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {

    tabptr = &arp_table[i];
    32c8:	82 9f       	mul	r24, r18
    32ca:	d0 01       	movw	r26, r0
    32cc:	83 9f       	mul	r24, r19
    32ce:	b0 0d       	add	r27, r0
    32d0:	92 9f       	mul	r25, r18
    32d2:	b0 0d       	add	r27, r0
    32d4:	11 24       	eor	r1, r1
    32d6:	ab 58       	subi	r26, 0x8B	; 139
    32d8:	bc 4f       	sbci	r27, 0xFC	; 252
    32da:	7f 5f       	subi	r23, 0xFF	; 255
{
  register struct arp_entry *tabptr = NULL;
  /* Walk through the ARP mapping table and try to find an entry to
     update. If none is found, the IP -> MAC address mapping is
     inserted in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32dc:	78 30       	cpi	r23, 0x08	; 8
    32de:	08 f4       	brcc	.+2      	; 0x32e2 <uip_arp_update+0xe4>
    32e0:	a7 cf       	rjmp	.-178    	; 0x3230 <uip_arp_update+0x32>

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32e2:	10 92 74 03 	sts	0x0374, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    32e6:	40 91 24 03 	lds	r20, 0x0324
    32ea:	50 91 25 03 	lds	r21, 0x0325
    32ee:	20 91 26 03 	lds	r18, 0x0326
    32f2:	30 91 27 03 	lds	r19, 0x0327

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32f6:	70 e0       	ldi	r23, 0x00	; 0
    tabptr = &arp_table[i];
    32f8:	8b e0       	ldi	r24, 0x0B	; 11
    32fa:	90 e0       	ldi	r25, 0x00	; 0

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    32fc:	19 c0       	rjmp	.+50     	; 0x3330 <uip_arp_update+0x132>
    tabptr = &arp_table[i];
    32fe:	c7 2f       	mov	r28, r23
    3300:	d0 e0       	ldi	r29, 0x00	; 0
    3302:	c8 9f       	mul	r28, r24
    3304:	d0 01       	movw	r26, r0
    3306:	c9 9f       	mul	r28, r25
    3308:	b0 0d       	add	r27, r0
    330a:	d8 9f       	mul	r29, r24
    330c:	b0 0d       	add	r27, r0
    330e:	11 24       	eor	r1, r1
    3310:	ab 58       	subi	r26, 0x8B	; 139
    3312:	bc 4f       	sbci	r27, 0xFC	; 252
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr)) {
    3314:	cd 91       	ld	r28, X+
    3316:	dc 91       	ld	r29, X
    3318:	11 97       	sbiw	r26, 0x01	; 1
    331a:	c4 17       	cp	r28, r20
    331c:	d5 07       	cpc	r29, r21
    331e:	39 f4       	brne	.+14     	; 0x332e <uip_arp_update+0x130>
    3320:	12 96       	adiw	r26, 0x02	; 2
    3322:	cd 91       	ld	r28, X+
    3324:	dc 91       	ld	r29, X
    3326:	13 97       	sbiw	r26, 0x03	; 3
    3328:	c2 17       	cp	r28, r18
    332a:	d3 07       	cpc	r29, r19
    332c:	19 f0       	breq	.+6      	; 0x3334 <uip_arp_update+0x136>
    332e:	7f 5f       	subi	r23, 0xFF	; 255

  /* If we get here, no existing ARP table entry was found, so we
     create one. */

  /* First, we try to find an unused entry in the ARP table. */
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3330:	78 30       	cpi	r23, 0x08	; 8
    3332:	28 f3       	brcs	.-54     	; 0x32fe <uip_arp_update+0x100>
    3334:	70 93 74 03 	sts	0x0374, r23
    }
  }

  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    3338:	78 30       	cpi	r23, 0x08	; 8
    333a:	b9 f5       	brne	.+110    	; 0x33aa <uip_arp_update+0x1ac>
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    333c:	00 91 cd 03 	lds	r16, 0x03CD
    3340:	40 2f       	mov	r20, r16
    3342:	50 e0       	ldi	r21, 0x00	; 0
    3344:	70 e0       	ldi	r23, 0x00	; 0
    3346:	20 e0       	ldi	r18, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3348:	30 e0       	ldi	r19, 0x00	; 0
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
    334a:	8b e0       	ldi	r24, 0x0B	; 11
    334c:	90 e0       	ldi	r25, 0x00	; 0
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    334e:	19 c0       	rjmp	.+50     	; 0x3382 <uip_arp_update+0x184>
      tabptr = &arp_table[i];
    3350:	c3 2f       	mov	r28, r19
    3352:	d0 e0       	ldi	r29, 0x00	; 0
      if(arptime - tabptr->time > tmpage) {
    3354:	c8 9f       	mul	r28, r24
    3356:	d0 01       	movw	r26, r0
    3358:	c9 9f       	mul	r28, r25
    335a:	b0 0d       	add	r27, r0
    335c:	d8 9f       	mul	r29, r24
    335e:	b0 0d       	add	r27, r0
    3360:	11 24       	eor	r1, r1
    3362:	ab 58       	subi	r26, 0x8B	; 139
    3364:	bc 4f       	sbci	r27, 0xFC	; 252
    3366:	1a 96       	adiw	r26, 0x0a	; 10
    3368:	cc 90       	ld	r12, X
    336a:	ea 01       	movw	r28, r20
    336c:	cc 19       	sub	r28, r12
    336e:	d1 09       	sbc	r29, r1
    3370:	a7 2f       	mov	r26, r23
    3372:	b0 e0       	ldi	r27, 0x00	; 0
    3374:	ac 17       	cp	r26, r28
    3376:	bd 07       	cpc	r27, r29
    3378:	1c f4       	brge	.+6      	; 0x3380 <uip_arp_update+0x182>
	tmpage = arptime - tabptr->time;
    337a:	70 2f       	mov	r23, r16
    337c:	7c 19       	sub	r23, r12
	c = i;
    337e:	23 2f       	mov	r18, r19
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
    3380:	3f 5f       	subi	r19, 0xFF	; 255
  /* If no unused entry is found, we try to find the oldest entry and
     throw it away. */
  if(i == UIP_ARPTAB_SIZE) {
    tmpage = 0;
    c = 0;
    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3382:	38 30       	cpi	r19, 0x08	; 8
    3384:	28 f3       	brcs	.-54     	; 0x3350 <uip_arp_update+0x152>
    3386:	70 93 ce 03 	sts	0x03CE, r23
    338a:	20 93 cf 03 	sts	0x03CF, r18
      if(arptime - tabptr->time > tmpage) {
	tmpage = arptime - tabptr->time;
	c = i;
      }
    }
    i = c;
    338e:	20 93 74 03 	sts	0x0374, r18
    tabptr = &arp_table[i];
    3392:	30 e0       	ldi	r19, 0x00	; 0
    3394:	8b e0       	ldi	r24, 0x0B	; 11
    3396:	90 e0       	ldi	r25, 0x00	; 0
    3398:	28 9f       	mul	r18, r24
    339a:	d0 01       	movw	r26, r0
    339c:	29 9f       	mul	r18, r25
    339e:	b0 0d       	add	r27, r0
    33a0:	38 9f       	mul	r19, r24
    33a2:	b0 0d       	add	r27, r0
    33a4:	11 24       	eor	r1, r1
    33a6:	ab 58       	subi	r26, 0x8B	; 139
    33a8:	bc 4f       	sbci	r27, 0xFC	; 252
  }

  /* Now, i is the ARP table entry which we will fill with the new
     information. */
  uip_ipaddr_copy(&tabptr->ipaddr, ipaddr);
    33aa:	20 81       	ld	r18, Z
    33ac:	31 81       	ldd	r19, Z+1	; 0x01
    33ae:	42 81       	ldd	r20, Z+2	; 0x02
    33b0:	53 81       	ldd	r21, Z+3	; 0x03
    33b2:	fd 01       	movw	r30, r26
    33b4:	21 93       	st	Z+, r18
    33b6:	31 93       	st	Z+, r19
    33b8:	41 93       	st	Z+, r20
    33ba:	51 93       	st	Z+, r21
  memcpy(tabptr->ethaddr.addr, ethaddr->addr, 6);
    33bc:	86 2f       	mov	r24, r22
    33be:	9f 2d       	mov	r25, r15
    33c0:	ec 01       	movw	r28, r24
    33c2:	86 e0       	ldi	r24, 0x06	; 6
    33c4:	09 90       	ld	r0, Y+
    33c6:	01 92       	st	Z+, r0
    33c8:	81 50       	subi	r24, 0x01	; 1
    33ca:	e1 f7       	brne	.-8      	; 0x33c4 <uip_arp_update+0x1c6>
  tabptr->time = arptime;
    33cc:	80 91 cd 03 	lds	r24, 0x03CD
    33d0:	1a 96       	adiw	r26, 0x0a	; 10
    33d2:	8c 93       	st	X, r24
    33d4:	1a 97       	sbiw	r26, 0x0a	; 10
}
    33d6:	df 91       	pop	r29
    33d8:	cf 91       	pop	r28
    33da:	1f 91       	pop	r17
    33dc:	0f 91       	pop	r16
    33de:	ff 90       	pop	r15
    33e0:	df 90       	pop	r13
    33e2:	cf 90       	pop	r12
    33e4:	08 95       	ret

000033e6 <uip_arp_init>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33e6:	10 92 74 03 	sts	0x0374, r1
    memset(&arp_table[i].ipaddr, 0, 4);
    33ea:	8b e0       	ldi	r24, 0x0B	; 11
    33ec:	90 e0       	ldi	r25, 0x00	; 0
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    33ee:	12 c0       	rjmp	.+36     	; 0x3414 <uip_arp_init+0x2e>
    memset(&arp_table[i].ipaddr, 0, 4);
    33f0:	24 2f       	mov	r18, r20
    33f2:	30 e0       	ldi	r19, 0x00	; 0
    33f4:	28 9f       	mul	r18, r24
    33f6:	f0 01       	movw	r30, r0
    33f8:	29 9f       	mul	r18, r25
    33fa:	f0 0d       	add	r31, r0
    33fc:	38 9f       	mul	r19, r24
    33fe:	f0 0d       	add	r31, r0
    3400:	11 24       	eor	r1, r1
    3402:	eb 58       	subi	r30, 0x8B	; 139
    3404:	fc 4f       	sbci	r31, 0xFC	; 252
    3406:	10 82       	st	Z, r1
    3408:	11 82       	std	Z+1, r1	; 0x01
    340a:	12 82       	std	Z+2, r1	; 0x02
    340c:	13 82       	std	Z+3, r1	; 0x03
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_init(void)
{
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    340e:	4f 5f       	subi	r20, 0xFF	; 255
    3410:	40 93 74 03 	sts	0x0374, r20
    3414:	40 91 74 03 	lds	r20, 0x0374
    3418:	48 30       	cpi	r20, 0x08	; 8
    341a:	50 f3       	brcs	.-44     	; 0x33f0 <uip_arp_init+0xa>
    memset(&arp_table[i].ipaddr, 0, 4);
  }
}
    341c:	08 95       	ret

0000341e <uip_arp_timer>:
void
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
    341e:	80 91 cd 03 	lds	r24, 0x03CD
    3422:	8f 5f       	subi	r24, 0xFF	; 255
    3424:	80 93 cd 03 	sts	0x03CD, r24
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3428:	10 92 74 03 	sts	0x0374, r1
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    342c:	6b e0       	ldi	r22, 0x0B	; 11
    342e:	70 e0       	ldi	r23, 0x00	; 0
    3430:	40 91 24 03 	lds	r20, 0x0324
    3434:	50 91 25 03 	lds	r21, 0x0325
    3438:	20 91 26 03 	lds	r18, 0x0326
    343c:	30 91 27 03 	lds	r19, 0x0327
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3440:	25 c0       	rjmp	.+74     	; 0x348c <uip_arp_timer+0x6e>
    tabptr = &arp_table[i];
    3442:	8a 2f       	mov	r24, r26
    3444:	90 e0       	ldi	r25, 0x00	; 0
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3446:	86 9f       	mul	r24, r22
    3448:	f0 01       	movw	r30, r0
    344a:	87 9f       	mul	r24, r23
    344c:	f0 0d       	add	r31, r0
    344e:	96 9f       	mul	r25, r22
    3450:	f0 0d       	add	r31, r0
    3452:	11 24       	eor	r1, r1
    3454:	eb 58       	subi	r30, 0x8B	; 139
    3456:	fc 4f       	sbci	r31, 0xFC	; 252
    3458:	80 81       	ld	r24, Z
    345a:	91 81       	ldd	r25, Z+1	; 0x01
    345c:	84 17       	cp	r24, r20
    345e:	95 07       	cpc	r25, r21
    3460:	91 f4       	brne	.+36     	; 0x3486 <uip_arp_timer+0x68>
    3462:	82 81       	ldd	r24, Z+2	; 0x02
    3464:	93 81       	ldd	r25, Z+3	; 0x03
    3466:	82 17       	cp	r24, r18
    3468:	93 07       	cpc	r25, r19
    346a:	69 f4       	brne	.+26     	; 0x3486 <uip_arp_timer+0x68>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
    346c:	80 91 cd 03 	lds	r24, 0x03CD
    3470:	90 e0       	ldi	r25, 0x00	; 0
    3472:	b2 85       	ldd	r27, Z+10	; 0x0a
    3474:	8b 1b       	sub	r24, r27
    3476:	91 09       	sbc	r25, r1
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    tabptr = &arp_table[i];
    if(uip_ipaddr_cmp(&tabptr->ipaddr, &uip_all_zeroes_addr) &&
    3478:	88 37       	cpi	r24, 0x78	; 120
    347a:	91 05       	cpc	r25, r1
    347c:	24 f0       	brlt	.+8      	; 0x3486 <uip_arp_timer+0x68>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    347e:	10 82       	st	Z, r1
    3480:	11 82       	std	Z+1, r1	; 0x01
    3482:	12 82       	std	Z+2, r1	; 0x02
    3484:	13 82       	std	Z+3, r1	; 0x03
uip_arp_timer(void)
{
  struct arp_entry *tabptr = NULL;

  ++arptime;
  for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    3486:	af 5f       	subi	r26, 0xFF	; 255
    3488:	a0 93 74 03 	sts	0x0374, r26
    348c:	a0 91 74 03 	lds	r26, 0x0374
    3490:	a8 30       	cpi	r26, 0x08	; 8
    3492:	b8 f2       	brcs	.-82     	; 0x3442 <uip_arp_timer+0x24>
       arptime - tabptr->time >= UIP_ARP_MAXAGE) {
      memset(&tabptr->ipaddr, 0, 4);
    }
  }

}
    3494:	08 95       	ret

00003496 <uip_arp_arpin>:
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_arpin(void)
{
  if(uip_len < sizeof(struct arp_hdr)) {
    3496:	80 91 25 06 	lds	r24, 0x0625
    349a:	90 91 26 06 	lds	r25, 0x0626
    349e:	8a 32       	cpi	r24, 0x2A	; 42
    34a0:	91 05       	cpc	r25, r1
    34a2:	28 f4       	brcc	.+10     	; 0x34ae <uip_arp_arpin+0x18>
    uip_len = 0;
    34a4:	10 92 26 06 	sts	0x0626, r1
    34a8:	10 92 25 06 	sts	0x0625, r1
    return;
    34ac:	08 95       	ret
  }
  uip_len = 0;
    34ae:	10 92 26 06 	sts	0x0626, r1
    34b2:	10 92 25 06 	sts	0x0625, r1

  switch(BUF->opcode) {
    34b6:	80 91 b1 07 	lds	r24, 0x07B1
    34ba:	90 91 b2 07 	lds	r25, 0x07B2
    34be:	21 e0       	ldi	r18, 0x01	; 1
    34c0:	80 30       	cpi	r24, 0x00	; 0
    34c2:	92 07       	cpc	r25, r18
    34c4:	31 f0       	breq	.+12     	; 0x34d2 <uip_arp_arpin+0x3c>
    34c6:	22 e0       	ldi	r18, 0x02	; 2
    34c8:	80 30       	cpi	r24, 0x00	; 0
    34ca:	92 07       	cpc	r25, r18
    34cc:	09 f0       	breq	.+2      	; 0x34d0 <uip_arp_arpin+0x3a>
    34ce:	90 c0       	rjmp	.+288    	; 0x35f0 <uip_arp_arpin+0x15a>
    34d0:	74 c0       	rjmp	.+232    	; 0x35ba <uip_arp_arpin+0x124>
    PRINTF("uip_arp_arpin: request for %d.%d.%d.%d (we are %d.%d.%d.%d)\n",
	   BUF->dipaddr.u8[0], BUF->dipaddr.u8[1],
	   BUF->dipaddr.u8[2], BUF->dipaddr.u8[3],
	   uip_hostaddr.u8[0], uip_hostaddr.u8[1],
	   uip_hostaddr.u8[2], uip_hostaddr.u8[3]);
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    34d2:	20 91 c3 07 	lds	r18, 0x07C3
    34d6:	30 91 c4 07 	lds	r19, 0x07C4
    34da:	80 91 99 07 	lds	r24, 0x0799
    34de:	90 91 9a 07 	lds	r25, 0x079A
    34e2:	28 17       	cp	r18, r24
    34e4:	39 07       	cpc	r19, r25
    34e6:	09 f0       	breq	.+2      	; 0x34ea <uip_arp_arpin+0x54>
    34e8:	83 c0       	rjmp	.+262    	; 0x35f0 <uip_arp_arpin+0x15a>
    34ea:	20 91 c5 07 	lds	r18, 0x07C5
    34ee:	30 91 c6 07 	lds	r19, 0x07C6
    34f2:	80 91 9b 07 	lds	r24, 0x079B
    34f6:	90 91 9c 07 	lds	r25, 0x079C
    34fa:	28 17       	cp	r18, r24
    34fc:	39 07       	cpc	r19, r25
    34fe:	09 f0       	breq	.+2      	; 0x3502 <uip_arp_arpin+0x6c>
    3500:	77 c0       	rjmp	.+238    	; 0x35f0 <uip_arp_arpin+0x15a>
      /* First, we register the one who made the request in our ARP
	 table, since it is likely that we will do more communication
	 with this host in the future. */
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    3502:	89 eb       	ldi	r24, 0xB9	; 185
    3504:	97 e0       	ldi	r25, 0x07	; 7
    3506:	63 eb       	ldi	r22, 0xB3	; 179
    3508:	77 e0       	ldi	r23, 0x07	; 7
    350a:	79 de       	rcall	.-782    	; 0x31fe <uip_arp_update>

      BUF->opcode = HTONS(ARP_REPLY);
    350c:	80 e0       	ldi	r24, 0x00	; 0
    350e:	92 e0       	ldi	r25, 0x02	; 2
    3510:	90 93 b2 07 	sts	0x07B2, r25
    3514:	80 93 b1 07 	sts	0x07B1, r24

      memcpy(BUF->dhwaddr.addr, BUF->shwaddr.addr, 6);
    3518:	ed eb       	ldi	r30, 0xBD	; 189
    351a:	f7 e0       	ldi	r31, 0x07	; 7
    351c:	df 01       	movw	r26, r30
    351e:	1a 97       	sbiw	r26, 0x0a	; 10
    3520:	86 e0       	ldi	r24, 0x06	; 6
    3522:	0d 90       	ld	r0, X+
    3524:	01 92       	st	Z+, r0
    3526:	81 50       	subi	r24, 0x01	; 1
    3528:	e1 f7       	brne	.-8      	; 0x3522 <uip_arp_arpin+0x8c>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    352a:	a3 eb       	ldi	r26, 0xB3	; 179
    352c:	b7 e0       	ldi	r27, 0x07	; 7
    352e:	ee e5       	ldi	r30, 0x5E	; 94
    3530:	f3 e0       	ldi	r31, 0x03	; 3
    3532:	86 e0       	ldi	r24, 0x06	; 6
    3534:	01 90       	ld	r0, Z+
    3536:	0d 92       	st	X+, r0
    3538:	81 50       	subi	r24, 0x01	; 1
    353a:	e1 f7       	brne	.-8      	; 0x3534 <uip_arp_arpin+0x9e>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    353c:	a3 ea       	ldi	r26, 0xA3	; 163
    353e:	b7 e0       	ldi	r27, 0x07	; 7
    3540:	ee e5       	ldi	r30, 0x5E	; 94
    3542:	f3 e0       	ldi	r31, 0x03	; 3
    3544:	86 e0       	ldi	r24, 0x06	; 6
    3546:	01 90       	ld	r0, Z+
    3548:	0d 92       	st	X+, r0
    354a:	81 50       	subi	r24, 0x01	; 1
    354c:	e1 f7       	brne	.-8      	; 0x3546 <uip_arp_arpin+0xb0>
      memcpy(BUF->ethhdr.dest.addr, BUF->dhwaddr.addr, 6);
    354e:	ed e9       	ldi	r30, 0x9D	; 157
    3550:	f7 e0       	ldi	r31, 0x07	; 7
    3552:	df 01       	movw	r26, r30
    3554:	90 96       	adiw	r26, 0x20	; 32
    3556:	86 e0       	ldi	r24, 0x06	; 6
    3558:	0d 90       	ld	r0, X+
    355a:	01 92       	st	Z+, r0
    355c:	81 50       	subi	r24, 0x01	; 1
    355e:	e1 f7       	brne	.-8      	; 0x3558 <uip_arp_arpin+0xc2>

      uip_ipaddr_copy(&BUF->dipaddr, &BUF->sipaddr);
    3560:	80 91 b9 07 	lds	r24, 0x07B9
    3564:	90 91 ba 07 	lds	r25, 0x07BA
    3568:	a0 91 bb 07 	lds	r26, 0x07BB
    356c:	b0 91 bc 07 	lds	r27, 0x07BC
    3570:	80 93 c3 07 	sts	0x07C3, r24
    3574:	90 93 c4 07 	sts	0x07C4, r25
    3578:	a0 93 c5 07 	sts	0x07C5, r26
    357c:	b0 93 c6 07 	sts	0x07C6, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    3580:	80 91 99 07 	lds	r24, 0x0799
    3584:	90 91 9a 07 	lds	r25, 0x079A
    3588:	a0 91 9b 07 	lds	r26, 0x079B
    358c:	b0 91 9c 07 	lds	r27, 0x079C
    3590:	80 93 b9 07 	sts	0x07B9, r24
    3594:	90 93 ba 07 	sts	0x07BA, r25
    3598:	a0 93 bb 07 	sts	0x07BB, r26
    359c:	b0 93 bc 07 	sts	0x07BC, r27

      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    35a0:	88 e0       	ldi	r24, 0x08	; 8
    35a2:	96 e0       	ldi	r25, 0x06	; 6
    35a4:	90 93 aa 07 	sts	0x07AA, r25
    35a8:	80 93 a9 07 	sts	0x07A9, r24
      uip_len = sizeof(struct arp_hdr);
    35ac:	8a e2       	ldi	r24, 0x2A	; 42
    35ae:	90 e0       	ldi	r25, 0x00	; 0
    35b0:	90 93 26 06 	sts	0x0626, r25
    35b4:	80 93 25 06 	sts	0x0625, r24
    35b8:	08 95       	ret
    }
    break;
  case HTONS(ARP_REPLY):
    /* ARP reply. We insert or update the ARP table if it was meant
       for us. */
    if(uip_ipaddr_cmp(&BUF->dipaddr, &uip_hostaddr)) {
    35ba:	20 91 c3 07 	lds	r18, 0x07C3
    35be:	30 91 c4 07 	lds	r19, 0x07C4
    35c2:	80 91 99 07 	lds	r24, 0x0799
    35c6:	90 91 9a 07 	lds	r25, 0x079A
    35ca:	28 17       	cp	r18, r24
    35cc:	39 07       	cpc	r19, r25
    35ce:	81 f4       	brne	.+32     	; 0x35f0 <uip_arp_arpin+0x15a>
    35d0:	20 91 c5 07 	lds	r18, 0x07C5
    35d4:	30 91 c6 07 	lds	r19, 0x07C6
    35d8:	80 91 9b 07 	lds	r24, 0x079B
    35dc:	90 91 9c 07 	lds	r25, 0x079C
    35e0:	28 17       	cp	r18, r24
    35e2:	39 07       	cpc	r19, r25
    35e4:	29 f4       	brne	.+10     	; 0x35f0 <uip_arp_arpin+0x15a>
      uip_arp_update(&BUF->sipaddr, &BUF->shwaddr);
    35e6:	89 eb       	ldi	r24, 0xB9	; 185
    35e8:	97 e0       	ldi	r25, 0x07	; 7
    35ea:	63 eb       	ldi	r22, 0xB3	; 179
    35ec:	77 e0       	ldi	r23, 0x07	; 7
    35ee:	07 ce       	rjmp	.-1010   	; 0x31fe <uip_arp_update>
    35f0:	08 95       	ret

000035f2 <uip_arp_out>:

     If not ARP table entry is found, we overwrite the original IP
     packet with an ARP request for the IP address. */

  /* First check if destination is a local broadcast. */
  if(uip_ipaddr_cmp(&IPBUF->destipaddr, &uip_broadcast_addr)) {
    35f2:	20 91 bb 07 	lds	r18, 0x07BB
    35f6:	30 91 bc 07 	lds	r19, 0x07BC
    35fa:	80 91 20 03 	lds	r24, 0x0320
    35fe:	90 91 21 03 	lds	r25, 0x0321
    3602:	28 17       	cp	r18, r24
    3604:	39 07       	cpc	r19, r25
    3606:	a9 f4       	brne	.+42     	; 0x3632 <uip_arp_out+0x40>
    3608:	20 91 bd 07 	lds	r18, 0x07BD
    360c:	30 91 be 07 	lds	r19, 0x07BE
    3610:	80 91 22 03 	lds	r24, 0x0322
    3614:	90 91 23 03 	lds	r25, 0x0323
    3618:	28 17       	cp	r18, r24
    361a:	39 07       	cpc	r19, r25
    361c:	51 f4       	brne	.+20     	; 0x3632 <uip_arp_out+0x40>
    memcpy(IPBUF->ethhdr.dest.addr, broadcast_ethaddr.addr, 6);
    361e:	ad e9       	ldi	r26, 0x9D	; 157
    3620:	b7 e0       	ldi	r27, 0x07	; 7
    3622:	e8 e2       	ldi	r30, 0x28	; 40
    3624:	f3 e0       	ldi	r31, 0x03	; 3
    3626:	86 e0       	ldi	r24, 0x06	; 6
    3628:	01 90       	ld	r0, Z+
    362a:	0d 92       	st	X+, r0
    362c:	81 50       	subi	r24, 0x01	; 1
    362e:	e1 f7       	brne	.-8      	; 0x3628 <uip_arp_out+0x36>
    3630:	d7 c0       	rjmp	.+430    	; 0x37e0 <uip_arp_out+0x1ee>
  } else {
    /* Check if the destination address is on the local network. */
    if(!uip_ipaddr_maskcmp(&IPBUF->destipaddr, &uip_hostaddr, &uip_netmask)) {
    3632:	80 91 bb 07 	lds	r24, 0x07BB
    3636:	90 91 bc 07 	lds	r25, 0x07BC
    363a:	20 91 99 07 	lds	r18, 0x0799
    363e:	30 91 9a 07 	lds	r19, 0x079A
    3642:	82 27       	eor	r24, r18
    3644:	93 27       	eor	r25, r19
    3646:	20 91 95 07 	lds	r18, 0x0795
    364a:	30 91 96 07 	lds	r19, 0x0796
    364e:	82 23       	and	r24, r18
    3650:	93 23       	and	r25, r19
    3652:	00 97       	sbiw	r24, 0x00	; 0
    3654:	91 f4       	brne	.+36     	; 0x367a <uip_arp_out+0x88>
    3656:	80 91 bd 07 	lds	r24, 0x07BD
    365a:	90 91 be 07 	lds	r25, 0x07BE
    365e:	20 91 9b 07 	lds	r18, 0x079B
    3662:	30 91 9c 07 	lds	r19, 0x079C
    3666:	82 27       	eor	r24, r18
    3668:	93 27       	eor	r25, r19
    366a:	20 91 97 07 	lds	r18, 0x0797
    366e:	30 91 98 07 	lds	r19, 0x0798
    3672:	82 23       	and	r24, r18
    3674:	93 23       	and	r25, r19
    3676:	00 97       	sbiw	r24, 0x00	; 0
    3678:	49 f0       	breq	.+18     	; 0x368c <uip_arp_out+0x9a>
      /* Destination address was not on the local network, so we need to
	 use the default router's IP address instead of the destination
	 address when determining the MAC address. */
      uip_ipaddr_copy(&ipaddr, &uip_draddr);
    367a:	80 91 91 07 	lds	r24, 0x0791
    367e:	90 91 92 07 	lds	r25, 0x0792
    3682:	a0 91 93 07 	lds	r26, 0x0793
    3686:	b0 91 94 07 	lds	r27, 0x0794
    368a:	08 c0       	rjmp	.+16     	; 0x369c <uip_arp_out+0xaa>
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    368c:	80 91 bb 07 	lds	r24, 0x07BB
    3690:	90 91 bc 07 	lds	r25, 0x07BC
    3694:	a0 91 bd 07 	lds	r26, 0x07BD
    3698:	b0 91 be 07 	lds	r27, 0x07BE
    369c:	80 93 70 03 	sts	0x0370, r24
    36a0:	90 93 71 03 	sts	0x0371, r25
    36a4:	a0 93 72 03 	sts	0x0372, r26
    36a8:	b0 93 73 03 	sts	0x0373, r27
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36ac:	10 92 74 03 	sts	0x0374, r1
      tabptr = &arp_table[i];
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    36b0:	40 91 70 03 	lds	r20, 0x0370
    36b4:	50 91 71 03 	lds	r21, 0x0371
    36b8:	20 91 72 03 	lds	r18, 0x0372
    36bc:	30 91 73 03 	lds	r19, 0x0373
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36c0:	a0 e0       	ldi	r26, 0x00	; 0
 */
/*-----------------------------------------------------------------------------------*/
void
uip_arp_out(void)
{
  struct arp_entry *tabptr = NULL;
    36c2:	e0 e0       	ldi	r30, 0x00	; 0
    36c4:	f0 e0       	ldi	r31, 0x00	; 0
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
      tabptr = &arp_table[i];
    36c6:	8b e0       	ldi	r24, 0x0B	; 11
    36c8:	90 e0       	ldi	r25, 0x00	; 0
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36ca:	16 c0       	rjmp	.+44     	; 0x36f8 <uip_arp_out+0x106>
      tabptr = &arp_table[i];
    36cc:	6a 2f       	mov	r22, r26
    36ce:	70 e0       	ldi	r23, 0x00	; 0
    36d0:	68 9f       	mul	r22, r24
    36d2:	f0 01       	movw	r30, r0
    36d4:	69 9f       	mul	r22, r25
    36d6:	f0 0d       	add	r31, r0
    36d8:	78 9f       	mul	r23, r24
    36da:	f0 0d       	add	r31, r0
    36dc:	11 24       	eor	r1, r1
    36de:	eb 58       	subi	r30, 0x8B	; 139
    36e0:	fc 4f       	sbci	r31, 0xFC	; 252
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
    36e2:	60 81       	ld	r22, Z
    36e4:	71 81       	ldd	r23, Z+1	; 0x01
    36e6:	46 17       	cp	r20, r22
    36e8:	57 07       	cpc	r21, r23
    36ea:	29 f4       	brne	.+10     	; 0x36f6 <uip_arp_out+0x104>
    36ec:	62 81       	ldd	r22, Z+2	; 0x02
    36ee:	73 81       	ldd	r23, Z+3	; 0x03
    36f0:	26 17       	cp	r18, r22
    36f2:	37 07       	cpc	r19, r23
    36f4:	19 f0       	breq	.+6      	; 0x36fc <uip_arp_out+0x10a>
    36f6:	af 5f       	subi	r26, 0xFF	; 255
    } else {
      /* Else, we use the destination IP address. */
      uip_ipaddr_copy(&ipaddr, &IPBUF->destipaddr);
    }

    for(i = 0; i < UIP_ARPTAB_SIZE; ++i) {
    36f8:	a8 30       	cpi	r26, 0x08	; 8
    36fa:	40 f3       	brcs	.-48     	; 0x36cc <uip_arp_out+0xda>
    36fc:	a0 93 74 03 	sts	0x0374, r26
      if(uip_ipaddr_cmp(&ipaddr, &tabptr->ipaddr)) {
	break;
      }
    }

    if(i == UIP_ARPTAB_SIZE) {
    3700:	a8 30       	cpi	r26, 0x08	; 8
    3702:	09 f0       	breq	.+2      	; 0x3706 <uip_arp_out+0x114>
    3704:	65 c0       	rjmp	.+202    	; 0x37d0 <uip_arp_out+0x1de>
      /* The destination address was not in our ARP table, so we
	 overwrite the IP packet with an ARP request. */

      memset(BUF->ethhdr.dest.addr, 0xff, 6);
    3706:	8d e9       	ldi	r24, 0x9D	; 157
    3708:	97 e0       	ldi	r25, 0x07	; 7
    370a:	6f ef       	ldi	r22, 0xFF	; 255
    370c:	70 e0       	ldi	r23, 0x00	; 0
    370e:	46 e0       	ldi	r20, 0x06	; 6
    3710:	50 e0       	ldi	r21, 0x00	; 0
    3712:	0e 94 13 3d 	call	0x7a26	; 0x7a26 <memset>
      memset(BUF->dhwaddr.addr, 0x00, 6);
    3716:	ad eb       	ldi	r26, 0xBD	; 189
    3718:	b7 e0       	ldi	r27, 0x07	; 7
    371a:	86 e0       	ldi	r24, 0x06	; 6
    371c:	fd 01       	movw	r30, r26
    371e:	11 92       	st	Z+, r1
    3720:	8a 95       	dec	r24
    3722:	e9 f7       	brne	.-6      	; 0x371e <uip_arp_out+0x12c>
      memcpy(BUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    3724:	5a 97       	sbiw	r26, 0x1a	; 26
    3726:	ee e5       	ldi	r30, 0x5E	; 94
    3728:	f3 e0       	ldi	r31, 0x03	; 3
    372a:	86 e0       	ldi	r24, 0x06	; 6
    372c:	01 90       	ld	r0, Z+
    372e:	0d 92       	st	X+, r0
    3730:	81 50       	subi	r24, 0x01	; 1
    3732:	e1 f7       	brne	.-8      	; 0x372c <uip_arp_out+0x13a>
      memcpy(BUF->shwaddr.addr, uip_ethaddr.addr, 6);
    3734:	a3 eb       	ldi	r26, 0xB3	; 179
    3736:	b7 e0       	ldi	r27, 0x07	; 7
    3738:	ee e5       	ldi	r30, 0x5E	; 94
    373a:	f3 e0       	ldi	r31, 0x03	; 3
    373c:	86 e0       	ldi	r24, 0x06	; 6
    373e:	01 90       	ld	r0, Z+
    3740:	0d 92       	st	X+, r0
    3742:	81 50       	subi	r24, 0x01	; 1
    3744:	e1 f7       	brne	.-8      	; 0x373e <uip_arp_out+0x14c>

      uip_ipaddr_copy(&BUF->dipaddr, &ipaddr);
    3746:	80 91 70 03 	lds	r24, 0x0370
    374a:	90 91 71 03 	lds	r25, 0x0371
    374e:	a0 91 72 03 	lds	r26, 0x0372
    3752:	b0 91 73 03 	lds	r27, 0x0373
    3756:	80 93 c3 07 	sts	0x07C3, r24
    375a:	90 93 c4 07 	sts	0x07C4, r25
    375e:	a0 93 c5 07 	sts	0x07C5, r26
    3762:	b0 93 c6 07 	sts	0x07C6, r27
      uip_ipaddr_copy(&BUF->sipaddr, &uip_hostaddr);
    3766:	80 91 99 07 	lds	r24, 0x0799
    376a:	90 91 9a 07 	lds	r25, 0x079A
    376e:	a0 91 9b 07 	lds	r26, 0x079B
    3772:	b0 91 9c 07 	lds	r27, 0x079C
    3776:	80 93 b9 07 	sts	0x07B9, r24
    377a:	90 93 ba 07 	sts	0x07BA, r25
    377e:	a0 93 bb 07 	sts	0x07BB, r26
    3782:	b0 93 bc 07 	sts	0x07BC, r27
      BUF->opcode = HTONS(ARP_REQUEST); /* ARP request. */
    3786:	80 e0       	ldi	r24, 0x00	; 0
    3788:	91 e0       	ldi	r25, 0x01	; 1
    378a:	90 93 b2 07 	sts	0x07B2, r25
    378e:	80 93 b1 07 	sts	0x07B1, r24
      BUF->hwtype = HTONS(ARP_HWTYPE_ETH);
    3792:	90 93 ac 07 	sts	0x07AC, r25
    3796:	80 93 ab 07 	sts	0x07AB, r24
      BUF->protocol = HTONS(UIP_ETHTYPE_IP);
    379a:	88 e0       	ldi	r24, 0x08	; 8
    379c:	90 e0       	ldi	r25, 0x00	; 0
    379e:	90 93 ae 07 	sts	0x07AE, r25
    37a2:	80 93 ad 07 	sts	0x07AD, r24
      BUF->hwlen = 6;
    37a6:	86 e0       	ldi	r24, 0x06	; 6
    37a8:	80 93 af 07 	sts	0x07AF, r24
      BUF->protolen = 4;
    37ac:	84 e0       	ldi	r24, 0x04	; 4
    37ae:	80 93 b0 07 	sts	0x07B0, r24
      BUF->ethhdr.type = HTONS(UIP_ETHTYPE_ARP);
    37b2:	88 e0       	ldi	r24, 0x08	; 8
    37b4:	96 e0       	ldi	r25, 0x06	; 6
    37b6:	90 93 aa 07 	sts	0x07AA, r25
    37ba:	80 93 a9 07 	sts	0x07A9, r24

      uip_appdata = &uip_buf[UIP_TCPIP_HLEN + UIP_LLH_LEN];
    37be:	83 ed       	ldi	r24, 0xD3	; 211
    37c0:	97 e0       	ldi	r25, 0x07	; 7
    37c2:	90 93 31 06 	sts	0x0631, r25
    37c6:	80 93 30 06 	sts	0x0630, r24

      uip_len = sizeof(struct arp_hdr);
    37ca:	8a e2       	ldi	r24, 0x2A	; 42
    37cc:	90 e0       	ldi	r25, 0x00	; 0
    37ce:	1c c0       	rjmp	.+56     	; 0x3808 <uip_arp_out+0x216>
      return;
    }

    /* Build an ethernet header. */
    memcpy(IPBUF->ethhdr.dest.addr, tabptr->ethaddr.addr, 6);
    37d0:	ad e9       	ldi	r26, 0x9D	; 157
    37d2:	b7 e0       	ldi	r27, 0x07	; 7
    37d4:	34 96       	adiw	r30, 0x04	; 4
    37d6:	86 e0       	ldi	r24, 0x06	; 6
    37d8:	01 90       	ld	r0, Z+
    37da:	0d 92       	st	X+, r0
    37dc:	81 50       	subi	r24, 0x01	; 1
    37de:	e1 f7       	brne	.-8      	; 0x37d8 <uip_arp_out+0x1e6>
  }
  memcpy(IPBUF->ethhdr.src.addr, uip_ethaddr.addr, 6);
    37e0:	a3 ea       	ldi	r26, 0xA3	; 163
    37e2:	b7 e0       	ldi	r27, 0x07	; 7
    37e4:	ee e5       	ldi	r30, 0x5E	; 94
    37e6:	f3 e0       	ldi	r31, 0x03	; 3
    37e8:	86 e0       	ldi	r24, 0x06	; 6
    37ea:	01 90       	ld	r0, Z+
    37ec:	0d 92       	st	X+, r0
    37ee:	81 50       	subi	r24, 0x01	; 1
    37f0:	e1 f7       	brne	.-8      	; 0x37ea <uip_arp_out+0x1f8>

  IPBUF->ethhdr.type = HTONS(UIP_ETHTYPE_IP);
    37f2:	88 e0       	ldi	r24, 0x08	; 8
    37f4:	90 e0       	ldi	r25, 0x00	; 0
    37f6:	90 93 aa 07 	sts	0x07AA, r25
    37fa:	80 93 a9 07 	sts	0x07A9, r24

  uip_len += sizeof(struct uip_eth_hdr);
    37fe:	80 91 25 06 	lds	r24, 0x0625
    3802:	90 91 26 06 	lds	r25, 0x0626
    3806:	0e 96       	adiw	r24, 0x0e	; 14
    3808:	90 93 26 06 	sts	0x0626, r25
    380c:	80 93 25 06 	sts	0x0625, r24
    3810:	08 95       	ret

00003812 <timer_set>:
 * \param interval The interval before the timer expires.
 *
 */
void
timer_set(struct timer *t, clock_time_t interval)
{
    3812:	cf 93       	push	r28
    3814:	df 93       	push	r29
    3816:	ec 01       	movw	r28, r24
  t->interval = interval;
    3818:	7b 83       	std	Y+3, r23	; 0x03
    381a:	6a 83       	std	Y+2, r22	; 0x02
  t->start = clock_time();
    381c:	49 d0       	rcall	.+146    	; 0x38b0 <clock_time>
    381e:	99 83       	std	Y+1, r25	; 0x01
    3820:	88 83       	st	Y, r24
}
    3822:	df 91       	pop	r29
    3824:	cf 91       	pop	r28
    3826:	08 95       	ret

00003828 <timer_reset>:
 *
 * \sa timer_restart()
 */
void
timer_reset(struct timer *t)
{
    3828:	fc 01       	movw	r30, r24
  t->start += t->interval;
    382a:	80 81       	ld	r24, Z
    382c:	91 81       	ldd	r25, Z+1	; 0x01
    382e:	22 81       	ldd	r18, Z+2	; 0x02
    3830:	33 81       	ldd	r19, Z+3	; 0x03
    3832:	82 0f       	add	r24, r18
    3834:	93 1f       	adc	r25, r19
    3836:	91 83       	std	Z+1, r25	; 0x01
    3838:	80 83       	st	Z, r24
}
    383a:	08 95       	ret

0000383c <timer_expired>:
 * \return Non-zero if the timer has expired, zero otherwise.
 *
 */
int
timer_expired(struct timer *t)
{
    383c:	cf 93       	push	r28
    383e:	df 93       	push	r29
    3840:	ec 01       	movw	r28, r24
  return (clock_time_t)(clock_time() - t->start) >= (clock_time_t)t->interval;
    3842:	36 d0       	rcall	.+108    	; 0x38b0 <clock_time>
    3844:	28 81       	ld	r18, Y
    3846:	39 81       	ldd	r19, Y+1	; 0x01
    3848:	ac 01       	movw	r20, r24
    384a:	42 1b       	sub	r20, r18
    384c:	53 0b       	sbc	r21, r19
    384e:	21 e0       	ldi	r18, 0x01	; 1
    3850:	30 e0       	ldi	r19, 0x00	; 0
    3852:	8a 81       	ldd	r24, Y+2	; 0x02
    3854:	9b 81       	ldd	r25, Y+3	; 0x03
    3856:	48 17       	cp	r20, r24
    3858:	59 07       	cpc	r21, r25
    385a:	10 f4       	brcc	.+4      	; 0x3860 <timer_expired+0x24>
    385c:	20 e0       	ldi	r18, 0x00	; 0
    385e:	30 e0       	ldi	r19, 0x00	; 0
}
    3860:	c9 01       	movw	r24, r18
    3862:	df 91       	pop	r29
    3864:	cf 91       	pop	r28
    3866:	08 95       	ret

00003868 <__vector_17>:
//Counted time
volatile clock_time_t clock_datetime = 0;

//Overflow interrupt
ISR(TIMER1_COMPA_vect, ISR_BLOCK)
{
    3868:	1f 92       	push	r1
    386a:	0f 92       	push	r0
    386c:	0f b6       	in	r0, 0x3f	; 63
    386e:	0f 92       	push	r0
    3870:	11 24       	eor	r1, r1
    3872:	8f 93       	push	r24
    3874:	9f 93       	push	r25
	clock_datetime += 1;
    3876:	80 91 d0 03 	lds	r24, 0x03D0
    387a:	90 91 d1 03 	lds	r25, 0x03D1
    387e:	01 96       	adiw	r24, 0x01	; 1
    3880:	90 93 d1 03 	sts	0x03D1, r25
    3884:	80 93 d0 03 	sts	0x03D0, r24
}
    3888:	9f 91       	pop	r25
    388a:	8f 91       	pop	r24
    388c:	0f 90       	pop	r0
    388e:	0f be       	out	0x3f, r0	; 63
    3890:	0f 90       	pop	r0
    3892:	1f 90       	pop	r1
    3894:	18 95       	reti

00003896 <clock_init>:

//Initialise the clock
void clock_init()
{
	OCR1A  = (((F_CPU / 1024) / 100) - 1);
    3896:	8d e4       	ldi	r24, 0x4D	; 77
    3898:	90 e0       	ldi	r25, 0x00	; 0
    389a:	90 93 89 00 	sts	0x0089, r25
    389e:	80 93 88 00 	sts	0x0088, r24
	TCCR1B = ((1 << WGM12) | (1 << CS12) | (1 << CS10));
    38a2:	8d e0       	ldi	r24, 0x0D	; 13
    38a4:	80 93 81 00 	sts	0x0081, r24
	TIMSK1 = (1 << OCIE1A);
    38a8:	82 e0       	ldi	r24, 0x02	; 2
    38aa:	80 93 6f 00 	sts	0x006F, r24
}
    38ae:	08 95       	ret

000038b0 <clock_time>:
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    38b0:	f8 94       	cli
clock_time_t clock_time()
{
	clock_time_t time;

	GlobalInterruptDisable();
	time = clock_datetime;
    38b2:	20 91 d0 03 	lds	r18, 0x03D0
    38b6:	30 91 d1 03 	lds	r19, 0x03D1
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    38ba:	78 94       	sei
	GlobalInterruptEnable();

	return time;
}
    38bc:	c9 01       	movw	r24, r18
    38be:	08 95       	ret

000038c0 <uip_split_output>:
#define BUF ((struct uip_tcpip_hdr *)&uip_buf[UIP_LLH_LEN])

/*-----------------------------------------------------------------------------*/
void
uip_split_output(void)
{
    38c0:	cf 93       	push	r28
    38c2:	df 93       	push	r29
#if UIP_TCP
  u16_t tcplen, len1, len2;

  /* We only try to split maximum sized TCP segments. */
  if(BUF->proto == UIP_PROTO_TCP  && uip_len == UIP_BUFSIZE) {
    38c4:	cb ea       	ldi	r28, 0xAB	; 171
    38c6:	d7 e0       	ldi	r29, 0x07	; 7
    38c8:	80 91 b4 07 	lds	r24, 0x07B4
    38cc:	86 30       	cpi	r24, 0x06	; 6
    38ce:	09 f0       	breq	.+2      	; 0x38d2 <uip_split_output+0x12>
    38d0:	75 c0       	rjmp	.+234    	; 0x39bc <uip_split_output+0xfc>
    38d2:	80 91 25 06 	lds	r24, 0x0625
    38d6:	90 91 26 06 	lds	r25, 0x0626
    38da:	25 e0       	ldi	r18, 0x05	; 5
    38dc:	8a 3e       	cpi	r24, 0xEA	; 234
    38de:	92 07       	cpc	r25, r18
    38e0:	09 f0       	breq	.+2      	; 0x38e4 <uip_split_output+0x24>
    38e2:	6c c0       	rjmp	.+216    	; 0x39bc <uip_split_output+0xfc>
      ++len2;
    }

    /* Create the first packet. This is done by altering the length
       field of the IP header and updating the checksums. */
    uip_len = len1 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    38e4:	80 e1       	ldi	r24, 0x10	; 16
    38e6:	93 e0       	ldi	r25, 0x03	; 3
    38e8:	90 93 26 06 	sts	0x0626, r25
    38ec:	80 93 25 06 	sts	0x0625, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len - UIP_LLH_LEN) >> 8;
    38f0:	83 e0       	ldi	r24, 0x03	; 3
    38f2:	8a 83       	std	Y+2, r24	; 0x02
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    38f4:	82 e0       	ldi	r24, 0x02	; 2
    38f6:	8b 83       	std	Y+3, r24	; 0x03
#endif /* UIP_CONF_IPV6 */

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    38f8:	1d a2       	std	Y+37, r1	; 0x25
    38fa:	1c a2       	std	Y+36, r1	; 0x24
    BUF->tcpchksum = ~(uip_tcpchksum());
    38fc:	0e 94 3b 11 	call	0x2276	; 0x2276 <uip_tcpchksum>
    3900:	80 95       	com	r24
    3902:	90 95       	com	r25
    3904:	9d a3       	std	Y+37, r25	; 0x25
    3906:	8c a3       	std	Y+36, r24	; 0x24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    3908:	1b 86       	std	Y+11, r1	; 0x0b
    390a:	1a 86       	std	Y+10, r1	; 0x0a
    BUF->ipchksum = ~(uip_ipchksum());
    390c:	0e 94 24 11 	call	0x2248	; 0x2248 <uip_ipchksum>
    3910:	80 95       	com	r24
    3912:	90 95       	com	r25
    3914:	9b 87       	std	Y+11, r25	; 0x0b
    3916:	8a 87       	std	Y+10, r24	; 0x0a

    /* Transmit the first packet. */
#if UIP_CONF_IPV6
    tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    3918:	80 91 d9 03 	lds	r24, 0x03D9
    391c:	40 91 25 06 	lds	r20, 0x0625
    3920:	50 91 26 06 	lds	r21, 0x0626
    3924:	81 30       	cpi	r24, 0x01	; 1
    3926:	41 f4       	brne	.+16     	; 0x3938 <uip_split_output+0x78>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    3928:	83 e1       	ldi	r24, 0x13	; 19
    392a:	91 e0       	ldi	r25, 0x01	; 1
    392c:	be 01       	movw	r22, r28
    392e:	6e 50       	subi	r22, 0x0E	; 14
    3930:	70 40       	sbci	r23, 0x00	; 0
    3932:	0e 94 21 38 	call	0x7042	; 0x7042 <RNDIS_Device_SendPacket>
    3936:	07 c0       	rjmp	.+14     	; 0x3946 <uip_split_output+0x86>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    3938:	8a ee       	ldi	r24, 0xEA	; 234
    393a:	91 e0       	ldi	r25, 0x01	; 1
    393c:	be 01       	movw	r22, r28
    393e:	6e 50       	subi	r22, 0x0E	; 14
    3940:	70 40       	sbci	r23, 0x00	; 0
    3942:	0e 94 1a 3c 	call	0x7834	; 0x7834 <RNDIS_Host_SendPacket>
    /* Now, create the second packet. To do this, it is not enough to
       just alter the length field, but we must also update the TCP
       sequence number and point the uip_appdata to a new place in
       memory. This place is determined by the length of the first
       packet (len1). */
    uip_len = len2 + UIP_TCPIP_HLEN + UIP_LLH_LEN;
    3946:	80 e1       	ldi	r24, 0x10	; 16
    3948:	93 e0       	ldi	r25, 0x03	; 3
    394a:	90 93 26 06 	sts	0x0626, r25
    394e:	80 93 25 06 	sts	0x0625, r24
    /* For IPv6, the IP length field does not include the IPv6 IP header
       length. */
    BUF->len[0] = ((uip_len - UIP_IPH_LEN) >> 8);
    BUF->len[1] = ((uip_len - UIP_IPH_LEN) & 0xff);
#else /* UIP_CONF_IPV6 */
    BUF->len[0] = (uip_len  - UIP_LLH_LEN) >> 8;
    3952:	83 e0       	ldi	r24, 0x03	; 3
    3954:	8a 83       	std	Y+2, r24	; 0x02
    BUF->len[1] = (uip_len - UIP_LLH_LEN) & 0xff;
    3956:	82 e0       	ldi	r24, 0x02	; 2
    3958:	8b 83       	std	Y+3, r24	; 0x03
#endif /* UIP_CONF_IPV6 */

    memcpy(uip_appdata, (u8_t *)uip_appdata + len1, len2);
    395a:	90 91 30 06 	lds	r25, 0x0630
    395e:	80 91 31 06 	lds	r24, 0x0631
    3962:	e9 2f       	mov	r30, r25
    3964:	f8 2f       	mov	r31, r24
    3966:	df 01       	movw	r26, r30
    3968:	a6 52       	subi	r26, 0x26	; 38
    396a:	bd 4f       	sbci	r27, 0xFD	; 253
    396c:	8a ed       	ldi	r24, 0xDA	; 218
    396e:	92 e0       	ldi	r25, 0x02	; 2
    3970:	0d 90       	ld	r0, X+
    3972:	01 92       	st	Z+, r0
    3974:	01 97       	sbiw	r24, 0x01	; 1
    3976:	e1 f7       	brne	.-8      	; 0x3970 <uip_split_output+0xb0>

    uip_add32(BUF->seqno, len1);
    3978:	83 ec       	ldi	r24, 0xC3	; 195
    397a:	97 e0       	ldi	r25, 0x07	; 7
    397c:	6a ed       	ldi	r22, 0xDA	; 218
    397e:	72 e0       	ldi	r23, 0x02	; 2
    3980:	0e 94 26 10 	call	0x204c	; 0x204c <uip_add32>
    BUF->seqno[0] = uip_acc32[0];
    3984:	80 91 29 06 	lds	r24, 0x0629
    3988:	88 8f       	std	Y+24, r24	; 0x18
    BUF->seqno[1] = uip_acc32[1];
    398a:	80 91 2a 06 	lds	r24, 0x062A
    398e:	89 8f       	std	Y+25, r24	; 0x19
    BUF->seqno[2] = uip_acc32[2];
    3990:	80 91 2b 06 	lds	r24, 0x062B
    3994:	8a 8f       	std	Y+26, r24	; 0x1a
    BUF->seqno[3] = uip_acc32[3];
    3996:	80 91 2c 06 	lds	r24, 0x062C
    399a:	8b 8f       	std	Y+27, r24	; 0x1b

    /* Recalculate the TCP checksum. */
    BUF->tcpchksum = 0;
    399c:	1d a2       	std	Y+37, r1	; 0x25
    399e:	1c a2       	std	Y+36, r1	; 0x24
    BUF->tcpchksum = ~(uip_tcpchksum());
    39a0:	0e 94 3b 11 	call	0x2276	; 0x2276 <uip_tcpchksum>
    39a4:	80 95       	com	r24
    39a6:	90 95       	com	r25
    39a8:	9d a3       	std	Y+37, r25	; 0x25
    39aa:	8c a3       	std	Y+36, r24	; 0x24

#if !UIP_CONF_IPV6
    /* Recalculate the IP checksum. */
    BUF->ipchksum = 0;
    39ac:	1b 86       	std	Y+11, r1	; 0x0b
    39ae:	1a 86       	std	Y+10, r1	; 0x0a
    BUF->ipchksum = ~(uip_ipchksum());
    39b0:	0e 94 24 11 	call	0x2248	; 0x2248 <uip_ipchksum>
    39b4:	80 95       	com	r24
    39b6:	90 95       	com	r25
    39b8:	9b 87       	std	Y+11, r25	; 0x0b
    39ba:	8a 87       	std	Y+10, r24	; 0x0a

  /*    uip_fw_output();*/
#if UIP_CONF_IPV6
	tcpip_ipv6_output();
#else
	if (USB_CurrentMode == USB_MODE_Device)
    39bc:	80 91 d9 03 	lds	r24, 0x03D9
    39c0:	40 91 25 06 	lds	r20, 0x0625
    39c4:	50 91 26 06 	lds	r21, 0x0626
    39c8:	81 30       	cpi	r24, 0x01	; 1
    39ca:	39 f4       	brne	.+14     	; 0x39da <uip_split_output+0x11a>
	  RNDIS_Device_SendPacket(&Ethernet_RNDIS_Interface_Device, uip_buf, uip_len);
    39cc:	83 e1       	ldi	r24, 0x13	; 19
    39ce:	91 e0       	ldi	r25, 0x01	; 1
    39d0:	6d e9       	ldi	r22, 0x9D	; 157
    39d2:	77 e0       	ldi	r23, 0x07	; 7
    39d4:	0e 94 21 38 	call	0x7042	; 0x7042 <RNDIS_Device_SendPacket>
    39d8:	06 c0       	rjmp	.+12     	; 0x39e6 <uip_split_output+0x126>
	else
	  RNDIS_Host_SendPacket(&Ethernet_RNDIS_Interface_Host, uip_buf, uip_len);
    39da:	8a ee       	ldi	r24, 0xEA	; 234
    39dc:	91 e0       	ldi	r25, 0x01	; 1
    39de:	6d e9       	ldi	r22, 0x9D	; 157
    39e0:	77 e0       	ldi	r23, 0x07	; 7
    39e2:	0e 94 1a 3c 	call	0x7834	; 0x7834 <RNDIS_Host_SendPacket>
#endif /* UIP_CONF_IPV6 */
}
    39e6:	df 91       	pop	r29
    39e8:	cf 91       	pop	r28
    39ea:	08 95       	ret

000039ec <disk_initialize>:
DSTATUS disk_initialize (
	BYTE drv				/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    39ec:	80 e0       	ldi	r24, 0x00	; 0
    39ee:	08 95       	ret

000039f0 <disk_status>:
DSTATUS disk_status (
	BYTE drv		/* Physical drive number (0..) */
)
{
	return FR_OK;
}
    39f0:	80 e0       	ldi	r24, 0x00	; 0
    39f2:	08 95       	ret

000039f4 <disk_read>:
	BYTE drv,		/* Physical drive number (0..) */
	BYTE *buff,		/* Data buffer to store read data */
	DWORD sector,	/* Sector address (LBA) */
	BYTE count		/* Number of sectors to read (1..128) */
)
{
    39f4:	0f 93       	push	r16
    39f6:	fb 01       	movw	r30, r22
    39f8:	ca 01       	movw	r24, r20
    39fa:	b9 01       	movw	r22, r18
    39fc:	40 2f       	mov	r20, r16
	DataflashManager_ReadBlocks_RAM(sector, count, buff);
    39fe:	50 e0       	ldi	r21, 0x00	; 0
    3a00:	9f 01       	movw	r18, r30
    3a02:	0e 94 7a 07 	call	0xef4	; 0xef4 <DataflashManager_ReadBlocks_RAM>
	return RES_OK;
}
    3a06:	80 e0       	ldi	r24, 0x00	; 0
    3a08:	0f 91       	pop	r16
    3a0a:	08 95       	ret

00003a0c <validate>:
)
{
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
    3a0c:	fc 01       	movw	r30, r24
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
    3a0e:	a0 81       	ld	r26, Z
    3a10:	b1 81       	ldd	r27, Z+1	; 0x01
    3a12:	10 97       	sbiw	r26, 0x00	; 0
    3a14:	99 f0       	breq	.+38     	; 0x3a3c <validate+0x30>
    3a16:	8c 91       	ld	r24, X
    3a18:	88 23       	and	r24, r24
    3a1a:	81 f0       	breq	.+32     	; 0x3a3c <validate+0x30>
    3a1c:	16 96       	adiw	r26, 0x06	; 6
    3a1e:	2d 91       	ld	r18, X+
    3a20:	3c 91       	ld	r19, X
    3a22:	17 97       	sbiw	r26, 0x07	; 7
    3a24:	82 81       	ldd	r24, Z+2	; 0x02
    3a26:	93 81       	ldd	r25, Z+3	; 0x03
    3a28:	28 17       	cp	r18, r24
    3a2a:	39 07       	cpc	r19, r25
    3a2c:	39 f4       	brne	.+14     	; 0x3a3c <validate+0x30>
		return FR_INVALID_OBJECT;

	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
    3a2e:	11 96       	adiw	r26, 0x01	; 1
    3a30:	8c 91       	ld	r24, X
    3a32:	de df       	rcall	.-68     	; 0x39f0 <disk_status>
    3a34:	80 ff       	sbrs	r24, 0
    3a36:	04 c0       	rjmp	.+8      	; 0x3a40 <validate+0x34>
		return FR_NOT_READY;
    3a38:	83 e0       	ldi	r24, 0x03	; 3
    3a3a:	08 95       	ret
	FIL *fil;


	fil = (FIL*)obj;	/* Assuming offset of fs and id in the FIL/DIR is identical */
	if (!fil->fs || !fil->fs->fs_type || fil->fs->id != fil->id)
		return FR_INVALID_OBJECT;
    3a3c:	89 e0       	ldi	r24, 0x09	; 9
    3a3e:	08 95       	ret
	ENTER_FF(fil->fs);		/* Lock file system */

	if (disk_status(fil->fs->drv) & STA_NOINIT)
		return FR_NOT_READY;

	return FR_OK;
    3a40:	80 e0       	ldi	r24, 0x00	; 0
}
    3a42:	08 95       	ret

00003a44 <move_window>:
static
FRESULT move_window (
	FATFS *fs,		/* File system object */
	DWORD sector	/* Sector number to make appearance in the fs->win[] */
)					/* Move to zero only writes back dirty window */
{
    3a44:	cf 92       	push	r12
    3a46:	df 92       	push	r13
    3a48:	ef 92       	push	r14
    3a4a:	ff 92       	push	r15
    3a4c:	0f 93       	push	r16
    3a4e:	cf 93       	push	r28
    3a50:	df 93       	push	r29
    3a52:	ec 01       	movw	r28, r24
    3a54:	6a 01       	movw	r12, r20
    3a56:	7b 01       	movw	r14, r22
	DWORD wsect;


	wsect = fs->winsect;
	if (wsect != sector) {	/* Changed current window */
    3a58:	8e 8d       	ldd	r24, Y+30	; 0x1e
    3a5a:	9f 8d       	ldd	r25, Y+31	; 0x1f
    3a5c:	a8 a1       	ldd	r26, Y+32	; 0x20
    3a5e:	b9 a1       	ldd	r27, Y+33	; 0x21
    3a60:	84 17       	cp	r24, r20
    3a62:	95 07       	cpc	r25, r21
    3a64:	a6 07       	cpc	r26, r22
    3a66:	b7 07       	cpc	r27, r23
    3a68:	a1 f0       	breq	.+40     	; 0x3a92 <move_window+0x4e>
					disk_write(fs->drv, fs->win, wsect, 1);
				}
			}
		}
#endif
		if (sector) {
    3a6a:	41 15       	cp	r20, r1
    3a6c:	51 05       	cpc	r21, r1
    3a6e:	61 05       	cpc	r22, r1
    3a70:	71 05       	cpc	r23, r1
    3a72:	79 f0       	breq	.+30     	; 0x3a92 <move_window+0x4e>
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
    3a74:	be 01       	movw	r22, r28
    3a76:	6e 5d       	subi	r22, 0xDE	; 222
    3a78:	7f 4f       	sbci	r23, 0xFF	; 255
    3a7a:	89 81       	ldd	r24, Y+1	; 0x01
    3a7c:	a7 01       	movw	r20, r14
    3a7e:	96 01       	movw	r18, r12
    3a80:	01 e0       	ldi	r16, 0x01	; 1
    3a82:	b8 df       	rcall	.-144    	; 0x39f4 <disk_read>
    3a84:	88 23       	and	r24, r24
    3a86:	39 f4       	brne	.+14     	; 0x3a96 <move_window+0x52>
				return FR_DISK_ERR;
			fs->winsect = sector;
    3a88:	ce 8e       	std	Y+30, r12	; 0x1e
    3a8a:	df 8e       	std	Y+31, r13	; 0x1f
    3a8c:	e8 a2       	std	Y+32, r14	; 0x20
    3a8e:	f9 a2       	std	Y+33, r15	; 0x21
    3a90:	03 c0       	rjmp	.+6      	; 0x3a98 <move_window+0x54>
		}
	}

	return FR_OK;
    3a92:	80 e0       	ldi	r24, 0x00	; 0
    3a94:	01 c0       	rjmp	.+2      	; 0x3a98 <move_window+0x54>
			}
		}
#endif
		if (sector) {
			if (disk_read(fs->drv, fs->win, sector, 1) != RES_OK)
				return FR_DISK_ERR;
    3a96:	81 e0       	ldi	r24, 0x01	; 1
			fs->winsect = sector;
		}
	}

	return FR_OK;
}
    3a98:	df 91       	pop	r29
    3a9a:	cf 91       	pop	r28
    3a9c:	0f 91       	pop	r16
    3a9e:	ff 90       	pop	r15
    3aa0:	ef 90       	pop	r14
    3aa2:	df 90       	pop	r13
    3aa4:	cf 90       	pop	r12
    3aa6:	08 95       	ret

00003aa8 <check_fs>:
static
BYTE check_fs (	/* 0:FAT-VBR, 1:Any BR but not FAT, 2:Not a BR, 3:Disk error */
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
    3aa8:	ef 92       	push	r14
    3aaa:	ff 92       	push	r15
    3aac:	0f 93       	push	r16
    3aae:	cf 93       	push	r28
    3ab0:	df 93       	push	r29
    3ab2:	ec 01       	movw	r28, r24
    3ab4:	9a 01       	movw	r18, r20
    3ab6:	ab 01       	movw	r20, r22
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
    3ab8:	82 e2       	ldi	r24, 0x22	; 34
    3aba:	e8 2e       	mov	r14, r24
    3abc:	f1 2c       	mov	r15, r1
    3abe:	ec 0e       	add	r14, r28
    3ac0:	fd 1e       	adc	r15, r29
    3ac2:	89 81       	ldd	r24, Y+1	; 0x01
    3ac4:	b7 01       	movw	r22, r14
    3ac6:	01 e0       	ldi	r16, 0x01	; 1
    3ac8:	95 df       	rcall	.-214    	; 0x39f4 <disk_read>
    3aca:	88 23       	and	r24, r24
    3acc:	41 f5       	brne	.+80     	; 0x3b1e <check_fs+0x76>
		return 3;
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
    3ace:	fe 01       	movw	r30, r28
    3ad0:	e0 5e       	subi	r30, 0xE0	; 224
    3ad2:	fd 4f       	sbci	r31, 0xFD	; 253
    3ad4:	80 81       	ld	r24, Z
    3ad6:	91 81       	ldd	r25, Z+1	; 0x01
    3ad8:	2a ea       	ldi	r18, 0xAA	; 170
    3ada:	85 35       	cpi	r24, 0x55	; 85
    3adc:	92 07       	cpc	r25, r18
    3ade:	09 f5       	brne	.+66     	; 0x3b22 <check_fs+0x7a>
		return 2;

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
    3ae0:	f7 01       	movw	r30, r14
    3ae2:	86 a9       	ldd	r24, Z+54	; 0x36
    3ae4:	97 a9       	ldd	r25, Z+55	; 0x37
    3ae6:	a0 ad       	ldd	r26, Z+56	; 0x38
    3ae8:	b1 ad       	ldd	r27, Z+57	; 0x39
    3aea:	b0 70       	andi	r27, 0x00	; 0
    3aec:	86 34       	cpi	r24, 0x46	; 70
    3aee:	f1 e4       	ldi	r31, 0x41	; 65
    3af0:	9f 07       	cpc	r25, r31
    3af2:	f4 e5       	ldi	r31, 0x54	; 84
    3af4:	af 07       	cpc	r26, r31
    3af6:	f0 e0       	ldi	r31, 0x00	; 0
    3af8:	bf 07       	cpc	r27, r31
    3afa:	a9 f0       	breq	.+42     	; 0x3b26 <check_fs+0x7e>
		return 0;
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
    3afc:	cc 58       	subi	r28, 0x8C	; 140
    3afe:	df 4f       	sbci	r29, 0xFF	; 255
    3b00:	28 81       	ld	r18, Y
    3b02:	39 81       	ldd	r19, Y+1	; 0x01
    3b04:	4a 81       	ldd	r20, Y+2	; 0x02
    3b06:	5b 81       	ldd	r21, Y+3	; 0x03
    3b08:	50 70       	andi	r21, 0x00	; 0
	FATFS *fs,	/* File system object */
	DWORD sect	/* Sector# (lba) to check if it is an FAT boot record or not */
)
{
	if (disk_read(fs->drv, fs->win, sect, 1) != RES_OK)	/* Load boot record */
		return 3;
    3b0a:	81 e0       	ldi	r24, 0x01	; 1
    3b0c:	26 34       	cpi	r18, 0x46	; 70
    3b0e:	91 e4       	ldi	r25, 0x41	; 65
    3b10:	39 07       	cpc	r19, r25
    3b12:	94 e5       	ldi	r25, 0x54	; 84
    3b14:	49 07       	cpc	r20, r25
    3b16:	90 e0       	ldi	r25, 0x00	; 0
    3b18:	59 07       	cpc	r21, r25
    3b1a:	31 f4       	brne	.+12     	; 0x3b28 <check_fs+0x80>
    3b1c:	04 c0       	rjmp	.+8      	; 0x3b26 <check_fs+0x7e>
    3b1e:	83 e0       	ldi	r24, 0x03	; 3
    3b20:	03 c0       	rjmp	.+6      	; 0x3b28 <check_fs+0x80>
	if (LD_WORD(&fs->win[BS_55AA]) != 0xAA55)		/* Check record signature (always placed at offset 510 even if the sector size is >512) */
		return 2;
    3b22:	82 e0       	ldi	r24, 0x02	; 2
    3b24:	01 c0       	rjmp	.+2      	; 0x3b28 <check_fs+0x80>

	if ((LD_DWORD(&fs->win[BS_FilSysType]) & 0xFFFFFF) == 0x544146)	/* Check "FAT" string */
		return 0;
    3b26:	80 e0       	ldi	r24, 0x00	; 0
	if ((LD_DWORD(&fs->win[BS_FilSysType32]) & 0xFFFFFF) == 0x544146)
		return 0;

	return 1;
}
    3b28:	df 91       	pop	r29
    3b2a:	cf 91       	pop	r28
    3b2c:	0f 91       	pop	r16
    3b2e:	ff 90       	pop	r15
    3b30:	ef 90       	pop	r14
    3b32:	08 95       	ret

00003b34 <ld_clust.clone.0>:
	BYTE *dir	/* Pointer to the directory entry */
)
{
	DWORD cl;

	cl = LD_WORD(dir+DIR_FstClusLO);
    3b34:	fb 01       	movw	r30, r22
    3b36:	22 8d       	ldd	r18, Z+26	; 0x1a
    3b38:	33 8d       	ldd	r19, Z+27	; 0x1b
    3b3a:	40 e0       	ldi	r20, 0x00	; 0
    3b3c:	50 e0       	ldi	r21, 0x00	; 0
	if (fs->fs_type == FS_FAT32)
    3b3e:	83 30       	cpi	r24, 0x03	; 3
    3b40:	59 f4       	brne	.+22     	; 0x3b58 <ld_clust.clone.0+0x24>
		cl |= (DWORD)LD_WORD(dir+DIR_FstClusHI) << 16;
    3b42:	84 89       	ldd	r24, Z+20	; 0x14
    3b44:	95 89       	ldd	r25, Z+21	; 0x15
    3b46:	a0 e0       	ldi	r26, 0x00	; 0
    3b48:	b0 e0       	ldi	r27, 0x00	; 0
    3b4a:	dc 01       	movw	r26, r24
    3b4c:	99 27       	eor	r25, r25
    3b4e:	88 27       	eor	r24, r24
    3b50:	28 2b       	or	r18, r24
    3b52:	39 2b       	or	r19, r25
    3b54:	4a 2b       	or	r20, r26
    3b56:	5b 2b       	or	r21, r27

	return cl;
}
    3b58:	b9 01       	movw	r22, r18
    3b5a:	ca 01       	movw	r24, r20
    3b5c:	08 95       	ret

00003b5e <clust2sect>:

DWORD clust2sect (	/* !=0: Sector number, 0: Failed - invalid cluster# */
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
    3b5e:	cf 93       	push	r28
    3b60:	df 93       	push	r29
    3b62:	ec 01       	movw	r28, r24
    3b64:	cb 01       	movw	r24, r22
    3b66:	ba 01       	movw	r22, r20
	clst -= 2;
    3b68:	62 50       	subi	r22, 0x02	; 2
    3b6a:	70 40       	sbci	r23, 0x00	; 0
    3b6c:	80 40       	sbci	r24, 0x00	; 0
    3b6e:	90 40       	sbci	r25, 0x00	; 0
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3b70:	2a 85       	ldd	r18, Y+10	; 0x0a
    3b72:	3b 85       	ldd	r19, Y+11	; 0x0b
    3b74:	4c 85       	ldd	r20, Y+12	; 0x0c
    3b76:	5d 85       	ldd	r21, Y+13	; 0x0d
    3b78:	22 50       	subi	r18, 0x02	; 2
    3b7a:	30 40       	sbci	r19, 0x00	; 0
    3b7c:	40 40       	sbci	r20, 0x00	; 0
    3b7e:	50 40       	sbci	r21, 0x00	; 0
    3b80:	62 17       	cp	r22, r18
    3b82:	73 07       	cpc	r23, r19
    3b84:	84 07       	cpc	r24, r20
    3b86:	95 07       	cpc	r25, r21
    3b88:	88 f4       	brcc	.+34     	; 0x3bac <clust2sect+0x4e>
	return clst * fs->csize + fs->database;
    3b8a:	2a 81       	ldd	r18, Y+2	; 0x02
    3b8c:	30 e0       	ldi	r19, 0x00	; 0
    3b8e:	40 e0       	ldi	r20, 0x00	; 0
    3b90:	50 e0       	ldi	r21, 0x00	; 0
    3b92:	0e 94 8e 3c 	call	0x791c	; 0x791c <__mulsi3>
    3b96:	9b 01       	movw	r18, r22
    3b98:	ac 01       	movw	r20, r24
    3b9a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    3b9c:	9b 8d       	ldd	r25, Y+27	; 0x1b
    3b9e:	ac 8d       	ldd	r26, Y+28	; 0x1c
    3ba0:	bd 8d       	ldd	r27, Y+29	; 0x1d
    3ba2:	28 0f       	add	r18, r24
    3ba4:	39 1f       	adc	r19, r25
    3ba6:	4a 1f       	adc	r20, r26
    3ba8:	5b 1f       	adc	r21, r27
    3baa:	03 c0       	rjmp	.+6      	; 0x3bb2 <clust2sect+0x54>
	FATFS *fs,		/* File system object */
	DWORD clst		/* Cluster# to be converted */
)
{
	clst -= 2;
	if (clst >= (fs->n_fatent - 2)) return 0;		/* Invalid cluster# */
    3bac:	20 e0       	ldi	r18, 0x00	; 0
    3bae:	30 e0       	ldi	r19, 0x00	; 0
    3bb0:	a9 01       	movw	r20, r18
	return clst * fs->csize + fs->database;
}
    3bb2:	b9 01       	movw	r22, r18
    3bb4:	ca 01       	movw	r24, r20
    3bb6:	df 91       	pop	r29
    3bb8:	cf 91       	pop	r28
    3bba:	08 95       	ret

00003bbc <get_fat>:

DWORD get_fat (	/* 0xFFFFFFFF:Disk error, 1:Internal error, Else:Cluster status */
	FATFS *fs,	/* File system object */
	DWORD clst	/* Cluster# to get the link information */
)
{
    3bbc:	bf 92       	push	r11
    3bbe:	cf 92       	push	r12
    3bc0:	df 92       	push	r13
    3bc2:	ef 92       	push	r14
    3bc4:	ff 92       	push	r15
    3bc6:	0f 93       	push	r16
    3bc8:	1f 93       	push	r17
    3bca:	cf 93       	push	r28
    3bcc:	df 93       	push	r29
    3bce:	ec 01       	movw	r28, r24
    3bd0:	6a 01       	movw	r12, r20
    3bd2:	7b 01       	movw	r14, r22
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
    3bd4:	42 30       	cpi	r20, 0x02	; 2
    3bd6:	51 05       	cpc	r21, r1
    3bd8:	61 05       	cpc	r22, r1
    3bda:	71 05       	cpc	r23, r1
    3bdc:	08 f4       	brcc	.+2      	; 0x3be0 <get_fat+0x24>
    3bde:	9e c0       	rjmp	.+316    	; 0x3d1c <get_fat+0x160>
    3be0:	8a 85       	ldd	r24, Y+10	; 0x0a
    3be2:	9b 85       	ldd	r25, Y+11	; 0x0b
    3be4:	ac 85       	ldd	r26, Y+12	; 0x0c
    3be6:	bd 85       	ldd	r27, Y+13	; 0x0d
    3be8:	48 17       	cp	r20, r24
    3bea:	59 07       	cpc	r21, r25
    3bec:	6a 07       	cpc	r22, r26
    3bee:	7b 07       	cpc	r23, r27
    3bf0:	08 f0       	brcs	.+2      	; 0x3bf4 <get_fat+0x38>
    3bf2:	94 c0       	rjmp	.+296    	; 0x3d1c <get_fat+0x160>
		return 1;

	switch (fs->fs_type) {
    3bf4:	88 81       	ld	r24, Y
    3bf6:	82 30       	cpi	r24, 0x02	; 2
    3bf8:	09 f4       	brne	.+2      	; 0x3bfc <get_fat+0x40>
    3bfa:	54 c0       	rjmp	.+168    	; 0x3ca4 <get_fat+0xe8>
    3bfc:	83 30       	cpi	r24, 0x03	; 3
    3bfe:	09 f4       	brne	.+2      	; 0x3c02 <get_fat+0x46>
    3c00:	6c c0       	rjmp	.+216    	; 0x3cda <get_fat+0x11e>
    3c02:	81 30       	cpi	r24, 0x01	; 1
    3c04:	09 f0       	breq	.+2      	; 0x3c08 <get_fat+0x4c>
    3c06:	8f c0       	rjmp	.+286    	; 0x3d26 <get_fat+0x16a>
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
    3c08:	8a 01       	movw	r16, r20
    3c0a:	16 95       	lsr	r17
    3c0c:	07 95       	ror	r16
    3c0e:	04 0f       	add	r16, r20
    3c10:	15 1f       	adc	r17, r21
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3c12:	a8 01       	movw	r20, r16
    3c14:	45 2f       	mov	r20, r21
    3c16:	55 27       	eor	r21, r21
    3c18:	46 95       	lsr	r20
    3c1a:	60 e0       	ldi	r22, 0x00	; 0
    3c1c:	70 e0       	ldi	r23, 0x00	; 0
    3c1e:	8a 89       	ldd	r24, Y+18	; 0x12
    3c20:	9b 89       	ldd	r25, Y+19	; 0x13
    3c22:	ac 89       	ldd	r26, Y+20	; 0x14
    3c24:	bd 89       	ldd	r27, Y+21	; 0x15
    3c26:	48 0f       	add	r20, r24
    3c28:	59 1f       	adc	r21, r25
    3c2a:	6a 1f       	adc	r22, r26
    3c2c:	7b 1f       	adc	r23, r27
    3c2e:	ce 01       	movw	r24, r28
    3c30:	09 df       	rcall	.-494    	; 0x3a44 <move_window>
    3c32:	88 23       	and	r24, r24
    3c34:	09 f0       	breq	.+2      	; 0x3c38 <get_fat+0x7c>
    3c36:	77 c0       	rjmp	.+238    	; 0x3d26 <get_fat+0x16a>
		wc = fs->win[bc % SS(fs)]; bc++;
    3c38:	f8 01       	movw	r30, r16
    3c3a:	f1 70       	andi	r31, 0x01	; 1
    3c3c:	ec 0f       	add	r30, r28
    3c3e:	fd 1f       	adc	r31, r29
    3c40:	b2 a0       	ldd	r11, Z+34	; 0x22
    3c42:	0f 5f       	subi	r16, 0xFF	; 255
    3c44:	1f 4f       	sbci	r17, 0xFF	; 255
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
    3c46:	a8 01       	movw	r20, r16
    3c48:	45 2f       	mov	r20, r21
    3c4a:	55 27       	eor	r21, r21
    3c4c:	46 95       	lsr	r20
    3c4e:	60 e0       	ldi	r22, 0x00	; 0
    3c50:	70 e0       	ldi	r23, 0x00	; 0
    3c52:	8a 89       	ldd	r24, Y+18	; 0x12
    3c54:	9b 89       	ldd	r25, Y+19	; 0x13
    3c56:	ac 89       	ldd	r26, Y+20	; 0x14
    3c58:	bd 89       	ldd	r27, Y+21	; 0x15
    3c5a:	48 0f       	add	r20, r24
    3c5c:	59 1f       	adc	r21, r25
    3c5e:	6a 1f       	adc	r22, r26
    3c60:	7b 1f       	adc	r23, r27
    3c62:	ce 01       	movw	r24, r28
    3c64:	ef de       	rcall	.-546    	; 0x3a44 <move_window>
    3c66:	88 23       	and	r24, r24
    3c68:	09 f0       	breq	.+2      	; 0x3c6c <get_fat+0xb0>
    3c6a:	5d c0       	rjmp	.+186    	; 0x3d26 <get_fat+0x16a>

	switch (fs->fs_type) {
	case FS_FAT12 :
		bc = (UINT)clst; bc += bc / 2;
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc = fs->win[bc % SS(fs)]; bc++;
    3c6c:	2b 2d       	mov	r18, r11
    3c6e:	30 e0       	ldi	r19, 0x00	; 0
		if (move_window(fs, fs->fatbase + (bc / SS(fs)))) break;
		wc |= fs->win[bc % SS(fs)] << 8;
    3c70:	11 70       	andi	r17, 0x01	; 1
    3c72:	0c 0f       	add	r16, r28
    3c74:	1d 1f       	adc	r17, r29
    3c76:	f8 01       	movw	r30, r16
    3c78:	92 a1       	ldd	r25, Z+34	; 0x22
    3c7a:	80 e0       	ldi	r24, 0x00	; 0
    3c7c:	28 2b       	or	r18, r24
    3c7e:	39 2b       	or	r19, r25
		return (clst & 1) ? (wc >> 4) : (wc & 0xFFF);
    3c80:	f1 e0       	ldi	r31, 0x01	; 1
    3c82:	cf 22       	and	r12, r31
    3c84:	dd 24       	eor	r13, r13
    3c86:	c1 14       	cp	r12, r1
    3c88:	d1 04       	cpc	r13, r1
    3c8a:	31 f0       	breq	.+12     	; 0x3c98 <get_fat+0xdc>
    3c8c:	14 e0       	ldi	r17, 0x04	; 4
    3c8e:	36 95       	lsr	r19
    3c90:	27 95       	ror	r18
    3c92:	1a 95       	dec	r17
    3c94:	e1 f7       	brne	.-8      	; 0x3c8e <get_fat+0xd2>
    3c96:	1e c0       	rjmp	.+60     	; 0x3cd4 <get_fat+0x118>
    3c98:	40 e0       	ldi	r20, 0x00	; 0
    3c9a:	50 e0       	ldi	r21, 0x00	; 0
    3c9c:	3f 70       	andi	r19, 0x0F	; 15
    3c9e:	40 70       	andi	r20, 0x00	; 0
    3ca0:	50 70       	andi	r21, 0x00	; 0
    3ca2:	44 c0       	rjmp	.+136    	; 0x3d2c <get_fat+0x170>

	case FS_FAT16 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 2)))) break;
    3ca4:	45 2f       	mov	r20, r21
    3ca6:	56 2f       	mov	r21, r22
    3ca8:	67 2f       	mov	r22, r23
    3caa:	77 27       	eor	r23, r23
    3cac:	8a 89       	ldd	r24, Y+18	; 0x12
    3cae:	9b 89       	ldd	r25, Y+19	; 0x13
    3cb0:	ac 89       	ldd	r26, Y+20	; 0x14
    3cb2:	bd 89       	ldd	r27, Y+21	; 0x15
    3cb4:	48 0f       	add	r20, r24
    3cb6:	59 1f       	adc	r21, r25
    3cb8:	6a 1f       	adc	r22, r26
    3cba:	7b 1f       	adc	r23, r27
    3cbc:	ce 01       	movw	r24, r28
    3cbe:	c2 de       	rcall	.-636    	; 0x3a44 <move_window>
    3cc0:	88 23       	and	r24, r24
    3cc2:	89 f5       	brne	.+98     	; 0x3d26 <get_fat+0x16a>
		p = &fs->win[clst * 2 % SS(fs)];
    3cc4:	f6 01       	movw	r30, r12
    3cc6:	ee 0f       	add	r30, r30
    3cc8:	ff 1f       	adc	r31, r31
    3cca:	f1 70       	andi	r31, 0x01	; 1
		return LD_WORD(p);
    3ccc:	ec 0f       	add	r30, r28
    3cce:	fd 1f       	adc	r31, r29
    3cd0:	22 a1       	ldd	r18, Z+34	; 0x22
    3cd2:	33 a1       	ldd	r19, Z+35	; 0x23
    3cd4:	40 e0       	ldi	r20, 0x00	; 0
    3cd6:	50 e0       	ldi	r21, 0x00	; 0
    3cd8:	29 c0       	rjmp	.+82     	; 0x3d2c <get_fat+0x170>

	case FS_FAT32 :
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
    3cda:	e7 e0       	ldi	r30, 0x07	; 7
    3cdc:	76 95       	lsr	r23
    3cde:	67 95       	ror	r22
    3ce0:	57 95       	ror	r21
    3ce2:	47 95       	ror	r20
    3ce4:	ea 95       	dec	r30
    3ce6:	d1 f7       	brne	.-12     	; 0x3cdc <get_fat+0x120>
    3ce8:	8a 89       	ldd	r24, Y+18	; 0x12
    3cea:	9b 89       	ldd	r25, Y+19	; 0x13
    3cec:	ac 89       	ldd	r26, Y+20	; 0x14
    3cee:	bd 89       	ldd	r27, Y+21	; 0x15
    3cf0:	48 0f       	add	r20, r24
    3cf2:	59 1f       	adc	r21, r25
    3cf4:	6a 1f       	adc	r22, r26
    3cf6:	7b 1f       	adc	r23, r27
    3cf8:	ce 01       	movw	r24, r28
    3cfa:	a4 de       	rcall	.-696    	; 0x3a44 <move_window>
    3cfc:	88 23       	and	r24, r24
    3cfe:	99 f4       	brne	.+38     	; 0x3d26 <get_fat+0x16a>
		p = &fs->win[clst * 4 % SS(fs)];
    3d00:	f6 01       	movw	r30, r12
    3d02:	ee 0f       	add	r30, r30
    3d04:	ff 1f       	adc	r31, r31
    3d06:	ee 0f       	add	r30, r30
    3d08:	ff 1f       	adc	r31, r31
    3d0a:	f1 70       	andi	r31, 0x01	; 1
		return LD_DWORD(p) & 0x0FFFFFFF;
    3d0c:	ec 0f       	add	r30, r28
    3d0e:	fd 1f       	adc	r31, r29
    3d10:	22 a1       	ldd	r18, Z+34	; 0x22
    3d12:	33 a1       	ldd	r19, Z+35	; 0x23
    3d14:	44 a1       	ldd	r20, Z+36	; 0x24
    3d16:	55 a1       	ldd	r21, Z+37	; 0x25
    3d18:	5f 70       	andi	r21, 0x0F	; 15
    3d1a:	08 c0       	rjmp	.+16     	; 0x3d2c <get_fat+0x170>
	UINT wc, bc;
	BYTE *p;


	if (clst < 2 || clst >= fs->n_fatent)	/* Check range */
		return 1;
    3d1c:	21 e0       	ldi	r18, 0x01	; 1
    3d1e:	30 e0       	ldi	r19, 0x00	; 0
    3d20:	40 e0       	ldi	r20, 0x00	; 0
    3d22:	50 e0       	ldi	r21, 0x00	; 0
    3d24:	03 c0       	rjmp	.+6      	; 0x3d2c <get_fat+0x170>
		if (move_window(fs, fs->fatbase + (clst / (SS(fs) / 4)))) break;
		p = &fs->win[clst * 4 % SS(fs)];
		return LD_DWORD(p) & 0x0FFFFFFF;
	}

	return 0xFFFFFFFF;	/* An error occurred at the disk I/O layer */
    3d26:	2f ef       	ldi	r18, 0xFF	; 255
    3d28:	3f ef       	ldi	r19, 0xFF	; 255
    3d2a:	a9 01       	movw	r20, r18
}
    3d2c:	b9 01       	movw	r22, r18
    3d2e:	ca 01       	movw	r24, r20
    3d30:	df 91       	pop	r29
    3d32:	cf 91       	pop	r28
    3d34:	1f 91       	pop	r17
    3d36:	0f 91       	pop	r16
    3d38:	ff 90       	pop	r15
    3d3a:	ef 90       	pop	r14
    3d3c:	df 90       	pop	r13
    3d3e:	cf 90       	pop	r12
    3d40:	bf 90       	pop	r11
    3d42:	08 95       	ret

00003d44 <dir_sdi.clone.4>:
/*-----------------------------------------------------------------------*/
/* Directory handling - Set directory index                              */
/*-----------------------------------------------------------------------*/

static
FRESULT dir_sdi (
    3d44:	0f 93       	push	r16
    3d46:	1f 93       	push	r17
    3d48:	cf 93       	push	r28
    3d4a:	df 93       	push	r29
    3d4c:	ec 01       	movw	r28, r24
{
	DWORD clst;
	WORD ic;


	dj->index = idx;
    3d4e:	1d 82       	std	Y+5, r1	; 0x05
    3d50:	1c 82       	std	Y+4, r1	; 0x04
	clst = dj->sclust;
    3d52:	4e 81       	ldd	r20, Y+6	; 0x06
    3d54:	5f 81       	ldd	r21, Y+7	; 0x07
    3d56:	68 85       	ldd	r22, Y+8	; 0x08
    3d58:	79 85       	ldd	r23, Y+9	; 0x09
	if (clst == 1 || clst >= dj->fs->n_fatent)	/* Check start cluster range */
    3d5a:	41 30       	cpi	r20, 0x01	; 1
    3d5c:	51 05       	cpc	r21, r1
    3d5e:	61 05       	cpc	r22, r1
    3d60:	71 05       	cpc	r23, r1
    3d62:	09 f4       	brne	.+2      	; 0x3d66 <dir_sdi.clone.4+0x22>
    3d64:	65 c0       	rjmp	.+202    	; 0x3e30 <dir_sdi.clone.4+0xec>
    3d66:	08 81       	ld	r16, Y
    3d68:	19 81       	ldd	r17, Y+1	; 0x01
    3d6a:	f8 01       	movw	r30, r16
    3d6c:	82 85       	ldd	r24, Z+10	; 0x0a
    3d6e:	93 85       	ldd	r25, Z+11	; 0x0b
    3d70:	a4 85       	ldd	r26, Z+12	; 0x0c
    3d72:	b5 85       	ldd	r27, Z+13	; 0x0d
    3d74:	48 17       	cp	r20, r24
    3d76:	59 07       	cpc	r21, r25
    3d78:	6a 07       	cpc	r22, r26
    3d7a:	7b 07       	cpc	r23, r27
    3d7c:	08 f0       	brcs	.+2      	; 0x3d80 <dir_sdi.clone.4+0x3c>
    3d7e:	58 c0       	rjmp	.+176    	; 0x3e30 <dir_sdi.clone.4+0xec>
		return FR_INT_ERR;
	if (!clst && dj->fs->fs_type == FS_FAT32)	/* Replace cluster# 0 with root cluster# if in FAT32 */
    3d80:	41 15       	cp	r20, r1
    3d82:	51 05       	cpc	r21, r1
    3d84:	61 05       	cpc	r22, r1
    3d86:	71 05       	cpc	r23, r1
    3d88:	f9 f4       	brne	.+62     	; 0x3dc8 <dir_sdi.clone.4+0x84>
    3d8a:	80 81       	ld	r24, Z
    3d8c:	83 30       	cpi	r24, 0x03	; 3
    3d8e:	49 f4       	brne	.+18     	; 0x3da2 <dir_sdi.clone.4+0x5e>
		clst = dj->fs->dirbase;
    3d90:	46 89       	ldd	r20, Z+22	; 0x16
    3d92:	57 89       	ldd	r21, Z+23	; 0x17
    3d94:	60 8d       	ldd	r22, Z+24	; 0x18
    3d96:	71 8d       	ldd	r23, Z+25	; 0x19

	if (clst == 0) {	/* Static table (root-dir in FAT12/16) */
    3d98:	41 15       	cp	r20, r1
    3d9a:	51 05       	cpc	r21, r1
    3d9c:	61 05       	cpc	r22, r1
    3d9e:	71 05       	cpc	r23, r1
    3da0:	99 f4       	brne	.+38     	; 0x3dc8 <dir_sdi.clone.4+0x84>
		dj->clust = clst;
    3da2:	1a 86       	std	Y+10, r1	; 0x0a
    3da4:	1b 86       	std	Y+11, r1	; 0x0b
    3da6:	1c 86       	std	Y+12, r1	; 0x0c
    3da8:	1d 86       	std	Y+13, r1	; 0x0d
		if (idx >= dj->fs->n_rootdir)		/* Index is out of range */
    3daa:	f8 01       	movw	r30, r16
    3dac:	80 85       	ldd	r24, Z+8	; 0x08
    3dae:	91 85       	ldd	r25, Z+9	; 0x09
    3db0:	00 97       	sbiw	r24, 0x00	; 0
    3db2:	09 f4       	brne	.+2      	; 0x3db6 <dir_sdi.clone.4+0x72>
    3db4:	3d c0       	rjmp	.+122    	; 0x3e30 <dir_sdi.clone.4+0xec>
			return FR_INT_ERR;
		dj->sect = dj->fs->dirbase + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3db6:	86 89       	ldd	r24, Z+22	; 0x16
    3db8:	97 89       	ldd	r25, Z+23	; 0x17
    3dba:	a0 8d       	ldd	r26, Z+24	; 0x18
    3dbc:	b1 8d       	ldd	r27, Z+25	; 0x19
    3dbe:	8e 87       	std	Y+14, r24	; 0x0e
    3dc0:	9f 87       	std	Y+15, r25	; 0x0f
    3dc2:	a8 8b       	std	Y+16, r26	; 0x10
    3dc4:	b9 8b       	std	Y+17, r27	; 0x11
    3dc6:	2c c0       	rjmp	.+88     	; 0x3e20 <dir_sdi.clone.4+0xdc>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
    3dc8:	f8 01       	movw	r30, r16
    3dca:	82 81       	ldd	r24, Z+2	; 0x02
		while (idx >= ic) {	/* Follow cluster chain */
    3dcc:	88 23       	and	r24, r24
    3dce:	f1 f4       	brne	.+60     	; 0x3e0c <dir_sdi.clone.4+0xc8>
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
    3dd0:	88 81       	ld	r24, Y
    3dd2:	99 81       	ldd	r25, Y+1	; 0x01
    3dd4:	f3 de       	rcall	.-538    	; 0x3bbc <get_fat>
    3dd6:	ab 01       	movw	r20, r22
    3dd8:	bc 01       	movw	r22, r24
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3dda:	4f 3f       	cpi	r20, 0xFF	; 255
    3ddc:	ff ef       	ldi	r31, 0xFF	; 255
    3dde:	5f 07       	cpc	r21, r31
    3de0:	ff ef       	ldi	r31, 0xFF	; 255
    3de2:	6f 07       	cpc	r22, r31
    3de4:	ff ef       	ldi	r31, 0xFF	; 255
    3de6:	7f 07       	cpc	r23, r31
    3de8:	09 f1       	breq	.+66     	; 0x3e2c <dir_sdi.clone.4+0xe8>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
    3dea:	42 30       	cpi	r20, 0x02	; 2
    3dec:	51 05       	cpc	r21, r1
    3dee:	61 05       	cpc	r22, r1
    3df0:	71 05       	cpc	r23, r1
    3df2:	f0 f0       	brcs	.+60     	; 0x3e30 <dir_sdi.clone.4+0xec>
    3df4:	e8 81       	ld	r30, Y
    3df6:	f9 81       	ldd	r31, Y+1	; 0x01
    3df8:	82 85       	ldd	r24, Z+10	; 0x0a
    3dfa:	93 85       	ldd	r25, Z+11	; 0x0b
    3dfc:	a4 85       	ldd	r26, Z+12	; 0x0c
    3dfe:	b5 85       	ldd	r27, Z+13	; 0x0d
    3e00:	48 17       	cp	r20, r24
    3e02:	59 07       	cpc	r21, r25
    3e04:	6a 07       	cpc	r22, r26
    3e06:	7b 07       	cpc	r23, r27
    3e08:	18 f3       	brcs	.-58     	; 0x3dd0 <dir_sdi.clone.4+0x8c>
    3e0a:	12 c0       	rjmp	.+36     	; 0x3e30 <dir_sdi.clone.4+0xec>
				return FR_INT_ERR;
			idx -= ic;
		}
		dj->clust = clst;
    3e0c:	4a 87       	std	Y+10, r20	; 0x0a
    3e0e:	5b 87       	std	Y+11, r21	; 0x0b
    3e10:	6c 87       	std	Y+12, r22	; 0x0c
    3e12:	7d 87       	std	Y+13, r23	; 0x0d
		dj->sect = clust2sect(dj->fs, clst) + idx / (SS(dj->fs) / SZ_DIR);	/* Sector# */
    3e14:	c8 01       	movw	r24, r16
    3e16:	a3 de       	rcall	.-698    	; 0x3b5e <clust2sect>
    3e18:	6e 87       	std	Y+14, r22	; 0x0e
    3e1a:	7f 87       	std	Y+15, r23	; 0x0f
    3e1c:	88 8b       	std	Y+16, r24	; 0x10
    3e1e:	99 8b       	std	Y+17, r25	; 0x11
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */
    3e20:	0e 5d       	subi	r16, 0xDE	; 222
    3e22:	1f 4f       	sbci	r17, 0xFF	; 255
    3e24:	1b 8b       	std	Y+19, r17	; 0x13
    3e26:	0a 8b       	std	Y+18, r16	; 0x12

	return FR_OK;	/* Seek succeeded */
    3e28:	80 e0       	ldi	r24, 0x00	; 0
    3e2a:	03 c0       	rjmp	.+6      	; 0x3e32 <dir_sdi.clone.4+0xee>
	}
	else {				/* Dynamic table (sub-dirs or root-dir in FAT32) */
		ic = SS(dj->fs) / SZ_DIR * dj->fs->csize;	/* Entries per cluster */
		while (idx >= ic) {	/* Follow cluster chain */
			clst = get_fat(dj->fs, clst);				/* Get next cluster */
			if (clst == 0xFFFFFFFF) return FR_DISK_ERR;	/* Disk error */
    3e2c:	81 e0       	ldi	r24, 0x01	; 1
    3e2e:	01 c0       	rjmp	.+2      	; 0x3e32 <dir_sdi.clone.4+0xee>
			if (clst < 2 || clst >= dj->fs->n_fatent)	/* Reached to end of table or int error */
				return FR_INT_ERR;
    3e30:	82 e0       	ldi	r24, 0x02	; 2
	}

	dj->dir = dj->fs->win + (idx % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;	/* Ptr to the entry in the sector */

	return FR_OK;	/* Seek succeeded */
}
    3e32:	df 91       	pop	r29
    3e34:	cf 91       	pop	r28
    3e36:	1f 91       	pop	r17
    3e38:	0f 91       	pop	r16
    3e3a:	08 95       	ret

00003e3c <f_mount>:
)
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
    3e3c:	88 23       	and	r24, r24
    3e3e:	91 f4       	brne	.+36     	; 0x3e64 <f_mount+0x28>
		return FR_INVALID_DRIVE;
	rfs = FatFs[vol];			/* Get current fs object */
    3e40:	e0 91 d2 03 	lds	r30, 0x03D2
    3e44:	f0 91 d3 03 	lds	r31, 0x03D3

	if (rfs) {
    3e48:	30 97       	sbiw	r30, 0x00	; 0
    3e4a:	09 f0       	breq	.+2      	; 0x3e4e <f_mount+0x12>
		clear_lock(rfs);
#endif
#if _FS_REENTRANT				/* Discard sync object of the current volume */
		if (!ff_del_syncobj(rfs->sobj)) return FR_INT_ERR;
#endif
		rfs->fs_type = 0;		/* Clear old fs object */
    3e4c:	10 82       	st	Z, r1
	}

	if (fs) {
    3e4e:	61 15       	cp	r22, r1
    3e50:	71 05       	cpc	r23, r1
    3e52:	11 f0       	breq	.+4      	; 0x3e58 <f_mount+0x1c>
		fs->fs_type = 0;		/* Clear new fs object */
    3e54:	fb 01       	movw	r30, r22
    3e56:	10 82       	st	Z, r1
#if _FS_REENTRANT				/* Create sync object for the new volume */
		if (!ff_cre_syncobj(vol, &fs->sobj)) return FR_INT_ERR;
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */
    3e58:	70 93 d3 03 	sts	0x03D3, r23
    3e5c:	60 93 d2 03 	sts	0x03D2, r22

	return FR_OK;
    3e60:	80 e0       	ldi	r24, 0x00	; 0
    3e62:	08 95       	ret
{
	FATFS *rfs;


	if (vol >= _VOLUMES)		/* Check if the drive number is valid */
		return FR_INVALID_DRIVE;
    3e64:	8b e0       	ldi	r24, 0x0B	; 11
#endif
	}
	FatFs[vol] = fs;			/* Register new fs object */

	return FR_OK;
}
    3e66:	08 95       	ret

00003e68 <f_open>:
FRESULT f_open (
	FIL *fp,			/* Pointer to the blank file object */
	const TCHAR *path,	/* Pointer to the file name */
	BYTE mode			/* Access mode and file open mode flags */
)
{
    3e68:	2f 92       	push	r2
    3e6a:	3f 92       	push	r3
    3e6c:	4f 92       	push	r4
    3e6e:	5f 92       	push	r5
    3e70:	6f 92       	push	r6
    3e72:	7f 92       	push	r7
    3e74:	8f 92       	push	r8
    3e76:	9f 92       	push	r9
    3e78:	af 92       	push	r10
    3e7a:	bf 92       	push	r11
    3e7c:	cf 92       	push	r12
    3e7e:	df 92       	push	r13
    3e80:	ef 92       	push	r14
    3e82:	ff 92       	push	r15
    3e84:	0f 93       	push	r16
    3e86:	1f 93       	push	r17
    3e88:	df 93       	push	r29
    3e8a:	cf 93       	push	r28
    3e8c:	cd b7       	in	r28, 0x3d	; 61
    3e8e:	de b7       	in	r29, 0x3e	; 62
    3e90:	e8 97       	sbiw	r28, 0x38	; 56
    3e92:	0f b6       	in	r0, 0x3f	; 63
    3e94:	f8 94       	cli
    3e96:	de bf       	out	0x3e, r29	; 62
    3e98:	0f be       	out	0x3f, r0	; 63
    3e9a:	cd bf       	out	0x3d, r28	; 61
    3e9c:	9c a3       	std	Y+36, r25	; 0x24
    3e9e:	8b a3       	std	Y+35, r24	; 0x23
    3ea0:	7b 01       	movw	r14, r22
    3ea2:	4f ab       	std	Y+55, r20	; 0x37
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    3ea4:	00 97       	sbiw	r24, 0x00	; 0
    3ea6:	09 f4       	brne	.+2      	; 0x3eaa <f_open+0x42>
    3ea8:	69 c3       	rjmp	.+1746   	; 0x457c <f_open+0x714>
	fp->fs = 0;			/* Clear file object */
    3eaa:	dc 01       	movw	r26, r24
    3eac:	11 96       	adiw	r26, 0x01	; 1
    3eae:	1c 92       	st	X, r1
    3eb0:	1e 92       	st	-X, r1
	const TCHAR *p = *path;
	FATFS *fs;


	/* Get logical drive number from the path name */
	vol = p[0] - '0';					/* Is there a drive number? */
    3eb2:	fb 01       	movw	r30, r22
    3eb4:	80 81       	ld	r24, Z
    3eb6:	90 e0       	ldi	r25, 0x00	; 0
    3eb8:	c0 97       	sbiw	r24, 0x30	; 48
	if (vol <= 9 && p[1] == ':') {		/* Found a drive number, get and strip it */
    3eba:	8a 30       	cpi	r24, 0x0A	; 10
    3ebc:	91 05       	cpc	r25, r1
    3ebe:	40 f4       	brcc	.+16     	; 0x3ed0 <f_open+0x68>
    3ec0:	21 81       	ldd	r18, Z+1	; 0x01
    3ec2:	2a 33       	cpi	r18, 0x3A	; 58
    3ec4:	29 f4       	brne	.+10     	; 0x3ed0 <f_open+0x68>
		p += 2; *path = p;				/* Return pointer to the path name */
    3ec6:	22 e0       	ldi	r18, 0x02	; 2
    3ec8:	30 e0       	ldi	r19, 0x00	; 0
    3eca:	e2 0e       	add	r14, r18
    3ecc:	f3 1e       	adc	r15, r19
    3ece:	02 c0       	rjmp	.+4      	; 0x3ed4 <f_open+0x6c>
	} else {							/* No drive number is given */
#if _FS_RPATH
		vol = CurrVol;					/* Use current drive */
#else
		vol = 0;						/* Use drive 0 */
    3ed0:	80 e0       	ldi	r24, 0x00	; 0
    3ed2:	90 e0       	ldi	r25, 0x00	; 0
#endif
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
    3ed4:	00 97       	sbiw	r24, 0x00	; 0
    3ed6:	09 f0       	breq	.+2      	; 0x3eda <f_open+0x72>
    3ed8:	aa c1       	rjmp	.+852    	; 0x422e <f_open+0x3c6>
		return FR_INVALID_DRIVE;
	fs = FatFs[vol];					/* Get corresponding file system object */
    3eda:	00 91 d2 03 	lds	r16, 0x03D2
    3ede:	10 91 d3 03 	lds	r17, 0x03D3
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    3ee2:	01 15       	cp	r16, r1
    3ee4:	11 05       	cpc	r17, r1
    3ee6:	09 f4       	brne	.+2      	; 0x3eea <f_open+0x82>
    3ee8:	a4 c1       	rjmp	.+840    	; 0x4232 <f_open+0x3ca>

	ENTER_FF(fs);						/* Lock file system */

	*rfs = fs;							/* Return pointer to the corresponding file system object */
    3eea:	1e 87       	std	Y+14, r17	; 0x0e
    3eec:	0d 87       	std	Y+13, r16	; 0x0d
	if (fs->fs_type) {					/* If the volume has been mounted */
    3eee:	d8 01       	movw	r26, r16
    3ef0:	8c 91       	ld	r24, X
    3ef2:	88 23       	and	r24, r24
    3ef4:	29 f0       	breq	.+10     	; 0x3f00 <f_open+0x98>
		stat = disk_status(fs->drv);
    3ef6:	11 96       	adiw	r26, 0x01	; 1
    3ef8:	8c 91       	ld	r24, X
    3efa:	7a dd       	rcall	.-1292   	; 0x39f0 <disk_status>
		if (!(stat & STA_NOINIT)) {		/* and the physical drive is kept initialized (has not been changed), */
    3efc:	80 ff       	sbrs	r24, 0
    3efe:	59 c3       	rjmp	.+1714   	; 0x45b2 <f_open+0x74a>
	}

	/* The file system object is not valid. */
	/* Following code attempts to mount the volume. (analyze BPB and initialize the fs object) */

	fs->fs_type = 0;					/* Clear the file system object */
    3f00:	f8 01       	movw	r30, r16
    3f02:	10 82       	st	Z, r1
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
    3f04:	11 82       	std	Z+1, r1	; 0x01
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
    3f06:	80 e0       	ldi	r24, 0x00	; 0
    3f08:	71 dd       	rcall	.-1310   	; 0x39ec <disk_initialize>
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
    3f0a:	80 fd       	sbrc	r24, 0
    3f0c:	94 c1       	rjmp	.+808    	; 0x4236 <f_open+0x3ce>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3f0e:	c8 01       	movw	r24, r16
    3f10:	40 e0       	ldi	r20, 0x00	; 0
    3f12:	50 e0       	ldi	r21, 0x00	; 0
    3f14:	ba 01       	movw	r22, r20
    3f16:	c8 dd       	rcall	.-1136   	; 0x3aa8 <check_fs>
	if (LD2PT(vol) && !fmt) fmt = 1;	/* Force non-SFD if the volume is forced partition */
	if (fmt == 1) {						/* Not an FAT-VBR, the physical drive can be partitioned */
    3f18:	81 30       	cpi	r24, 0x01	; 1
    3f1a:	b9 f4       	brne	.+46     	; 0x3f4a <f_open+0xe2>
		/* Check the partition listed in the partition table */
		pi = LD2PT(vol);
		if (pi) pi--;
		tbl = &fs->win[MBR_Table + pi * SZ_PTE];/* Partition table */
		if (tbl[4]) {						/* Is the partition existing? */
    3f1c:	f8 01       	movw	r30, r16
    3f1e:	ec 51       	subi	r30, 0x1C	; 28
    3f20:	fe 4f       	sbci	r31, 0xFE	; 254
    3f22:	80 81       	ld	r24, Z
    3f24:	88 23       	and	r24, r24
    3f26:	09 f4       	brne	.+2      	; 0x3f2a <f_open+0xc2>
    3f28:	8a c1       	rjmp	.+788    	; 0x423e <f_open+0x3d6>
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
    3f2a:	f8 01       	movw	r30, r16
    3f2c:	e8 51       	subi	r30, 0x18	; 24
    3f2e:	fe 4f       	sbci	r31, 0xFE	; 254
    3f30:	20 81       	ld	r18, Z
    3f32:	31 81       	ldd	r19, Z+1	; 0x01
    3f34:	42 81       	ldd	r20, Z+2	; 0x02
    3f36:	53 81       	ldd	r21, Z+3	; 0x03
    3f38:	2b a7       	std	Y+43, r18	; 0x2b
    3f3a:	3c a7       	std	Y+44, r19	; 0x2c
    3f3c:	4d a7       	std	Y+45, r20	; 0x2d
    3f3e:	5e a7       	std	Y+46, r21	; 0x2e
			fmt = check_fs(fs, bsect);		/* Check the partition */
    3f40:	c8 01       	movw	r24, r16
    3f42:	ba 01       	movw	r22, r20
    3f44:	a9 01       	movw	r20, r18
    3f46:	b0 dd       	rcall	.-1184   	; 0x3aa8 <check_fs>
    3f48:	04 c0       	rjmp	.+8      	; 0x3f52 <f_open+0xea>
#if _MAX_SS != 512						/* Get disk sector size (variable sector size cfg only) */
	if (disk_ioctl(fs->drv, GET_SECTOR_SIZE, &fs->ssize) != RES_OK)
		return FR_DISK_ERR;
#endif
	/* Search FAT partition on the drive. Supports only generic partitions, FDISK and SFD. */
	fmt = check_fs(fs, bsect = 0);		/* Load sector 0 and check if it is an FAT-VBR (in SFD) */
    3f4a:	1b a6       	std	Y+43, r1	; 0x2b
    3f4c:	1c a6       	std	Y+44, r1	; 0x2c
    3f4e:	1d a6       	std	Y+45, r1	; 0x2d
    3f50:	1e a6       	std	Y+46, r1	; 0x2e
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    3f52:	83 30       	cpi	r24, 0x03	; 3
    3f54:	09 f4       	brne	.+2      	; 0x3f58 <f_open+0xf0>
    3f56:	71 c1       	rjmp	.+738    	; 0x423a <f_open+0x3d2>
	if (fmt) return FR_NO_FILESYSTEM;		/* No FAT volume is found */
    3f58:	88 23       	and	r24, r24
    3f5a:	09 f0       	breq	.+2      	; 0x3f5e <f_open+0xf6>
    3f5c:	70 c1       	rjmp	.+736    	; 0x423e <f_open+0x3d6>

	/* An FAT volume is found. Following code initializes the file system object */

	if (LD_WORD(fs->win+BPB_BytsPerSec) != SS(fs))		/* (BPB_BytsPerSec must be equal to the physical sector size) */
    3f5e:	b2 e2       	ldi	r27, 0x22	; 34
    3f60:	4b 2e       	mov	r4, r27
    3f62:	51 2c       	mov	r5, r1
    3f64:	40 0e       	add	r4, r16
    3f66:	51 1e       	adc	r5, r17
    3f68:	d2 01       	movw	r26, r4
    3f6a:	1b 96       	adiw	r26, 0x0b	; 11
    3f6c:	8d 91       	ld	r24, X+
    3f6e:	9c 91       	ld	r25, X
    3f70:	1c 97       	sbiw	r26, 0x0c	; 12
    3f72:	b2 e0       	ldi	r27, 0x02	; 2
    3f74:	80 30       	cpi	r24, 0x00	; 0
    3f76:	9b 07       	cpc	r25, r27
    3f78:	09 f0       	breq	.+2      	; 0x3f7c <f_open+0x114>
    3f7a:	61 c1       	rjmp	.+706    	; 0x423e <f_open+0x3d6>
		return FR_NO_FILESYSTEM;

	fasize = LD_WORD(fs->win+BPB_FATSz16);				/* Number of sectors per FAT */
    3f7c:	f2 01       	movw	r30, r4
    3f7e:	86 89       	ldd	r24, Z+22	; 0x16
    3f80:	97 89       	ldd	r25, Z+23	; 0x17
    3f82:	9c 01       	movw	r18, r24
    3f84:	40 e0       	ldi	r20, 0x00	; 0
    3f86:	50 e0       	ldi	r21, 0x00	; 0
    3f88:	2d a3       	std	Y+37, r18	; 0x25
    3f8a:	3e a3       	std	Y+38, r19	; 0x26
    3f8c:	4f a3       	std	Y+39, r20	; 0x27
    3f8e:	58 a7       	std	Y+40, r21	; 0x28
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
    3f90:	21 15       	cp	r18, r1
    3f92:	31 05       	cpc	r19, r1
    3f94:	41 05       	cpc	r20, r1
    3f96:	51 05       	cpc	r21, r1
    3f98:	59 f4       	brne	.+22     	; 0x3fb0 <f_open+0x148>
    3f9a:	d2 01       	movw	r26, r4
    3f9c:	94 96       	adiw	r26, 0x24	; 36
    3f9e:	8d 91       	ld	r24, X+
    3fa0:	9d 91       	ld	r25, X+
    3fa2:	0d 90       	ld	r0, X+
    3fa4:	bc 91       	ld	r27, X
    3fa6:	a0 2d       	mov	r26, r0
    3fa8:	8d a3       	std	Y+37, r24	; 0x25
    3faa:	9e a3       	std	Y+38, r25	; 0x26
    3fac:	af a3       	std	Y+39, r26	; 0x27
    3fae:	b8 a7       	std	Y+40, r27	; 0x28
	fs->fsize = fasize;
    3fb0:	2d a1       	ldd	r18, Y+37	; 0x25
    3fb2:	3e a1       	ldd	r19, Y+38	; 0x26
    3fb4:	4f a1       	ldd	r20, Y+39	; 0x27
    3fb6:	58 a5       	ldd	r21, Y+40	; 0x28
    3fb8:	d8 01       	movw	r26, r16
    3fba:	1e 96       	adiw	r26, 0x0e	; 14
    3fbc:	2d 93       	st	X+, r18
    3fbe:	3d 93       	st	X+, r19
    3fc0:	4d 93       	st	X+, r20
    3fc2:	5c 93       	st	X, r21
    3fc4:	51 97       	sbiw	r26, 0x11	; 17

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
    3fc6:	d2 96       	adiw	r26, 0x32	; 50
    3fc8:	2c 91       	ld	r18, X
    3fca:	d2 97       	sbiw	r26, 0x32	; 50
    3fcc:	13 96       	adiw	r26, 0x03	; 3
    3fce:	2c 93       	st	X, r18
    3fd0:	13 97       	sbiw	r26, 0x03	; 3
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
    3fd2:	82 2f       	mov	r24, r18
    3fd4:	81 50       	subi	r24, 0x01	; 1
    3fd6:	82 30       	cpi	r24, 0x02	; 2
    3fd8:	08 f0       	brcs	.+2      	; 0x3fdc <f_open+0x174>
    3fda:	31 c1       	rjmp	.+610    	; 0x423e <f_open+0x3d6>
	fasize *= b;										/* Number of sectors for FAT area */

	fs->csize = b = fs->win[BPB_SecPerClus];			/* Number of sectors per cluster */
    3fdc:	9f 96       	adiw	r26, 0x2f	; 47
    3fde:	3c 90       	ld	r3, X
    3fe0:	9f 97       	sbiw	r26, 0x2f	; 47
    3fe2:	12 96       	adiw	r26, 0x02	; 2
    3fe4:	3c 92       	st	X, r3
    3fe6:	12 97       	sbiw	r26, 0x02	; 2
	if (!b || (b & (b - 1))) return FR_NO_FILESYSTEM;	/* (Must be power of 2) */
    3fe8:	33 20       	and	r3, r3
    3fea:	09 f4       	brne	.+2      	; 0x3fee <f_open+0x186>
    3fec:	28 c1       	rjmp	.+592    	; 0x423e <f_open+0x3d6>
    3fee:	43 2d       	mov	r20, r3
    3ff0:	50 e0       	ldi	r21, 0x00	; 0
    3ff2:	ca 01       	movw	r24, r20
    3ff4:	01 97       	sbiw	r24, 0x01	; 1
    3ff6:	84 23       	and	r24, r20
    3ff8:	95 23       	and	r25, r21
    3ffa:	00 97       	sbiw	r24, 0x00	; 0
    3ffc:	09 f0       	breq	.+2      	; 0x4000 <f_open+0x198>
    3ffe:	1f c1       	rjmp	.+574    	; 0x423e <f_open+0x3d6>

	fs->n_rootdir = LD_WORD(fs->win+BPB_RootEntCnt);	/* Number of root directory entries */
    4000:	f2 01       	movw	r30, r4
    4002:	01 88       	ldd	r0, Z+17	; 0x11
    4004:	f2 89       	ldd	r31, Z+18	; 0x12
    4006:	e0 2d       	mov	r30, r0
    4008:	fa a7       	std	Y+42, r31	; 0x2a
    400a:	e9 a7       	std	Y+41, r30	; 0x29
    400c:	19 96       	adiw	r26, 0x09	; 9
    400e:	fc 93       	st	X, r31
    4010:	ee 93       	st	-X, r30
    4012:	18 97       	sbiw	r26, 0x08	; 8
	if (fs->n_rootdir % (SS(fs) / SZ_DIR)) return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must be sector aligned) */
    4014:	cf 01       	movw	r24, r30
    4016:	8f 70       	andi	r24, 0x0F	; 15
    4018:	90 70       	andi	r25, 0x00	; 0
    401a:	00 97       	sbiw	r24, 0x00	; 0
    401c:	09 f0       	breq	.+2      	; 0x4020 <f_open+0x1b8>
    401e:	0f c1       	rjmp	.+542    	; 0x423e <f_open+0x3d6>

	tsect = LD_WORD(fs->win+BPB_TotSec16);				/* Number of sectors on the volume */
    4020:	d2 01       	movw	r26, r4
    4022:	53 96       	adiw	r26, 0x13	; 19
    4024:	6d 90       	ld	r6, X+
    4026:	7c 90       	ld	r7, X
    4028:	54 97       	sbiw	r26, 0x14	; 20
    402a:	88 24       	eor	r8, r8
    402c:	99 24       	eor	r9, r9
	if (!tsect) tsect = LD_DWORD(fs->win+BPB_TotSec32);
    402e:	61 14       	cp	r6, r1
    4030:	71 04       	cpc	r7, r1
    4032:	81 04       	cpc	r8, r1
    4034:	91 04       	cpc	r9, r1
    4036:	31 f4       	brne	.+12     	; 0x4044 <f_open+0x1dc>
    4038:	90 96       	adiw	r26, 0x20	; 32
    403a:	6d 90       	ld	r6, X+
    403c:	7d 90       	ld	r7, X+
    403e:	8d 90       	ld	r8, X+
    4040:	9c 90       	ld	r9, X
    4042:	93 97       	sbiw	r26, 0x23	; 35

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
    4044:	f2 01       	movw	r30, r4
    4046:	a6 84       	ldd	r10, Z+14	; 0x0e
    4048:	b7 84       	ldd	r11, Z+15	; 0x0f
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */
    404a:	a1 14       	cp	r10, r1
    404c:	b1 04       	cpc	r11, r1
    404e:	09 f4       	brne	.+2      	; 0x4052 <f_open+0x1ea>
    4050:	f6 c0       	rjmp	.+492    	; 0x423e <f_open+0x3d6>
	if (!fasize) fasize = LD_DWORD(fs->win+BPB_FATSz32);
	fs->fsize = fasize;

	fs->n_fats = b = fs->win[BPB_NumFATs];				/* Number of FAT copies */
	if (b != 1 && b != 2) return FR_NO_FILESYSTEM;		/* (Must be 1 or 2) */
	fasize *= b;										/* Number of sectors for FAT area */
    4052:	30 e0       	ldi	r19, 0x00	; 0
    4054:	40 e0       	ldi	r20, 0x00	; 0
    4056:	50 e0       	ldi	r21, 0x00	; 0
    4058:	6d a1       	ldd	r22, Y+37	; 0x25
    405a:	7e a1       	ldd	r23, Y+38	; 0x26
    405c:	8f a1       	ldd	r24, Y+39	; 0x27
    405e:	98 a5       	ldd	r25, Y+40	; 0x28
    4060:	0e 94 8e 3c 	call	0x791c	; 0x791c <__mulsi3>
    4064:	6f a7       	std	Y+47, r22	; 0x2f
    4066:	78 ab       	std	Y+48, r23	; 0x30
    4068:	89 ab       	std	Y+49, r24	; 0x31
    406a:	9a ab       	std	Y+50, r25	; 0x32

	nrsv = LD_WORD(fs->win+BPB_RsvdSecCnt);				/* Number of reserved sectors */
	if (!nrsv) return FR_NO_FILESYSTEM;					/* (BPB_RsvdSecCnt must not be 0) */

	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
    406c:	95 01       	movw	r18, r10
    406e:	40 e0       	ldi	r20, 0x00	; 0
    4070:	50 e0       	ldi	r21, 0x00	; 0
    4072:	2b ab       	std	Y+51, r18	; 0x33
    4074:	3c ab       	std	Y+52, r19	; 0x34
    4076:	4d ab       	std	Y+53, r20	; 0x35
    4078:	5e ab       	std	Y+54, r21	; 0x36
    407a:	a9 a4       	ldd	r10, Y+41	; 0x29
    407c:	ba a4       	ldd	r11, Y+42	; 0x2a
    407e:	a4 e0       	ldi	r26, 0x04	; 4
    4080:	b6 94       	lsr	r11
    4082:	a7 94       	ror	r10
    4084:	aa 95       	dec	r26
    4086:	e1 f7       	brne	.-8      	; 0x4080 <f_open+0x218>
    4088:	cc 24       	eor	r12, r12
    408a:	dd 24       	eor	r13, r13
    408c:	a2 0e       	add	r10, r18
    408e:	b3 1e       	adc	r11, r19
    4090:	c4 1e       	adc	r12, r20
    4092:	d5 1e       	adc	r13, r21
    4094:	a6 0e       	add	r10, r22
    4096:	b7 1e       	adc	r11, r23
    4098:	c8 1e       	adc	r12, r24
    409a:	d9 1e       	adc	r13, r25
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
    409c:	6a 14       	cp	r6, r10
    409e:	7b 04       	cpc	r7, r11
    40a0:	8c 04       	cpc	r8, r12
    40a2:	9d 04       	cpc	r9, r13
    40a4:	08 f4       	brcc	.+2      	; 0x40a8 <f_open+0x240>
    40a6:	cb c0       	rjmp	.+406    	; 0x423e <f_open+0x3d6>
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
    40a8:	c4 01       	movw	r24, r8
    40aa:	b3 01       	movw	r22, r6
    40ac:	6a 19       	sub	r22, r10
    40ae:	7b 09       	sbc	r23, r11
    40b0:	8c 09       	sbc	r24, r12
    40b2:	9d 09       	sbc	r25, r13
    40b4:	23 2d       	mov	r18, r3
    40b6:	30 e0       	ldi	r19, 0x00	; 0
    40b8:	40 e0       	ldi	r20, 0x00	; 0
    40ba:	50 e0       	ldi	r21, 0x00	; 0
    40bc:	0e 94 ad 3c 	call	0x795a	; 0x795a <__udivmodsi4>
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
    40c0:	21 15       	cp	r18, r1
    40c2:	31 05       	cpc	r19, r1
    40c4:	41 05       	cpc	r20, r1
    40c6:	51 05       	cpc	r21, r1
    40c8:	09 f4       	brne	.+2      	; 0x40cc <f_open+0x264>
    40ca:	b9 c0       	rjmp	.+370    	; 0x423e <f_open+0x3d6>
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    40cc:	26 3f       	cpi	r18, 0xF6	; 246
    40ce:	8f e0       	ldi	r24, 0x0F	; 15
    40d0:	38 07       	cpc	r19, r24
    40d2:	80 e0       	ldi	r24, 0x00	; 0
    40d4:	48 07       	cpc	r20, r24
    40d6:	80 e0       	ldi	r24, 0x00	; 0
    40d8:	58 07       	cpc	r21, r24
    40da:	50 f0       	brcs	.+20     	; 0x40f0 <f_open+0x288>
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    40dc:	26 3f       	cpi	r18, 0xF6	; 246
    40de:	9f ef       	ldi	r25, 0xFF	; 255
    40e0:	39 07       	cpc	r19, r25
    40e2:	90 e0       	ldi	r25, 0x00	; 0
    40e4:	49 07       	cpc	r20, r25
    40e6:	90 e0       	ldi	r25, 0x00	; 0
    40e8:	59 07       	cpc	r21, r25
    40ea:	20 f4       	brcc	.+8      	; 0x40f4 <f_open+0x28c>
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
    40ec:	62 e0       	ldi	r22, 0x02	; 2
    40ee:	03 c0       	rjmp	.+6      	; 0x40f6 <f_open+0x28e>
	/* Determine the FAT sub type */
	sysect = nrsv + fasize + fs->n_rootdir / (SS(fs) / SZ_DIR);	/* RSV+FAT+DIR */
	if (tsect < sysect) return FR_NO_FILESYSTEM;		/* (Invalid volume size) */
	nclst = (tsect - sysect) / fs->csize;				/* Number of clusters */
	if (!nclst) return FR_NO_FILESYSTEM;				/* (Invalid volume size) */
	fmt = FS_FAT12;
    40f0:	61 e0       	ldi	r22, 0x01	; 1
    40f2:	01 c0       	rjmp	.+2      	; 0x40f6 <f_open+0x28e>
	if (nclst >= MIN_FAT16) fmt = FS_FAT16;
	if (nclst >= MIN_FAT32) fmt = FS_FAT32;
    40f4:	63 e0       	ldi	r22, 0x03	; 3

	/* Boundaries and Limits */
	fs->n_fatent = nclst + 2;							/* Number of FAT entries */
    40f6:	2e 5f       	subi	r18, 0xFE	; 254
    40f8:	3f 4f       	sbci	r19, 0xFF	; 255
    40fa:	4f 4f       	sbci	r20, 0xFF	; 255
    40fc:	5f 4f       	sbci	r21, 0xFF	; 255
    40fe:	d8 01       	movw	r26, r16
    4100:	1a 96       	adiw	r26, 0x0a	; 10
    4102:	2d 93       	st	X+, r18
    4104:	3d 93       	st	X+, r19
    4106:	4d 93       	st	X+, r20
    4108:	5c 93       	st	X, r21
    410a:	1d 97       	sbiw	r26, 0x0d	; 13
	fs->database = bsect + sysect;						/* Data start sector */
    410c:	8b a5       	ldd	r24, Y+43	; 0x2b
    410e:	9c a5       	ldd	r25, Y+44	; 0x2c
    4110:	ad a5       	ldd	r26, Y+45	; 0x2d
    4112:	be a5       	ldd	r27, Y+46	; 0x2e
    4114:	a8 0e       	add	r10, r24
    4116:	b9 1e       	adc	r11, r25
    4118:	ca 1e       	adc	r12, r26
    411a:	db 1e       	adc	r13, r27
    411c:	d8 01       	movw	r26, r16
    411e:	5a 96       	adiw	r26, 0x1a	; 26
    4120:	ad 92       	st	X+, r10
    4122:	bd 92       	st	X+, r11
    4124:	cd 92       	st	X+, r12
    4126:	dc 92       	st	X, r13
    4128:	5d 97       	sbiw	r26, 0x1d	; 29
	fs->fatbase = bsect + nrsv; 						/* FAT start sector */
    412a:	ab a4       	ldd	r10, Y+43	; 0x2b
    412c:	bc a4       	ldd	r11, Y+44	; 0x2c
    412e:	cd a4       	ldd	r12, Y+45	; 0x2d
    4130:	de a4       	ldd	r13, Y+46	; 0x2e
    4132:	8b a9       	ldd	r24, Y+51	; 0x33
    4134:	9c a9       	ldd	r25, Y+52	; 0x34
    4136:	ad a9       	ldd	r26, Y+53	; 0x35
    4138:	be a9       	ldd	r27, Y+54	; 0x36
    413a:	a8 0e       	add	r10, r24
    413c:	b9 1e       	adc	r11, r25
    413e:	ca 1e       	adc	r12, r26
    4140:	db 1e       	adc	r13, r27
    4142:	d8 01       	movw	r26, r16
    4144:	52 96       	adiw	r26, 0x12	; 18
    4146:	ad 92       	st	X+, r10
    4148:	bd 92       	st	X+, r11
    414a:	cd 92       	st	X+, r12
    414c:	dc 92       	st	X, r13
    414e:	55 97       	sbiw	r26, 0x15	; 21
	if (fmt == FS_FAT32) {
    4150:	63 30       	cpi	r22, 0x03	; 3
    4152:	c9 f4       	brne	.+50     	; 0x4186 <f_open+0x31e>
		if (fs->n_rootdir) return FR_NO_FILESYSTEM;		/* (BPB_RootEntCnt must be 0) */
    4154:	e9 a5       	ldd	r30, Y+41	; 0x29
    4156:	fa a5       	ldd	r31, Y+42	; 0x2a
    4158:	30 97       	sbiw	r30, 0x00	; 0
    415a:	09 f0       	breq	.+2      	; 0x415e <f_open+0x2f6>
    415c:	70 c0       	rjmp	.+224    	; 0x423e <f_open+0x3d6>
		fs->dirbase = LD_DWORD(fs->win+BPB_RootClus);	/* Root directory start cluster */
    415e:	f2 01       	movw	r30, r4
    4160:	84 a5       	ldd	r24, Z+44	; 0x2c
    4162:	95 a5       	ldd	r25, Z+45	; 0x2d
    4164:	a6 a5       	ldd	r26, Z+46	; 0x2e
    4166:	b7 a5       	ldd	r27, Z+47	; 0x2f
    4168:	f8 01       	movw	r30, r16
    416a:	86 8b       	std	Z+22, r24	; 0x16
    416c:	97 8b       	std	Z+23, r25	; 0x17
    416e:	a0 8f       	std	Z+24, r26	; 0x18
    4170:	b1 8f       	std	Z+25, r27	; 0x19
		szbfat = fs->n_fatent * 4;						/* (Required FAT size) */
    4172:	da 01       	movw	r26, r20
    4174:	c9 01       	movw	r24, r18
    4176:	f2 e0       	ldi	r31, 0x02	; 2
    4178:	88 0f       	add	r24, r24
    417a:	99 1f       	adc	r25, r25
    417c:	aa 1f       	adc	r26, r26
    417e:	bb 1f       	adc	r27, r27
    4180:	fa 95       	dec	r31
    4182:	d1 f7       	brne	.-12     	; 0x4178 <f_open+0x310>
    4184:	2a c0       	rjmp	.+84     	; 0x41da <f_open+0x372>
	} else {
		if (!fs->n_rootdir)	return FR_NO_FILESYSTEM;	/* (BPB_RootEntCnt must not be 0) */
    4186:	89 a5       	ldd	r24, Y+41	; 0x29
    4188:	9a a5       	ldd	r25, Y+42	; 0x2a
    418a:	00 97       	sbiw	r24, 0x00	; 0
    418c:	09 f4       	brne	.+2      	; 0x4190 <f_open+0x328>
    418e:	57 c0       	rjmp	.+174    	; 0x423e <f_open+0x3d6>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
    4190:	8f a5       	ldd	r24, Y+47	; 0x2f
    4192:	98 a9       	ldd	r25, Y+48	; 0x30
    4194:	a9 a9       	ldd	r26, Y+49	; 0x31
    4196:	ba a9       	ldd	r27, Y+50	; 0x32
    4198:	8a 0d       	add	r24, r10
    419a:	9b 1d       	adc	r25, r11
    419c:	ac 1d       	adc	r26, r12
    419e:	bd 1d       	adc	r27, r13
    41a0:	f8 01       	movw	r30, r16
    41a2:	86 8b       	std	Z+22, r24	; 0x16
    41a4:	97 8b       	std	Z+23, r25	; 0x17
    41a6:	a0 8f       	std	Z+24, r26	; 0x18
    41a8:	b1 8f       	std	Z+25, r27	; 0x19
    41aa:	da 01       	movw	r26, r20
    41ac:	c9 01       	movw	r24, r18
    41ae:	88 0f       	add	r24, r24
    41b0:	99 1f       	adc	r25, r25
    41b2:	aa 1f       	adc	r26, r26
    41b4:	bb 1f       	adc	r27, r27
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
    41b6:	62 30       	cpi	r22, 0x02	; 2
    41b8:	81 f0       	breq	.+32     	; 0x41da <f_open+0x372>
    41ba:	82 0f       	add	r24, r18
    41bc:	93 1f       	adc	r25, r19
    41be:	a4 1f       	adc	r26, r20
    41c0:	b5 1f       	adc	r27, r21
    41c2:	b6 95       	lsr	r27
    41c4:	a7 95       	ror	r26
    41c6:	97 95       	ror	r25
    41c8:	87 95       	ror	r24
    41ca:	21 70       	andi	r18, 0x01	; 1
    41cc:	30 70       	andi	r19, 0x00	; 0
    41ce:	40 70       	andi	r20, 0x00	; 0
    41d0:	50 70       	andi	r21, 0x00	; 0
    41d2:	82 0f       	add	r24, r18
    41d4:	93 1f       	adc	r25, r19
    41d6:	a4 1f       	adc	r26, r20
    41d8:	b5 1f       	adc	r27, r21
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
    41da:	81 50       	subi	r24, 0x01	; 1
    41dc:	9e 4f       	sbci	r25, 0xFE	; 254
    41de:	af 4f       	sbci	r26, 0xFF	; 255
    41e0:	bf 4f       	sbci	r27, 0xFF	; 255
    41e2:	29 e0       	ldi	r18, 0x09	; 9
    41e4:	b6 95       	lsr	r27
    41e6:	a7 95       	ror	r26
    41e8:	97 95       	ror	r25
    41ea:	87 95       	ror	r24
    41ec:	2a 95       	dec	r18
    41ee:	d1 f7       	brne	.-12     	; 0x41e4 <f_open+0x37c>
    41f0:	2d a1       	ldd	r18, Y+37	; 0x25
    41f2:	3e a1       	ldd	r19, Y+38	; 0x26
    41f4:	4f a1       	ldd	r20, Y+39	; 0x27
    41f6:	58 a5       	ldd	r21, Y+40	; 0x28
    41f8:	28 17       	cp	r18, r24
    41fa:	39 07       	cpc	r19, r25
    41fc:	4a 07       	cpc	r20, r26
    41fe:	5b 07       	cpc	r21, r27
    4200:	f0 f0       	brcs	.+60     	; 0x423e <f_open+0x3d6>
				fs->last_clust = LD_DWORD(fs->win+FSI_Nxt_Free);
				fs->free_clust = LD_DWORD(fs->win+FSI_Free_Count);
		}
	}
#endif
	fs->fs_type = fmt;		/* FAT sub-type */
    4202:	d8 01       	movw	r26, r16
    4204:	6c 93       	st	X, r22
	fs->id = ++Fsid;		/* File system mount ID */
    4206:	80 91 d4 03 	lds	r24, 0x03D4
    420a:	90 91 d5 03 	lds	r25, 0x03D5
    420e:	01 96       	adiw	r24, 0x01	; 1
    4210:	90 93 d5 03 	sts	0x03D5, r25
    4214:	80 93 d4 03 	sts	0x03D4, r24
    4218:	17 96       	adiw	r26, 0x07	; 7
    421a:	9c 93       	st	X, r25
    421c:	8e 93       	st	-X, r24
    421e:	16 97       	sbiw	r26, 0x06	; 6
	fs->winsect = 0;		/* Invalidate sector cache */
    4220:	f8 01       	movw	r30, r16
    4222:	16 8e       	std	Z+30, r1	; 0x1e
    4224:	17 8e       	std	Z+31, r1	; 0x1f
    4226:	10 a2       	std	Z+32, r1	; 0x20
    4228:	11 a2       	std	Z+33, r1	; 0x21
	fs->wflag = 0;
    422a:	14 82       	std	Z+4, r1	; 0x04
    422c:	c2 c1       	rjmp	.+900    	; 0x45b2 <f_open+0x74a>
	}

	/* Check if the file system object is valid or not */
	*rfs = 0;
	if (vol >= _VOLUMES) 				/* Is the drive number valid? */
		return FR_INVALID_DRIVE;
    422e:	2b e0       	ldi	r18, 0x0B	; 11
    4230:	a6 c1       	rjmp	.+844    	; 0x457e <f_open+0x716>
	fs = FatFs[vol];					/* Get corresponding file system object */
	if (!fs) return FR_NOT_ENABLED;		/* Is the file system object available? */
    4232:	2c e0       	ldi	r18, 0x0C	; 12
    4234:	a4 c1       	rjmp	.+840    	; 0x457e <f_open+0x716>

	fs->fs_type = 0;					/* Clear the file system object */
	fs->drv = LD2PD(vol);				/* Bind the logical drive and a physical drive */
	stat = disk_initialize(fs->drv);	/* Initialize the physical drive */
	if (stat & STA_NOINIT)				/* Check if the initialization succeeded */
		return FR_NOT_READY;			/* Failed to initialize due to no medium or hard error */
    4236:	23 e0       	ldi	r18, 0x03	; 3
    4238:	a2 c1       	rjmp	.+836    	; 0x457e <f_open+0x716>
		if (tbl[4]) {						/* Is the partition existing? */
			bsect = LD_DWORD(&tbl[8]);		/* Partition offset in LBA */
			fmt = check_fs(fs, bsect);		/* Check the partition */
		}
	}
	if (fmt == 3) return FR_DISK_ERR;
    423a:	21 e0       	ldi	r18, 0x01	; 1
    423c:	a0 c1       	rjmp	.+832    	; 0x457e <f_open+0x716>
		fs->dirbase = fs->fatbase + fasize;				/* Root directory start sector */
		szbfat = (fmt == FS_FAT16) ?					/* (Required FAT size) */
			fs->n_fatent * 2 : fs->n_fatent * 3 / 2 + (fs->n_fatent & 1);
	}
	if (fs->fsize < (szbfat + (SS(fs) - 1)) / SS(fs))	/* (BPB_FATSz must not be less than required) */
		return FR_NO_FILESYSTEM;
    423e:	2d e0       	ldi	r18, 0x0D	; 13
    4240:	9e c1       	rjmp	.+828    	; 0x457e <f_open+0x716>
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    4242:	8c 35       	cpi	r24, 0x5C	; 92
    4244:	19 f4       	brne	.+6      	; 0x424c <f_open+0x3e4>
		path++;
    4246:	08 94       	sec
    4248:	e1 1c       	adc	r14, r1
    424a:	f1 1c       	adc	r15, r1
	dj->sclust = 0;						/* Start from the root dir */
    424c:	1b 8a       	std	Y+19, r1	; 0x13
    424e:	1c 8a       	std	Y+20, r1	; 0x14
    4250:	1d 8a       	std	Y+21, r1	; 0x15
    4252:	1e 8a       	std	Y+22, r1	; 0x16
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
    4254:	d7 01       	movw	r26, r14
    4256:	8c 91       	ld	r24, X
    4258:	80 32       	cpi	r24, 0x20	; 32
    425a:	38 f4       	brcc	.+14     	; 0x426a <f_open+0x402>
		res = dir_sdi(dj, 0);
    425c:	ce 01       	movw	r24, r28
    425e:	0d 96       	adiw	r24, 0x0d	; 13
    4260:	71 dd       	rcall	.-1310   	; 0x3d44 <dir_sdi.clone.4>
    4262:	28 2f       	mov	r18, r24
		dj->dir = 0;
    4264:	18 a2       	std	Y+32, r1	; 0x20
    4266:	1f 8e       	std	Y+31, r1	; 0x1f
    4268:	78 c1       	rjmp	.+752    	; 0x455a <f_open+0x6f2>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    426a:	90 e2       	ldi	r25, 0x20	; 32
    426c:	39 2e       	mov	r3, r25
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    426e:	85 e0       	ldi	r24, 0x05	; 5
    4270:	28 2e       	mov	r2, r24
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
    4272:	0d e0       	ldi	r16, 0x0D	; 13
    4274:	80 2e       	mov	r8, r16
    4276:	91 2c       	mov	r9, r1
    4278:	8c 0e       	add	r8, r28
    427a:	9d 1e       	adc	r9, r29
	dj->sclust = 0;						/* Start from the root dir */
#endif

	if ((UINT)*path < ' ') {			/* Nul path means the start directory itself */
		res = dir_sdi(dj, 0);
		dj->dir = 0;
    427c:	37 01       	movw	r6, r14
	BYTE b, c, d, *sfn;
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
    427e:	f7 01       	movw	r30, r14
    4280:	80 81       	ld	r24, Z
    4282:	08 94       	sec
    4284:	e1 1c       	adc	r14, r1
    4286:	f1 1c       	adc	r15, r1
    4288:	8f 32       	cpi	r24, 0x2F	; 47
    428a:	c1 f3       	breq	.-16     	; 0x427c <f_open+0x414>
    428c:	8c 35       	cpi	r24, 0x5C	; 92
    428e:	b1 f3       	breq	.-20     	; 0x427c <f_open+0x414>
	sfn = dj->fn;
    4290:	e9 a1       	ldd	r30, Y+33	; 0x21
    4292:	fa a1       	ldd	r31, Y+34	; 0x22
}

/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    4294:	df 01       	movw	r26, r30
	UINT ni, si, i;
	const char *p;

	/* Create file name in directory form */
	for (p = *path; *p == '/' || *p == '\\'; p++) ;	/* Strip duplicated separator */
	sfn = dj->fn;
    4296:	8b e0       	ldi	r24, 0x0B	; 11
    4298:	90 e0       	ldi	r25, 0x00	; 0
    429a:	01 c0       	rjmp	.+2      	; 0x429e <f_open+0x436>
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
		*d++ = (BYTE)val;
    429c:	3d 92       	st	X+, r3
/* Fill memory */
static
void mem_set (void* dst, int val, UINT cnt) {
	BYTE *d = (BYTE*)dst;

	while (cnt--)
    429e:	01 97       	sbiw	r24, 0x01	; 1
    42a0:	2f ef       	ldi	r18, 0xFF	; 255
    42a2:	8f 3f       	cpi	r24, 0xFF	; 255
    42a4:	92 07       	cpc	r25, r18
    42a6:	d1 f7       	brne	.-12     	; 0x429c <f_open+0x434>
    42a8:	80 e0       	ldi	r24, 0x00	; 0
    42aa:	90 e0       	ldi	r25, 0x00	; 0
    42ac:	aa 24       	eor	r10, r10
    42ae:	bb 24       	eor	r11, r11
    42b0:	28 e0       	ldi	r18, 0x08	; 8
    42b2:	30 e0       	ldi	r19, 0x00	; 0
    42b4:	60 e0       	ldi	r22, 0x00	; 0
		sfn[NS] = (c <= ' ') ? NS_LAST | NS_DOT : NS_DOT;	/* Set last segment flag if end of path */
		return FR_OK;
	}
#endif
	for (;;) {
		c = (BYTE)p[si++];
    42b6:	d3 01       	movw	r26, r6
    42b8:	aa 0d       	add	r26, r10
    42ba:	bb 1d       	adc	r27, r11
    42bc:	7c 91       	ld	r23, X
    42be:	08 94       	sec
    42c0:	a1 1c       	adc	r10, r1
    42c2:	b1 1c       	adc	r11, r1
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
    42c4:	71 32       	cpi	r23, 0x21	; 33
    42c6:	08 f4       	brcc	.+2      	; 0x42ca <f_open+0x462>
    42c8:	60 c0       	rjmp	.+192    	; 0x438a <f_open+0x522>
    42ca:	7f 32       	cpi	r23, 0x2F	; 47
    42cc:	09 f4       	brne	.+2      	; 0x42d0 <f_open+0x468>
    42ce:	5f c0       	rjmp	.+190    	; 0x438e <f_open+0x526>
    42d0:	7c 35       	cpi	r23, 0x5C	; 92
    42d2:	09 f4       	brne	.+2      	; 0x42d6 <f_open+0x46e>
    42d4:	5c c0       	rjmp	.+184    	; 0x438e <f_open+0x526>
		if (c == '.' || i >= ni) {
    42d6:	7e 32       	cpi	r23, 0x2E	; 46
    42d8:	19 f0       	breq	.+6      	; 0x42e0 <f_open+0x478>
    42da:	82 17       	cp	r24, r18
    42dc:	93 07       	cpc	r25, r19
    42de:	70 f0       	brcs	.+28     	; 0x42fc <f_open+0x494>
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
    42e0:	28 30       	cpi	r18, 0x08	; 8
    42e2:	31 05       	cpc	r19, r1
    42e4:	09 f0       	breq	.+2      	; 0x42e8 <f_open+0x480>
    42e6:	34 c1       	rjmp	.+616    	; 0x4550 <f_open+0x6e8>
    42e8:	7e 32       	cpi	r23, 0x2E	; 46
    42ea:	09 f0       	breq	.+2      	; 0x42ee <f_open+0x486>
    42ec:	31 c1       	rjmp	.+610    	; 0x4550 <f_open+0x6e8>
			i = 8; ni = 11;
			b <<= 2; continue;
    42ee:	66 0f       	add	r22, r22
    42f0:	66 0f       	add	r22, r22
	for (;;) {
		c = (BYTE)p[si++];
		if (c <= ' ' || c == '/' || c == '\\') break;	/* Break on end of segment */
		if (c == '.' || i >= ni) {
			if (ni != 8 || c != '.') return FR_INVALID_NAME;
			i = 8; ni = 11;
    42f2:	88 e0       	ldi	r24, 0x08	; 8
    42f4:	90 e0       	ldi	r25, 0x00	; 0
    42f6:	2b e0       	ldi	r18, 0x0B	; 11
    42f8:	30 e0       	ldi	r19, 0x00	; 0
    42fa:	dd cf       	rjmp	.-70     	; 0x42b6 <f_open+0x44e>
			b <<= 2; continue;
		}
		if (c >= 0x80) {				/* Extended char? */
    42fc:	77 fd       	sbrc	r23, 7
			b |= 3;						/* Eliminate NT flag */
    42fe:	63 60       	ori	r22, 0x03	; 3
#if !_DF1S	/* ASCII only cfg */
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
    4300:	47 2f       	mov	r20, r23
    4302:	41 58       	subi	r20, 0x81	; 129
    4304:	4f 31       	cpi	r20, 0x1F	; 31
    4306:	18 f0       	brcs	.+6      	; 0x430e <f_open+0x4a6>
    4308:	4f 55       	subi	r20, 0x5F	; 95
    430a:	4d 31       	cpi	r20, 0x1D	; 29
    430c:	00 f5       	brcc	.+64     	; 0x434e <f_open+0x4e6>
			d = (BYTE)p[si++];			/* Get 2nd byte */
    430e:	d3 01       	movw	r26, r6
    4310:	aa 0d       	add	r26, r10
    4312:	bb 1d       	adc	r27, r11
    4314:	0c 91       	ld	r16, X
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
    4316:	40 2f       	mov	r20, r16
    4318:	40 54       	subi	r20, 0x40	; 64
    431a:	4f 33       	cpi	r20, 0x3F	; 63
    431c:	20 f0       	brcs	.+8      	; 0x4326 <f_open+0x4be>
    431e:	40 54       	subi	r20, 0x40	; 64
    4320:	4d 37       	cpi	r20, 0x7D	; 125
    4322:	08 f0       	brcs	.+2      	; 0x4326 <f_open+0x4be>
    4324:	15 c1       	rjmp	.+554    	; 0x4550 <f_open+0x6e8>
    4326:	a9 01       	movw	r20, r18
    4328:	41 50       	subi	r20, 0x01	; 1
    432a:	50 40       	sbci	r21, 0x00	; 0
    432c:	84 17       	cp	r24, r20
    432e:	95 07       	cpc	r25, r21
    4330:	08 f0       	brcs	.+2      	; 0x4334 <f_open+0x4cc>
    4332:	0e c1       	rjmp	.+540    	; 0x4550 <f_open+0x6e8>
			return FR_INVALID_NAME;
#endif
#endif
		}
		if (IsDBCS1(c)) {				/* Check if it is a DBC 1st byte (always false on SBCS cfg) */
			d = (BYTE)p[si++];			/* Get 2nd byte */
    4334:	08 94       	sec
    4336:	a1 1c       	adc	r10, r1
    4338:	b1 1c       	adc	r11, r1
			if (!IsDBCS2(d) || i >= ni - 1)	/* Reject invalid DBC */
				return FR_INVALID_NAME;
			sfn[i++] = c;
    433a:	df 01       	movw	r26, r30
    433c:	a8 0f       	add	r26, r24
    433e:	b9 1f       	adc	r27, r25
    4340:	7c 93       	st	X, r23
    4342:	01 96       	adiw	r24, 0x01	; 1
			sfn[i++] = d;
    4344:	df 01       	movw	r26, r30
    4346:	a8 0f       	add	r26, r24
    4348:	b9 1f       	adc	r27, r25
    434a:	0c 93       	st	X, r16
    434c:	1c c0       	rjmp	.+56     	; 0x4386 <f_open+0x51e>
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
    434e:	07 2f       	mov	r16, r23
    4350:	10 e0       	ldi	r17, 0x00	; 0
    4352:	ae e2       	ldi	r26, 0x2E	; 46
    4354:	b3 e0       	ldi	r27, 0x03	; 3
}

/* Check if chr is contained in the string */
static
int chk_chr (const char* str, int chr) {
	while (*str && *str != chr) str++;
    4356:	4d 91       	ld	r20, X+
    4358:	44 23       	and	r20, r20
    435a:	29 f0       	breq	.+10     	; 0x4366 <f_open+0x4fe>
    435c:	50 e0       	ldi	r21, 0x00	; 0
    435e:	40 17       	cp	r20, r16
    4360:	51 07       	cpc	r21, r17
    4362:	c9 f7       	brne	.-14     	; 0x4356 <f_open+0x4ee>
    4364:	f5 c0       	rjmp	.+490    	; 0x4550 <f_open+0x6e8>
			sfn[i++] = c;
			sfn[i++] = d;
		} else {						/* Single byte code */
			if (chk_chr("\"*+,:;<=>\?[]|\x7F", c))	/* Reject illegal chrs for SFN */
				return FR_INVALID_NAME;
			if (IsUpper(c)) {			/* ASCII large capital? */
    4366:	47 2f       	mov	r20, r23
    4368:	41 54       	subi	r20, 0x41	; 65
    436a:	4a 31       	cpi	r20, 0x1A	; 26
    436c:	10 f4       	brcc	.+4      	; 0x4372 <f_open+0x50a>
				b |= 2;
    436e:	62 60       	ori	r22, 0x02	; 2
    4370:	06 c0       	rjmp	.+12     	; 0x437e <f_open+0x516>
			} else {
				if (IsLower(c)) {		/* ASCII small capital? */
    4372:	47 2f       	mov	r20, r23
    4374:	41 56       	subi	r20, 0x61	; 97
    4376:	4a 31       	cpi	r20, 0x1A	; 26
    4378:	10 f4       	brcc	.+4      	; 0x437e <f_open+0x516>
					b |= 1; c -= 0x20;
    437a:	61 60       	ori	r22, 0x01	; 1
    437c:	70 52       	subi	r23, 0x20	; 32
				}
			}
			sfn[i++] = c;
    437e:	df 01       	movw	r26, r30
    4380:	a8 0f       	add	r26, r24
    4382:	b9 1f       	adc	r27, r25
    4384:	7c 93       	st	X, r23
    4386:	01 96       	adiw	r24, 0x01	; 1
    4388:	96 cf       	rjmp	.-212    	; 0x42b6 <f_open+0x44e>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */
    438a:	44 e0       	ldi	r20, 0x04	; 4
    438c:	01 c0       	rjmp	.+2      	; 0x4390 <f_open+0x528>
    438e:	40 e0       	ldi	r20, 0x00	; 0

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    4390:	00 97       	sbiw	r24, 0x00	; 0
    4392:	09 f4       	brne	.+2      	; 0x4396 <f_open+0x52e>
    4394:	dd c0       	rjmp	.+442    	; 0x4550 <f_open+0x6e8>
	if (sfn[0] == DDE) sfn[0] = NDDE;	/* When first char collides with DDE, replace it with 0x05 */
    4396:	80 81       	ld	r24, Z
    4398:	85 3e       	cpi	r24, 0xE5	; 229
    439a:	09 f4       	brne	.+2      	; 0x439e <f_open+0x536>
    439c:	20 82       	st	Z, r2

	if (ni == 8) b <<= 2;
    439e:	28 30       	cpi	r18, 0x08	; 8
    43a0:	31 05       	cpc	r19, r1
    43a2:	11 f4       	brne	.+4      	; 0x43a8 <f_open+0x540>
    43a4:	66 0f       	add	r22, r22
    43a6:	66 0f       	add	r22, r22
	if ((b & 0x03) == 0x01) c |= NS_EXT;	/* NT flag (Name extension has only small capital) */
    43a8:	70 e0       	ldi	r23, 0x00	; 0
    43aa:	cb 01       	movw	r24, r22
    43ac:	83 70       	andi	r24, 0x03	; 3
    43ae:	90 70       	andi	r25, 0x00	; 0
    43b0:	81 30       	cpi	r24, 0x01	; 1
    43b2:	91 05       	cpc	r25, r1
    43b4:	09 f4       	brne	.+2      	; 0x43b8 <f_open+0x550>
    43b6:	40 61       	ori	r20, 0x10	; 16
	if ((b & 0x0C) == 0x04) c |= NS_BODY;	/* NT flag (Name body has only small capital) */
    43b8:	6c 70       	andi	r22, 0x0C	; 12
    43ba:	70 70       	andi	r23, 0x00	; 0
    43bc:	64 30       	cpi	r22, 0x04	; 4
    43be:	71 05       	cpc	r23, r1
    43c0:	09 f4       	brne	.+2      	; 0x43c4 <f_open+0x55c>
    43c2:	48 60       	ori	r20, 0x08	; 8

	sfn[NS] = c;		/* Store NT flag, File name is created */
    43c4:	43 87       	std	Z+11, r20	; 0x0b
	BYTE c, *dir;
#if _USE_LFN
	BYTE a, ord, sum;
#endif

	res = dir_sdi(dj, 0);			/* Rewind directory object */
    43c6:	c4 01       	movw	r24, r8
    43c8:	bd dc       	rcall	.-1670   	; 0x3d44 <dir_sdi.clone.4>
	if (res != FR_OK) return res;
    43ca:	88 23       	and	r24, r24
    43cc:	09 f0       	breq	.+2      	; 0x43d0 <f_open+0x568>
    43ce:	a1 c0       	rjmp	.+322    	; 0x4512 <f_open+0x6aa>

#if _USE_LFN
	ord = sum = 0xFF;
#endif
	do {
		res = move_window(dj->fs, dj->sect);
    43d0:	4b 8d       	ldd	r20, Y+27	; 0x1b
    43d2:	5c 8d       	ldd	r21, Y+28	; 0x1c
    43d4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    43d6:	7e 8d       	ldd	r23, Y+30	; 0x1e
    43d8:	8d 85       	ldd	r24, Y+13	; 0x0d
    43da:	9e 85       	ldd	r25, Y+14	; 0x0e
    43dc:	33 db       	rcall	.-2458   	; 0x3a44 <move_window>
		if (res != FR_OK) break;
    43de:	88 23       	and	r24, r24
    43e0:	09 f0       	breq	.+2      	; 0x43e4 <f_open+0x57c>
    43e2:	97 c0       	rjmp	.+302    	; 0x4512 <f_open+0x6aa>
		dir = dj->dir;					/* Ptr to the directory entry of current index */
    43e4:	ef 8d       	ldd	r30, Y+31	; 0x1f
    43e6:	f8 a1       	ldd	r31, Y+32	; 0x20
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    43e8:	90 81       	ld	r25, Z
    43ea:	99 23       	and	r25, r25
    43ec:	09 f4       	brne	.+2      	; 0x43f0 <f_open+0x588>
    43ee:	90 c0       	rjmp	.+288    	; 0x4510 <f_open+0x6a8>
				ord = 0xFF; dj->lfn_idx = 0xFFFF;	/* Reset LFN sequence */
				if (!(dj->fn[NS] & NS_LOSS) && !mem_cmp(dir, dj->fn, 11)) break;	/* SFN matched? */
			}
		}
#else		/* Non LFN configuration */
		if (!(dir[DIR_Attr] & AM_VOL) && !mem_cmp(dir, dj->fn, 11)) /* Is it a valid entry? */
    43f0:	93 85       	ldd	r25, Z+11	; 0x0b
    43f2:	93 fd       	sbrc	r25, 3
    43f4:	0d c0       	rjmp	.+26     	; 0x4410 <f_open+0x5a8>
    43f6:	a9 a1       	ldd	r26, Y+33	; 0x21
    43f8:	ba a1       	ldd	r27, Y+34	; 0x22

/*-----------------------------------------------------------------------*/
/* Open or Create a File                                                 */
/*-----------------------------------------------------------------------*/

FRESULT f_open (
    43fa:	af 01       	movw	r20, r30
    43fc:	45 5f       	subi	r20, 0xF5	; 245
    43fe:	5f 4f       	sbci	r21, 0xFF	; 255
static
int mem_cmp (const void* dst, const void* src, UINT cnt) {
	const BYTE *d = (const BYTE *)dst, *s = (const BYTE *)src;
	int r = 0;

	while (cnt-- && (r = *d++ - *s++) == 0) ;
    4400:	e4 17       	cp	r30, r20
    4402:	f5 07       	cpc	r31, r21
    4404:	09 f4       	brne	.+2      	; 0x4408 <f_open+0x5a0>
    4406:	85 c0       	rjmp	.+266    	; 0x4512 <f_open+0x6aa>
    4408:	21 91       	ld	r18, Z+
    440a:	9d 91       	ld	r25, X+
    440c:	29 17       	cp	r18, r25
    440e:	c1 f3       	breq	.-16     	; 0x4400 <f_open+0x598>
	DWORD clst;
	WORD i;


	stretch = stretch;		/* To suppress warning on read-only cfg. */
	i = dj->index + 1;
    4410:	e9 88       	ldd	r14, Y+17	; 0x11
    4412:	fa 88       	ldd	r15, Y+18	; 0x12
    4414:	08 94       	sec
    4416:	e1 1c       	adc	r14, r1
    4418:	f1 1c       	adc	r15, r1
	if (!i || !dj->sect)	/* Report EOT when index has reached 65535 */
    441a:	e1 14       	cp	r14, r1
    441c:	f1 04       	cpc	r15, r1
    441e:	09 f4       	brne	.+2      	; 0x4422 <f_open+0x5ba>
    4420:	77 c0       	rjmp	.+238    	; 0x4510 <f_open+0x6a8>
    4422:	8b 8d       	ldd	r24, Y+27	; 0x1b
    4424:	9c 8d       	ldd	r25, Y+28	; 0x1c
    4426:	ad 8d       	ldd	r26, Y+29	; 0x1d
    4428:	be 8d       	ldd	r27, Y+30	; 0x1e
    442a:	00 97       	sbiw	r24, 0x00	; 0
    442c:	a1 05       	cpc	r26, r1
    442e:	b1 05       	cpc	r27, r1
    4430:	09 f4       	brne	.+2      	; 0x4434 <f_open+0x5cc>
    4432:	6e c0       	rjmp	.+220    	; 0x4510 <f_open+0x6a8>
		return FR_NO_FILE;

	if (!(i % (SS(dj->fs) / SZ_DIR))) {	/* Sector changed? */
    4434:	1f e0       	ldi	r17, 0x0F	; 15
    4436:	41 2e       	mov	r4, r17
    4438:	51 2c       	mov	r5, r1
    443a:	4e 20       	and	r4, r14
    443c:	5f 20       	and	r5, r15
    443e:	41 14       	cp	r4, r1
    4440:	51 04       	cpc	r5, r1
    4442:	09 f0       	breq	.+2      	; 0x4446 <f_open+0x5de>
    4444:	52 c0       	rjmp	.+164    	; 0x44ea <f_open+0x682>
		dj->sect++;					/* Next sector */
    4446:	01 96       	adiw	r24, 0x01	; 1
    4448:	a1 1d       	adc	r26, r1
    444a:	b1 1d       	adc	r27, r1
    444c:	8b 8f       	std	Y+27, r24	; 0x1b
    444e:	9c 8f       	std	Y+28, r25	; 0x1c
    4450:	ad 8f       	std	Y+29, r26	; 0x1d
    4452:	be 8f       	std	Y+30, r27	; 0x1e

		if (dj->clust == 0) {	/* Static table */
    4454:	4f 89       	ldd	r20, Y+23	; 0x17
    4456:	58 8d       	ldd	r21, Y+24	; 0x18
    4458:	69 8d       	ldd	r22, Y+25	; 0x19
    445a:	7a 8d       	ldd	r23, Y+26	; 0x1a
    445c:	8d 85       	ldd	r24, Y+13	; 0x0d
    445e:	9e 85       	ldd	r25, Y+14	; 0x0e
    4460:	41 15       	cp	r20, r1
    4462:	51 05       	cpc	r21, r1
    4464:	61 05       	cpc	r22, r1
    4466:	71 05       	cpc	r23, r1
    4468:	49 f4       	brne	.+18     	; 0x447c <f_open+0x614>
			if (i >= dj->fs->n_rootdir)	/* Report EOT when end of table */
    446a:	dc 01       	movw	r26, r24
    446c:	18 96       	adiw	r26, 0x08	; 8
    446e:	8d 91       	ld	r24, X+
    4470:	9c 91       	ld	r25, X
    4472:	19 97       	sbiw	r26, 0x09	; 9
    4474:	e8 16       	cp	r14, r24
    4476:	f9 06       	cpc	r15, r25
    4478:	c0 f1       	brcs	.+112    	; 0x44ea <f_open+0x682>
    447a:	4a c0       	rjmp	.+148    	; 0x4510 <f_open+0x6a8>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
    447c:	fc 01       	movw	r30, r24
    447e:	22 81       	ldd	r18, Z+2	; 0x02
    4480:	30 e0       	ldi	r19, 0x00	; 0
    4482:	21 50       	subi	r18, 0x01	; 1
    4484:	30 40       	sbci	r19, 0x00	; 0
    4486:	f7 01       	movw	r30, r14
    4488:	a4 e0       	ldi	r26, 0x04	; 4
    448a:	f6 95       	lsr	r31
    448c:	e7 95       	ror	r30
    448e:	aa 95       	dec	r26
    4490:	e1 f7       	brne	.-8      	; 0x448a <f_open+0x622>
    4492:	2e 23       	and	r18, r30
    4494:	3f 23       	and	r19, r31
    4496:	21 15       	cp	r18, r1
    4498:	31 05       	cpc	r19, r1
    449a:	39 f5       	brne	.+78     	; 0x44ea <f_open+0x682>
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
    449c:	8f db       	rcall	.-2274   	; 0x3bbc <get_fat>
    449e:	ab 01       	movw	r20, r22
    44a0:	bc 01       	movw	r22, r24
				if (clst <= 1) return FR_INT_ERR;
    44a2:	42 30       	cpi	r20, 0x02	; 2
    44a4:	51 05       	cpc	r21, r1
    44a6:	61 05       	cpc	r22, r1
    44a8:	71 05       	cpc	r23, r1
    44aa:	70 f1       	brcs	.+92     	; 0x4508 <f_open+0x6a0>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    44ac:	4f 3f       	cpi	r20, 0xFF	; 255
    44ae:	ff ef       	ldi	r31, 0xFF	; 255
    44b0:	5f 07       	cpc	r21, r31
    44b2:	ff ef       	ldi	r31, 0xFF	; 255
    44b4:	6f 07       	cpc	r22, r31
    44b6:	ff ef       	ldi	r31, 0xFF	; 255
    44b8:	7f 07       	cpc	r23, r31
    44ba:	41 f1       	breq	.+80     	; 0x450c <f_open+0x6a4>
				if (clst >= dj->fs->n_fatent) {					/* When it reached end of dynamic table */
    44bc:	8d 85       	ldd	r24, Y+13	; 0x0d
    44be:	9e 85       	ldd	r25, Y+14	; 0x0e
    44c0:	dc 01       	movw	r26, r24
    44c2:	1a 96       	adiw	r26, 0x0a	; 10
    44c4:	0d 91       	ld	r16, X+
    44c6:	1d 91       	ld	r17, X+
    44c8:	2d 91       	ld	r18, X+
    44ca:	3c 91       	ld	r19, X
    44cc:	1d 97       	sbiw	r26, 0x0d	; 13
    44ce:	40 17       	cp	r20, r16
    44d0:	51 07       	cpc	r21, r17
    44d2:	62 07       	cpc	r22, r18
    44d4:	73 07       	cpc	r23, r19
    44d6:	e0 f4       	brcc	.+56     	; 0x4510 <f_open+0x6a8>
					dj->fs->winsect -= c;						/* Rewind window address */
#else
					return FR_NO_FILE;			/* Report EOT */
#endif
				}
				dj->clust = clst;				/* Initialize data for new cluster */
    44d8:	4f 8b       	std	Y+23, r20	; 0x17
    44da:	58 8f       	std	Y+24, r21	; 0x18
    44dc:	69 8f       	std	Y+25, r22	; 0x19
    44de:	7a 8f       	std	Y+26, r23	; 0x1a
				dj->sect = clust2sect(dj->fs, clst);
    44e0:	3e db       	rcall	.-2436   	; 0x3b5e <clust2sect>
    44e2:	6b 8f       	std	Y+27, r22	; 0x1b
    44e4:	7c 8f       	std	Y+28, r23	; 0x1c
    44e6:	8d 8f       	std	Y+29, r24	; 0x1d
    44e8:	9e 8f       	std	Y+30, r25	; 0x1e
			}
		}
	}

	dj->index = i;
    44ea:	fa 8a       	std	Y+18, r15	; 0x12
    44ec:	e9 8a       	std	Y+17, r14	; 0x11
	dj->dir = dj->fs->win + (i % (SS(dj->fs) / SZ_DIR)) * SZ_DIR;
    44ee:	8d 85       	ldd	r24, Y+13	; 0x0d
    44f0:	9e 85       	ldd	r25, Y+14	; 0x0e
    44f2:	82 96       	adiw	r24, 0x22	; 34
    44f4:	35 e0       	ldi	r19, 0x05	; 5
    44f6:	44 0c       	add	r4, r4
    44f8:	55 1c       	adc	r5, r5
    44fa:	3a 95       	dec	r19
    44fc:	e1 f7       	brne	.-8      	; 0x44f6 <f_open+0x68e>
    44fe:	84 0d       	add	r24, r4
    4500:	95 1d       	adc	r25, r5
    4502:	98 a3       	std	Y+32, r25	; 0x20
    4504:	8f 8f       	std	Y+31, r24	; 0x1f
    4506:	64 cf       	rjmp	.-312    	; 0x43d0 <f_open+0x568>
				return FR_NO_FILE;
		}
		else {					/* Dynamic table */
			if (((i / (SS(dj->fs) / SZ_DIR)) & (dj->fs->csize - 1)) == 0) {	/* Cluster changed? */
				clst = get_fat(dj->fs, dj->clust);				/* Get next cluster */
				if (clst <= 1) return FR_INT_ERR;
    4508:	82 e0       	ldi	r24, 0x02	; 2
    450a:	03 c0       	rjmp	.+6      	; 0x4512 <f_open+0x6aa>
				if (clst == 0xFFFFFFFF) return FR_DISK_ERR;
    450c:	81 e0       	ldi	r24, 0x01	; 1
    450e:	01 c0       	rjmp	.+2      	; 0x4512 <f_open+0x6aa>
	do {
		res = move_window(dj->fs, dj->sect);
		if (res != FR_OK) break;
		dir = dj->dir;					/* Ptr to the directory entry of current index */
		c = dir[DIR_Name];
		if (c == 0) { res = FR_NO_FILE; break; }	/* Reached to end of table */
    4510:	84 e0       	ldi	r24, 0x04	; 4
	} else {							/* Follow path */
		for (;;) {
			res = create_name(dj, &path);	/* Get a segment */
			if (res != FR_OK) break;
			res = dir_find(dj);				/* Find it */
			ns = *(dj->fn+NS);
    4512:	e9 a1       	ldd	r30, Y+33	; 0x21
    4514:	fa a1       	ldd	r31, Y+34	; 0x22
    4516:	93 85       	ldd	r25, Z+11	; 0x0b
			if (res != FR_OK) {				/* Failed to find the object */
    4518:	88 23       	and	r24, r24
    451a:	31 f0       	breq	.+12     	; 0x4528 <f_open+0x6c0>
    451c:	28 2f       	mov	r18, r24
				if (res != FR_NO_FILE) break;	/* Abort if any hard error occurred */
    451e:	24 30       	cpi	r18, 0x04	; 4
    4520:	e1 f4       	brne	.+56     	; 0x455a <f_open+0x6f2>
				if (_FS_RPATH && (ns & NS_DOT)) {	/* If dot entry is not exit */
					dj->sclust = 0; dj->dir = 0;	/* It is the root dir */
					res = FR_OK;
					if (!(ns & NS_LAST)) continue;
				} else {							/* Could not find the object */
					if (!(ns & NS_LAST)) res = FR_NO_PATH;
    4522:	92 ff       	sbrs	r25, 2
    4524:	17 c0       	rjmp	.+46     	; 0x4554 <f_open+0x6ec>
    4526:	19 c0       	rjmp	.+50     	; 0x455a <f_open+0x6f2>
				}
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
    4528:	92 fd       	sbrc	r25, 2
    452a:	16 c0       	rjmp	.+44     	; 0x4558 <f_open+0x6f0>
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
    452c:	6f 8d       	ldd	r22, Y+31	; 0x1f
    452e:	78 a1       	ldd	r23, Y+32	; 0x20
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
    4530:	fb 01       	movw	r30, r22
    4532:	83 85       	ldd	r24, Z+11	; 0x0b
    4534:	84 ff       	sbrs	r24, 4
    4536:	0e c0       	rjmp	.+28     	; 0x4554 <f_open+0x6ec>
				}
			}
			sfn[i++] = c;
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
    4538:	73 01       	movw	r14, r6
    453a:	ea 0c       	add	r14, r10
    453c:	fb 1c       	adc	r15, r11
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    453e:	ed 85       	ldd	r30, Y+13	; 0x0d
    4540:	fe 85       	ldd	r31, Y+14	; 0x0e
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
			}
			dj->sclust = ld_clust(dj->fs, dir);
    4542:	80 81       	ld	r24, Z
    4544:	f7 da       	rcall	.-2578   	; 0x3b34 <ld_clust.clone.0>
    4546:	6b 8b       	std	Y+19, r22	; 0x13
    4548:	7c 8b       	std	Y+20, r23	; 0x14
    454a:	8d 8b       	std	Y+21, r24	; 0x15
    454c:	9e 8b       	std	Y+22, r25	; 0x16
    454e:	96 ce       	rjmp	.-724    	; 0x427c <f_open+0x414>
		}
	}
	*path = &p[si];						/* Return pointer to the next segment */
	c = (c <= ' ') ? NS_LAST : 0;		/* Set last segment flag if end of path */

	if (!i) return FR_INVALID_NAME;		/* Reject nul string */
    4550:	26 e0       	ldi	r18, 0x06	; 6
    4552:	03 c0       	rjmp	.+6      	; 0x455a <f_open+0x6f2>
				break;
			}
			if (ns & NS_LAST) break;			/* Last segment match. Function completed. */
			dir = dj->dir;						/* There is next segment. Follow the sub directory */
			if (!(dir[DIR_Attr] & AM_DIR)) {	/* Cannot follow because it is a file */
				res = FR_NO_PATH; break;
    4554:	25 e0       	ldi	r18, 0x05	; 5
    4556:	01 c0       	rjmp	.+2      	; 0x455a <f_open+0x6f2>
    4558:	28 2f       	mov	r18, r24
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
		res = follow_path(&dj, path);	/* Follow the file path */
		dir = dj.dir;
    455a:	0f 8d       	ldd	r16, Y+31	; 0x1f
    455c:	18 a1       	ldd	r17, Y+32	; 0x20
			if (!fp->lockid) res = FR_INT_ERR;
#endif
		}

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
    455e:	22 23       	and	r18, r18
    4560:	71 f4       	brne	.+28     	; 0x457e <f_open+0x716>
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
    4562:	01 15       	cp	r16, r1
    4564:	11 05       	cpc	r17, r1
    4566:	41 f0       	breq	.+16     	; 0x4578 <f_open+0x710>
				res = FR_INVALID_NAME;
			} else {
				if (dir[DIR_Attr] & AM_DIR)	/* It is a directory */
    4568:	d8 01       	movw	r26, r16
    456a:	1b 96       	adiw	r26, 0x0b	; 11
    456c:	8c 91       	ld	r24, X
    456e:	1b 97       	sbiw	r26, 0x0b	; 11
    4570:	84 ff       	sbrs	r24, 4
    4572:	29 c0       	rjmp	.+82     	; 0x45c6 <f_open+0x75e>
					res = FR_NO_FILE;
    4574:	24 e0       	ldi	r18, 0x04	; 4
    4576:	03 c0       	rjmp	.+6      	; 0x457e <f_open+0x716>

#else				/* R/O configuration */
		if (res == FR_OK) {					/* Follow succeeded */
			dir = dj.dir;
			if (!dir) {						/* Current dir itself */
				res = FR_INVALID_NAME;
    4578:	26 e0       	ldi	r18, 0x06	; 6
    457a:	01 c0       	rjmp	.+2      	; 0x457e <f_open+0x716>
	DIR dj;
	BYTE *dir;
	DEF_NAMEBUF;


	if (!fp) return FR_INVALID_OBJECT;
    457c:	29 e0       	ldi	r18, 0x09	; 9
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
		}
	}

	LEAVE_FF(dj.fs, res);
}
    457e:	82 2f       	mov	r24, r18
    4580:	e8 96       	adiw	r28, 0x38	; 56
    4582:	0f b6       	in	r0, 0x3f	; 63
    4584:	f8 94       	cli
    4586:	de bf       	out	0x3e, r29	; 62
    4588:	0f be       	out	0x3f, r0	; 63
    458a:	cd bf       	out	0x3d, r28	; 61
    458c:	cf 91       	pop	r28
    458e:	df 91       	pop	r29
    4590:	1f 91       	pop	r17
    4592:	0f 91       	pop	r16
    4594:	ff 90       	pop	r15
    4596:	ef 90       	pop	r14
    4598:	df 90       	pop	r13
    459a:	cf 90       	pop	r12
    459c:	bf 90       	pop	r11
    459e:	af 90       	pop	r10
    45a0:	9f 90       	pop	r9
    45a2:	8f 90       	pop	r8
    45a4:	7f 90       	pop	r7
    45a6:	6f 90       	pop	r6
    45a8:	5f 90       	pop	r5
    45aa:	4f 90       	pop	r4
    45ac:	3f 90       	pop	r3
    45ae:	2f 90       	pop	r2
    45b0:	08 95       	ret
#else
	mode &= FA_READ;
	res = chk_mounted(&path, &dj.fs, 0);
#endif
	if (res == FR_OK) {
		INIT_BUF(dj);
    45b2:	ce 01       	movw	r24, r28
    45b4:	01 96       	adiw	r24, 0x01	; 1
    45b6:	9a a3       	std	Y+34, r25	; 0x22
    45b8:	89 a3       	std	Y+33, r24	; 0x21
		path++;	dj->sclust = 0;		/* Strip it and start from the root dir */
	} else {							/* No heading separator */
		dj->sclust = dj->fs->cdir;	/* Start from the current dir */
	}
#else
	if (*path == '/' || *path == '\\')	/* Strip heading separator if exist */
    45ba:	f7 01       	movw	r30, r14
    45bc:	80 81       	ld	r24, Z
    45be:	8f 32       	cpi	r24, 0x2F	; 47
    45c0:	09 f0       	breq	.+2      	; 0x45c4 <f_open+0x75c>
    45c2:	3f ce       	rjmp	.-898    	; 0x4242 <f_open+0x3da>
    45c4:	40 ce       	rjmp	.-896    	; 0x4246 <f_open+0x3de>

#if !_FS_READONLY
	mode &= FA_READ | FA_WRITE | FA_CREATE_ALWAYS | FA_OPEN_ALWAYS | FA_CREATE_NEW;
	res = chk_mounted(&path, &dj.fs, (BYTE)(mode & ~FA_READ));
#else
	mode &= FA_READ;
    45c6:	8f a9       	ldd	r24, Y+55	; 0x37
    45c8:	81 70       	andi	r24, 0x01	; 1
		}
#endif
		FREE_BUF();

		if (res == FR_OK) {
			fp->flag = mode;					/* File access mode */
    45ca:	ab a1       	ldd	r26, Y+35	; 0x23
    45cc:	bc a1       	ldd	r27, Y+36	; 0x24
    45ce:	14 96       	adiw	r26, 0x04	; 4
    45d0:	8c 93       	st	X, r24
			fp->sclust = ld_clust(dj.fs, dir);	/* File start cluster */
    45d2:	ed 84       	ldd	r14, Y+13	; 0x0d
    45d4:	fe 84       	ldd	r15, Y+14	; 0x0e
    45d6:	f7 01       	movw	r30, r14
    45d8:	80 81       	ld	r24, Z
    45da:	b8 01       	movw	r22, r16
    45dc:	28 af       	std	Y+56, r18	; 0x38
    45de:	aa da       	rcall	.-2732   	; 0x3b34 <ld_clust.clone.0>
    45e0:	ab a1       	ldd	r26, Y+35	; 0x23
    45e2:	bc a1       	ldd	r27, Y+36	; 0x24
    45e4:	1e 96       	adiw	r26, 0x0e	; 14
    45e6:	6d 93       	st	X+, r22
    45e8:	7d 93       	st	X+, r23
    45ea:	8d 93       	st	X+, r24
    45ec:	9c 93       	st	X, r25
    45ee:	51 97       	sbiw	r26, 0x11	; 17
			fp->fsize = LD_DWORD(dir+DIR_FileSize);	/* File size */
    45f0:	f8 01       	movw	r30, r16
    45f2:	84 8d       	ldd	r24, Z+28	; 0x1c
    45f4:	95 8d       	ldd	r25, Z+29	; 0x1d
    45f6:	a6 8d       	ldd	r26, Z+30	; 0x1e
    45f8:	b7 8d       	ldd	r27, Z+31	; 0x1f
    45fa:	eb a1       	ldd	r30, Y+35	; 0x23
    45fc:	fc a1       	ldd	r31, Y+36	; 0x24
    45fe:	82 87       	std	Z+10, r24	; 0x0a
    4600:	93 87       	std	Z+11, r25	; 0x0b
    4602:	a4 87       	std	Z+12, r26	; 0x0c
    4604:	b5 87       	std	Z+13, r27	; 0x0d
			fp->fptr = 0;						/* File pointer */
    4606:	16 82       	std	Z+6, r1	; 0x06
    4608:	17 82       	std	Z+7, r1	; 0x07
    460a:	10 86       	std	Z+8, r1	; 0x08
    460c:	11 86       	std	Z+9, r1	; 0x09
			fp->dsect = 0;
    460e:	16 8a       	std	Z+22, r1	; 0x16
    4610:	17 8a       	std	Z+23, r1	; 0x17
    4612:	10 8e       	std	Z+24, r1	; 0x18
    4614:	11 8e       	std	Z+25, r1	; 0x19
#if _USE_FASTSEEK
			fp->cltbl = 0;						/* Normal seek mode */
#endif
			fp->fs = dj.fs; fp->id = dj.fs->id;	/* Validate file object */
    4616:	f1 82       	std	Z+1, r15	; 0x01
    4618:	e0 82       	st	Z, r14
    461a:	d7 01       	movw	r26, r14
    461c:	16 96       	adiw	r26, 0x06	; 6
    461e:	8d 91       	ld	r24, X+
    4620:	9c 91       	ld	r25, X
    4622:	17 97       	sbiw	r26, 0x07	; 7
    4624:	93 83       	std	Z+3, r25	; 0x03
    4626:	82 83       	std	Z+2, r24	; 0x02
    4628:	28 ad       	ldd	r18, Y+56	; 0x38
    462a:	a9 cf       	rjmp	.-174    	; 0x457e <f_open+0x716>

0000462c <f_read>:
	FIL *fp, 		/* Pointer to the file object */
	void *buff,		/* Pointer to data buffer */
	UINT btr,		/* Number of bytes to read */
	UINT *br		/* Pointer to number of bytes read */
)
{
    462c:	2f 92       	push	r2
    462e:	3f 92       	push	r3
    4630:	4f 92       	push	r4
    4632:	5f 92       	push	r5
    4634:	6f 92       	push	r6
    4636:	7f 92       	push	r7
    4638:	8f 92       	push	r8
    463a:	9f 92       	push	r9
    463c:	af 92       	push	r10
    463e:	bf 92       	push	r11
    4640:	cf 92       	push	r12
    4642:	df 92       	push	r13
    4644:	ef 92       	push	r14
    4646:	ff 92       	push	r15
    4648:	0f 93       	push	r16
    464a:	1f 93       	push	r17
    464c:	df 93       	push	r29
    464e:	cf 93       	push	r28
    4650:	00 d0       	rcall	.+0      	; 0x4652 <f_read+0x26>
    4652:	cd b7       	in	r28, 0x3d	; 61
    4654:	de b7       	in	r29, 0x3e	; 62
    4656:	1c 01       	movw	r2, r24
    4658:	7a 01       	movw	r14, r20
    465a:	39 01       	movw	r6, r18
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;


	*br = 0;	/* Clear read byte counter */
    465c:	d9 01       	movw	r26, r18
    465e:	1d 92       	st	X+, r1
    4660:	1c 92       	st	X, r1

	res = validate(fp);							/* Check validity */
    4662:	69 83       	std	Y+1, r22	; 0x01
    4664:	7a 83       	std	Y+2, r23	; 0x02
    4666:	d2 d9       	rcall	.-3164   	; 0x3a0c <validate>
    4668:	18 2f       	mov	r17, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    466a:	69 81       	ldd	r22, Y+1	; 0x01
    466c:	7a 81       	ldd	r23, Y+2	; 0x02
    466e:	88 23       	and	r24, r24
    4670:	09 f0       	breq	.+2      	; 0x4674 <f_read+0x48>
    4672:	21 c1       	rjmp	.+578    	; 0x48b6 <f_read+0x28a>
	if (fp->flag & FA__ERROR)					/* Aborted file? */
    4674:	f1 01       	movw	r30, r2
    4676:	84 81       	ldd	r24, Z+4	; 0x04
    4678:	87 fd       	sbrc	r24, 7
    467a:	1a c1       	rjmp	.+564    	; 0x48b0 <f_read+0x284>
		LEAVE_FF(fp->fs, FR_INT_ERR);
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
    467c:	80 ff       	sbrs	r24, 0
    467e:	1a c1       	rjmp	.+564    	; 0x48b4 <f_read+0x288>
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
    4680:	82 85       	ldd	r24, Z+10	; 0x0a
    4682:	93 85       	ldd	r25, Z+11	; 0x0b
    4684:	a4 85       	ldd	r26, Z+12	; 0x0c
    4686:	b5 85       	ldd	r27, Z+13	; 0x0d
    4688:	26 81       	ldd	r18, Z+6	; 0x06
    468a:	37 81       	ldd	r19, Z+7	; 0x07
    468c:	40 85       	ldd	r20, Z+8	; 0x08
    468e:	51 85       	ldd	r21, Z+9	; 0x09
    4690:	82 1b       	sub	r24, r18
    4692:	93 0b       	sbc	r25, r19
    4694:	a4 0b       	sbc	r26, r20
    4696:	b5 0b       	sbc	r27, r21
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */
    4698:	97 01       	movw	r18, r14
    469a:	40 e0       	ldi	r20, 0x00	; 0
    469c:	50 e0       	ldi	r21, 0x00	; 0
    469e:	82 17       	cp	r24, r18
    46a0:	93 07       	cpc	r25, r19
    46a2:	a4 07       	cpc	r26, r20
    46a4:	b5 07       	cpc	r27, r21
    46a6:	08 f4       	brcc	.+2      	; 0x46aa <f_read+0x7e>
    46a8:	7c 01       	movw	r14, r24
)
{
	FRESULT res;
	DWORD clst, sect, remain;
	UINT rcnt, cc;
	BYTE csect, *rbuff = buff;
    46aa:	86 2e       	mov	r8, r22
    46ac:	97 2e       	mov	r9, r23
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    46ae:	41 2c       	mov	r4, r1
    46b0:	72 e0       	ldi	r23, 0x02	; 2
    46b2:	57 2e       	mov	r5, r23
    46b4:	f8 c0       	rjmp	.+496    	; 0x48a6 <f_read+0x27a>
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
		if ((fp->fptr % SS(fp->fs)) == 0) {		/* On the sector boundary? */
    46b6:	d1 01       	movw	r26, r2
    46b8:	16 96       	adiw	r26, 0x06	; 6
    46ba:	2d 91       	ld	r18, X+
    46bc:	3d 91       	ld	r19, X+
    46be:	4d 91       	ld	r20, X+
    46c0:	5c 91       	ld	r21, X
    46c2:	19 97       	sbiw	r26, 0x09	; 9
    46c4:	da 01       	movw	r26, r20
    46c6:	c9 01       	movw	r24, r18
    46c8:	91 70       	andi	r25, 0x01	; 1
    46ca:	a0 70       	andi	r26, 0x00	; 0
    46cc:	b0 70       	andi	r27, 0x00	; 0
    46ce:	00 97       	sbiw	r24, 0x00	; 0
    46d0:	a1 05       	cpc	r26, r1
    46d2:	b1 05       	cpc	r27, r1
    46d4:	09 f0       	breq	.+2      	; 0x46d8 <f_read+0xac>
    46d6:	83 c0       	rjmp	.+262    	; 0x47de <f_read+0x1b2>
			csect = (BYTE)(fp->fptr / SS(fp->fs) & (fp->fs->csize - 1));	/* Sector offset in the cluster */
    46d8:	f1 01       	movw	r30, r2
    46da:	80 81       	ld	r24, Z
    46dc:	91 81       	ldd	r25, Z+1	; 0x01
    46de:	59 01       	movw	r10, r18
    46e0:	6a 01       	movw	r12, r20
    46e2:	69 e0       	ldi	r22, 0x09	; 9
    46e4:	d6 94       	lsr	r13
    46e6:	c7 94       	ror	r12
    46e8:	b7 94       	ror	r11
    46ea:	a7 94       	ror	r10
    46ec:	6a 95       	dec	r22
    46ee:	d1 f7       	brne	.-12     	; 0x46e4 <f_read+0xb8>
    46f0:	dc 01       	movw	r26, r24
    46f2:	12 96       	adiw	r26, 0x02	; 2
    46f4:	0c 91       	ld	r16, X
    46f6:	12 97       	sbiw	r26, 0x02	; 2
    46f8:	01 50       	subi	r16, 0x01	; 1
    46fa:	0a 21       	and	r16, r10
			if (!csect) {						/* On the cluster boundary? */
    46fc:	29 f5       	brne	.+74     	; 0x4748 <f_read+0x11c>
				if (fp->fptr == 0) {			/* On the top of the file? */
    46fe:	21 15       	cp	r18, r1
    4700:	31 05       	cpc	r19, r1
    4702:	41 05       	cpc	r20, r1
    4704:	51 05       	cpc	r21, r1
    4706:	29 f4       	brne	.+10     	; 0x4712 <f_read+0xe6>
					clst = fp->sclust;			/* Follow from the origin */
    4708:	66 85       	ldd	r22, Z+14	; 0x0e
    470a:	77 85       	ldd	r23, Z+15	; 0x0f
    470c:	80 89       	ldd	r24, Z+16	; 0x10
    470e:	91 89       	ldd	r25, Z+17	; 0x11
    4710:	06 c0       	rjmp	.+12     	; 0x471e <f_read+0xf2>
#if _USE_FASTSEEK
					if (fp->cltbl)
						clst = clmt_clust(fp, fp->fptr);	/* Get cluster# from the CLMT */
					else
#endif
						clst = get_fat(fp->fs, fp->clust);	/* Follow cluster chain on the FAT */
    4712:	f1 01       	movw	r30, r2
    4714:	42 89       	ldd	r20, Z+18	; 0x12
    4716:	53 89       	ldd	r21, Z+19	; 0x13
    4718:	64 89       	ldd	r22, Z+20	; 0x14
    471a:	75 89       	ldd	r23, Z+21	; 0x15
    471c:	4f da       	rcall	.-2914   	; 0x3bbc <get_fat>
				}
				if (clst < 2) ABORT(fp->fs, FR_INT_ERR);
    471e:	62 30       	cpi	r22, 0x02	; 2
    4720:	71 05       	cpc	r23, r1
    4722:	81 05       	cpc	r24, r1
    4724:	91 05       	cpc	r25, r1
    4726:	00 f1       	brcs	.+64     	; 0x4768 <f_read+0x13c>
				if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4728:	6f 3f       	cpi	r22, 0xFF	; 255
    472a:	bf ef       	ldi	r27, 0xFF	; 255
    472c:	7b 07       	cpc	r23, r27
    472e:	bf ef       	ldi	r27, 0xFF	; 255
    4730:	8b 07       	cpc	r24, r27
    4732:	bf ef       	ldi	r27, 0xFF	; 255
    4734:	9b 07       	cpc	r25, r27
    4736:	09 f4       	brne	.+2      	; 0x473a <f_read+0x10e>
    4738:	41 c0       	rjmp	.+130    	; 0x47bc <f_read+0x190>
				fp->clust = clst;				/* Update current cluster */
    473a:	d1 01       	movw	r26, r2
    473c:	52 96       	adiw	r26, 0x12	; 18
    473e:	6d 93       	st	X+, r22
    4740:	7d 93       	st	X+, r23
    4742:	8d 93       	st	X+, r24
    4744:	9c 93       	st	X, r25
    4746:	55 97       	sbiw	r26, 0x15	; 21
			}
			sect = clust2sect(fp->fs, fp->clust);	/* Get current sector */
    4748:	f1 01       	movw	r30, r2
    474a:	a0 80       	ld	r10, Z
    474c:	b1 80       	ldd	r11, Z+1	; 0x01
    474e:	42 89       	ldd	r20, Z+18	; 0x12
    4750:	53 89       	ldd	r21, Z+19	; 0x13
    4752:	64 89       	ldd	r22, Z+20	; 0x14
    4754:	75 89       	ldd	r23, Z+21	; 0x15
    4756:	c5 01       	movw	r24, r10
    4758:	02 da       	rcall	.-3068   	; 0x3b5e <clust2sect>
    475a:	9b 01       	movw	r18, r22
    475c:	ac 01       	movw	r20, r24
			if (!sect) ABORT(fp->fs, FR_INT_ERR);
    475e:	61 15       	cp	r22, r1
    4760:	71 05       	cpc	r23, r1
    4762:	81 05       	cpc	r24, r1
    4764:	91 05       	cpc	r25, r1
    4766:	49 f4       	brne	.+18     	; 0x477a <f_read+0x14e>
    4768:	d1 01       	movw	r26, r2
    476a:	14 96       	adiw	r26, 0x04	; 4
    476c:	8c 91       	ld	r24, X
    476e:	14 97       	sbiw	r26, 0x04	; 4
    4770:	80 68       	ori	r24, 0x80	; 128
    4772:	14 96       	adiw	r26, 0x04	; 4
    4774:	8c 93       	st	X, r24
    4776:	14 97       	sbiw	r26, 0x04	; 4
    4778:	9b c0       	rjmp	.+310    	; 0x48b0 <f_read+0x284>
			sect += csect;
    477a:	20 0f       	add	r18, r16
    477c:	31 1d       	adc	r19, r1
    477e:	41 1d       	adc	r20, r1
    4780:	51 1d       	adc	r21, r1
			cc = btr / SS(fp->fs);				/* When remaining bytes >= sector size, */
    4782:	67 01       	movw	r12, r14
    4784:	cd 2c       	mov	r12, r13
    4786:	dd 24       	eor	r13, r13
    4788:	c6 94       	lsr	r12
			if (cc) {							/* Read maximum contiguous sectors directly */
    478a:	c1 14       	cp	r12, r1
    478c:	d1 04       	cpc	r13, r1
    478e:	01 f1       	breq	.+64     	; 0x47d0 <f_read+0x1a4>
				if (csect + cc > fp->fs->csize)	/* Clip at cluster boundary */
    4790:	f5 01       	movw	r30, r10
    4792:	62 81       	ldd	r22, Z+2	; 0x02
    4794:	80 2f       	mov	r24, r16
    4796:	90 e0       	ldi	r25, 0x00	; 0
    4798:	f6 01       	movw	r30, r12
    479a:	e8 0f       	add	r30, r24
    479c:	f9 1f       	adc	r31, r25
    479e:	70 e0       	ldi	r23, 0x00	; 0
    47a0:	6e 17       	cp	r22, r30
    47a2:	7f 07       	cpc	r23, r31
    47a4:	18 f4       	brcc	.+6      	; 0x47ac <f_read+0x180>
					cc = fp->fs->csize - csect;
    47a6:	6b 01       	movw	r12, r22
    47a8:	c8 1a       	sub	r12, r24
    47aa:	d9 0a       	sbc	r13, r25
				if (disk_read(fp->fs->drv, rbuff, sect, (BYTE)cc) != RES_OK)
    47ac:	d5 01       	movw	r26, r10
    47ae:	11 96       	adiw	r26, 0x01	; 1
    47b0:	8c 91       	ld	r24, X
    47b2:	b4 01       	movw	r22, r8
    47b4:	0c 2d       	mov	r16, r12
    47b6:	1e d9       	rcall	.-3524   	; 0x39f4 <disk_read>
    47b8:	88 23       	and	r24, r24
    47ba:	29 f0       	breq	.+10     	; 0x47c6 <f_read+0x19a>
					ABORT(fp->fs, FR_DISK_ERR);
    47bc:	f1 01       	movw	r30, r2
    47be:	84 81       	ldd	r24, Z+4	; 0x04
    47c0:	80 68       	ori	r24, 0x80	; 128
    47c2:	84 83       	std	Z+4, r24	; 0x04
    47c4:	22 c0       	rjmp	.+68     	; 0x480a <f_read+0x1de>
#else
				if ((fp->flag & FA__DIRTY) && fp->dsect - sect < cc)
					mem_cpy(rbuff + ((fp->dsect - sect) * SS(fp->fs)), fp->buf, SS(fp->fs));
#endif
#endif
				rcnt = SS(fp->fs) * cc;			/* Number of bytes transferred */
    47c6:	b6 01       	movw	r22, r12
    47c8:	76 2f       	mov	r23, r22
    47ca:	66 27       	eor	r22, r22
    47cc:	77 0f       	add	r23, r23
				continue;
    47ce:	4e c0       	rjmp	.+156    	; 0x486c <f_read+0x240>
#endif
				if (disk_read(fp->fs->drv, fp->buf, sect, 1) != RES_OK)	/* Fill sector cache */
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
    47d0:	d1 01       	movw	r26, r2
    47d2:	56 96       	adiw	r26, 0x16	; 22
    47d4:	2d 93       	st	X+, r18
    47d6:	3d 93       	st	X+, r19
    47d8:	4d 93       	st	X+, r20
    47da:	5c 93       	st	X, r21
    47dc:	59 97       	sbiw	r26, 0x19	; 25
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    47de:	f1 01       	movw	r30, r2
    47e0:	a6 80       	ldd	r10, Z+6	; 0x06
    47e2:	b7 80       	ldd	r11, Z+7	; 0x07
    47e4:	c0 84       	ldd	r12, Z+8	; 0x08
    47e6:	d1 84       	ldd	r13, Z+9	; 0x09
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
    47e8:	46 89       	ldd	r20, Z+22	; 0x16
    47ea:	57 89       	ldd	r21, Z+23	; 0x17
    47ec:	60 8d       	ldd	r22, Z+24	; 0x18
    47ee:	71 8d       	ldd	r23, Z+25	; 0x19
    47f0:	80 81       	ld	r24, Z
    47f2:	91 81       	ldd	r25, Z+1	; 0x01
    47f4:	27 d9       	rcall	.-3506   	; 0x3a44 <move_window>
    47f6:	88 23       	and	r24, r24
    47f8:	51 f0       	breq	.+20     	; 0x480e <f_read+0x1e2>
			ABORT(fp->fs, FR_DISK_ERR);
    47fa:	d1 01       	movw	r26, r2
    47fc:	14 96       	adiw	r26, 0x04	; 4
    47fe:	8c 91       	ld	r24, X
    4800:	14 97       	sbiw	r26, 0x04	; 4
    4802:	80 68       	ori	r24, 0x80	; 128
    4804:	14 96       	adiw	r26, 0x04	; 4
    4806:	8c 93       	st	X, r24
    4808:	14 97       	sbiw	r26, 0x04	; 4
    480a:	11 e0       	ldi	r17, 0x01	; 1
    480c:	54 c0       	rjmp	.+168    	; 0x48b6 <f_read+0x28a>
					ABORT(fp->fs, FR_DISK_ERR);
			}
#endif
			fp->dsect = sect;
		}
		rcnt = SS(fp->fs) - ((UINT)fp->fptr % SS(fp->fs));	/* Get partial sector data from sector buffer */
    480e:	c5 01       	movw	r24, r10
    4810:	91 70       	andi	r25, 0x01	; 1
    4812:	f2 01       	movw	r30, r4
    4814:	e8 1b       	sub	r30, r24
    4816:	f9 0b       	sbc	r31, r25
    4818:	b7 01       	movw	r22, r14
    481a:	ee 15       	cp	r30, r14
    481c:	ff 05       	cpc	r31, r15
    481e:	08 f4       	brcc	.+2      	; 0x4822 <f_read+0x1f6>
    4820:	bf 01       	movw	r22, r30
		if (rcnt > btr) rcnt = btr;
#if _FS_TINY
		if (move_window(fp->fs, fp->dsect))		/* Move sector window */
			ABORT(fp->fs, FR_DISK_ERR);
		mem_cpy(rbuff, &fp->fs->win[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
    4822:	d1 01       	movw	r26, r2
    4824:	8d 91       	ld	r24, X+
    4826:	9c 91       	ld	r25, X
    4828:	11 97       	sbiw	r26, 0x01	; 1
    482a:	82 96       	adiw	r24, 0x22	; 34
    482c:	16 96       	adiw	r26, 0x06	; 6
    482e:	2d 91       	ld	r18, X+
    4830:	3c 91       	ld	r19, X
    4832:	17 97       	sbiw	r26, 0x07	; 7
    4834:	31 70       	andi	r19, 0x01	; 1
    4836:	82 0f       	add	r24, r18
    4838:	93 1f       	adc	r25, r19

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;
    483a:	dc 01       	movw	r26, r24
/*-----------------------------------------------------------------------*/

/* Copy memory to memory */
static
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
    483c:	f4 01       	movw	r30, r8
	const BYTE *s = (const BYTE*)src;
    483e:	9b 01       	movw	r18, r22
    4840:	06 c0       	rjmp	.+12     	; 0x484e <f_read+0x222>

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
		*(int*)d = *(int*)s;
    4842:	4d 91       	ld	r20, X+
    4844:	5d 91       	ld	r21, X+
    4846:	41 93       	st	Z+, r20
    4848:	51 93       	st	Z+, r21
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
    484a:	22 50       	subi	r18, 0x02	; 2
    484c:	30 40       	sbci	r19, 0x00	; 0
void mem_cpy (void* dst, const void* src, UINT cnt) {
	BYTE *d = (BYTE*)dst;
	const BYTE *s = (const BYTE*)src;

#if _WORD_ACCESS == 1
	while (cnt >= sizeof (int)) {
    484e:	22 30       	cpi	r18, 0x02	; 2
    4850:	31 05       	cpc	r19, r1
    4852:	b8 f7       	brcc	.-18     	; 0x4842 <f_read+0x216>

/*-----------------------------------------------------------------------*/
/* Read File                                                             */
/*-----------------------------------------------------------------------*/

FRESULT f_read (
    4854:	9b 01       	movw	r18, r22
    4856:	2e 7f       	andi	r18, 0xFE	; 254
    4858:	f4 01       	movw	r30, r8
    485a:	e2 0f       	add	r30, r18
    485c:	f3 1f       	adc	r31, r19
    485e:	82 0f       	add	r24, r18
    4860:	93 1f       	adc	r25, r19
		*(int*)d = *(int*)s;
		d += sizeof (int); s += sizeof (int);
		cnt -= sizeof (int);
	}
#endif
	while (cnt--)
    4862:	60 ff       	sbrs	r22, 0
    4864:	03 c0       	rjmp	.+6      	; 0x486c <f_read+0x240>
		*d++ = *s++;
    4866:	dc 01       	movw	r26, r24
    4868:	8c 91       	ld	r24, X
    486a:	80 83       	st	Z, r24
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
		rbuff += rcnt, fp->fptr += rcnt, *br += rcnt, btr -= rcnt) {
    486c:	86 0e       	add	r8, r22
    486e:	97 1e       	adc	r9, r23
    4870:	9b 01       	movw	r18, r22
    4872:	40 e0       	ldi	r20, 0x00	; 0
    4874:	50 e0       	ldi	r21, 0x00	; 0
    4876:	f1 01       	movw	r30, r2
    4878:	86 81       	ldd	r24, Z+6	; 0x06
    487a:	97 81       	ldd	r25, Z+7	; 0x07
    487c:	a0 85       	ldd	r26, Z+8	; 0x08
    487e:	b1 85       	ldd	r27, Z+9	; 0x09
    4880:	82 0f       	add	r24, r18
    4882:	93 1f       	adc	r25, r19
    4884:	a4 1f       	adc	r26, r20
    4886:	b5 1f       	adc	r27, r21
    4888:	86 83       	std	Z+6, r24	; 0x06
    488a:	97 83       	std	Z+7, r25	; 0x07
    488c:	a0 87       	std	Z+8, r26	; 0x08
    488e:	b1 87       	std	Z+9, r27	; 0x09
    4890:	d3 01       	movw	r26, r6
    4892:	8d 91       	ld	r24, X+
    4894:	9c 91       	ld	r25, X
    4896:	11 97       	sbiw	r26, 0x01	; 1
    4898:	86 0f       	add	r24, r22
    489a:	97 1f       	adc	r25, r23
    489c:	11 96       	adiw	r26, 0x01	; 1
    489e:	9c 93       	st	X, r25
    48a0:	8e 93       	st	-X, r24
    48a2:	e6 1a       	sub	r14, r22
    48a4:	f7 0a       	sbc	r15, r23
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
	remain = fp->fsize - fp->fptr;
	if (btr > remain) btr = (UINT)remain;		/* Truncate btr by remaining bytes */

	for ( ;  btr;								/* Repeat until all data read */
    48a6:	e1 14       	cp	r14, r1
    48a8:	f1 04       	cpc	r15, r1
    48aa:	09 f0       	breq	.+2      	; 0x48ae <f_read+0x282>
    48ac:	04 cf       	rjmp	.-504    	; 0x46b6 <f_read+0x8a>
    48ae:	03 c0       	rjmp	.+6      	; 0x48b6 <f_read+0x28a>
	*br = 0;	/* Clear read byte counter */

	res = validate(fp);							/* Check validity */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)					/* Aborted file? */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    48b0:	12 e0       	ldi	r17, 0x02	; 2
    48b2:	01 c0       	rjmp	.+2      	; 0x48b6 <f_read+0x28a>
	if (!(fp->flag & FA_READ)) 					/* Check access mode */
		LEAVE_FF(fp->fs, FR_DENIED);
    48b4:	17 e0       	ldi	r17, 0x07	; 7
		mem_cpy(rbuff, &fp->buf[fp->fptr % SS(fp->fs)], rcnt);	/* Pick partial sector */
#endif
	}

	LEAVE_FF(fp->fs, FR_OK);
}
    48b6:	81 2f       	mov	r24, r17
    48b8:	0f 90       	pop	r0
    48ba:	0f 90       	pop	r0
    48bc:	cf 91       	pop	r28
    48be:	df 91       	pop	r29
    48c0:	1f 91       	pop	r17
    48c2:	0f 91       	pop	r16
    48c4:	ff 90       	pop	r15
    48c6:	ef 90       	pop	r14
    48c8:	df 90       	pop	r13
    48ca:	cf 90       	pop	r12
    48cc:	bf 90       	pop	r11
    48ce:	af 90       	pop	r10
    48d0:	9f 90       	pop	r9
    48d2:	8f 90       	pop	r8
    48d4:	7f 90       	pop	r7
    48d6:	6f 90       	pop	r6
    48d8:	5f 90       	pop	r5
    48da:	4f 90       	pop	r4
    48dc:	3f 90       	pop	r3
    48de:	2f 90       	pop	r2
    48e0:	08 95       	ret

000048e2 <f_close>:
/*-----------------------------------------------------------------------*/

FRESULT f_close (
	FIL *fp		/* Pointer to the file object to be closed */
)
{
    48e2:	cf 93       	push	r28
    48e4:	df 93       	push	r29
    48e6:	ec 01       	movw	r28, r24
	FRESULT res;


#if _FS_READONLY
	res = validate(fp);
    48e8:	91 d8       	rcall	.-3806   	; 0x3a0c <validate>
	{
#if _FS_REENTRANT
		FATFS *fs = fp->fs;
#endif
		if (res == FR_OK) fp->fs = 0;	/* Discard file object */
    48ea:	88 23       	and	r24, r24
    48ec:	11 f4       	brne	.+4      	; 0x48f2 <f_close+0x10>
    48ee:	19 82       	std	Y+1, r1	; 0x01
    48f0:	18 82       	st	Y, r1
	}
#endif
	if (res == FR_OK) fp->fs = 0;	/* Discard file object */
	return res;
#endif
}
    48f2:	df 91       	pop	r29
    48f4:	cf 91       	pop	r28
    48f6:	08 95       	ret

000048f8 <f_lseek>:

FRESULT f_lseek (
	FIL *fp,		/* Pointer to the file object */
	DWORD ofs		/* File pointer from top of file */
)
{
    48f8:	2f 92       	push	r2
    48fa:	3f 92       	push	r3
    48fc:	4f 92       	push	r4
    48fe:	5f 92       	push	r5
    4900:	6f 92       	push	r6
    4902:	7f 92       	push	r7
    4904:	9f 92       	push	r9
    4906:	af 92       	push	r10
    4908:	bf 92       	push	r11
    490a:	cf 92       	push	r12
    490c:	df 92       	push	r13
    490e:	ef 92       	push	r14
    4910:	ff 92       	push	r15
    4912:	0f 93       	push	r16
    4914:	1f 93       	push	r17
    4916:	df 93       	push	r29
    4918:	cf 93       	push	r28
    491a:	cd b7       	in	r28, 0x3d	; 61
    491c:	de b7       	in	r29, 0x3e	; 62
    491e:	28 97       	sbiw	r28, 0x08	; 8
    4920:	0f b6       	in	r0, 0x3f	; 63
    4922:	f8 94       	cli
    4924:	de bf       	out	0x3e, r29	; 62
    4926:	0f be       	out	0x3f, r0	; 63
    4928:	cd bf       	out	0x3d, r28	; 61
    492a:	1c 01       	movw	r2, r24
	FRESULT res;


	res = validate(fp);					/* Check validity of the object */
    492c:	4d 83       	std	Y+5, r20	; 0x05
    492e:	5e 83       	std	Y+6, r21	; 0x06
    4930:	6f 83       	std	Y+7, r22	; 0x07
    4932:	78 87       	std	Y+8, r23	; 0x08
    4934:	6b d8       	rcall	.-3882   	; 0x3a0c <validate>
    4936:	98 2e       	mov	r9, r24
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
    4938:	4d 81       	ldd	r20, Y+5	; 0x05
    493a:	5e 81       	ldd	r21, Y+6	; 0x06
    493c:	6f 81       	ldd	r22, Y+7	; 0x07
    493e:	78 85       	ldd	r23, Y+8	; 0x08
    4940:	88 23       	and	r24, r24
    4942:	09 f0       	breq	.+2      	; 0x4946 <f_lseek+0x4e>
    4944:	28 c1       	rjmp	.+592    	; 0x4b96 <f_lseek+0x29e>
	if (fp->flag & FA__ERROR)			/* Check abort flag */
    4946:	d1 01       	movw	r26, r2
    4948:	14 96       	adiw	r26, 0x04	; 4
    494a:	8c 91       	ld	r24, X
    494c:	14 97       	sbiw	r26, 0x04	; 4
    494e:	87 fd       	sbrc	r24, 7
    4950:	20 c1       	rjmp	.+576    	; 0x4b92 <f_lseek+0x29a>
    4952:	1a 96       	adiw	r26, 0x0a	; 10
    4954:	8d 91       	ld	r24, X+
    4956:	9d 91       	ld	r25, X+
    4958:	0d 90       	ld	r0, X+
    495a:	bc 91       	ld	r27, X
    495c:	a0 2d       	mov	r26, r0
    495e:	e4 2e       	mov	r14, r20
    4960:	f5 2e       	mov	r15, r21
    4962:	06 2f       	mov	r16, r22
    4964:	17 2f       	mov	r17, r23
    4966:	8e 15       	cp	r24, r14
    4968:	9f 05       	cpc	r25, r15
    496a:	a0 07       	cpc	r26, r16
    496c:	b1 07       	cpc	r27, r17
    496e:	10 f4       	brcc	.+4      	; 0x4974 <f_lseek+0x7c>
    4970:	7c 01       	movw	r14, r24
    4972:	8d 01       	movw	r16, r26
#if !_FS_READONLY
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
    4974:	f1 01       	movw	r30, r2
    4976:	86 81       	ldd	r24, Z+6	; 0x06
    4978:	97 81       	ldd	r25, Z+7	; 0x07
    497a:	a0 85       	ldd	r26, Z+8	; 0x08
    497c:	b1 85       	ldd	r27, Z+9	; 0x09
		fp->fptr = nsect = 0;
    497e:	16 82       	std	Z+6, r1	; 0x06
    4980:	17 82       	std	Z+7, r1	; 0x07
    4982:	10 86       	std	Z+8, r1	; 0x08
    4984:	11 86       	std	Z+9, r1	; 0x09
		if (ofs) {
    4986:	e1 14       	cp	r14, r1
    4988:	f1 04       	cpc	r15, r1
    498a:	01 05       	cpc	r16, r1
    498c:	11 05       	cpc	r17, r1
    498e:	09 f4       	brne	.+2      	; 0x4992 <f_lseek+0x9a>
    4990:	e0 c0       	rjmp	.+448    	; 0x4b52 <f_lseek+0x25a>
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
    4992:	20 81       	ld	r18, Z
    4994:	31 81       	ldd	r19, Z+1	; 0x01
    4996:	f9 01       	movw	r30, r18
    4998:	a2 80       	ldd	r10, Z+2	; 0x02
    499a:	bb 24       	eor	r11, r11
    499c:	cc 24       	eor	r12, r12
    499e:	dd 24       	eor	r13, r13
    49a0:	29 e0       	ldi	r18, 0x09	; 9
    49a2:	aa 0c       	add	r10, r10
    49a4:	bb 1c       	adc	r11, r11
    49a6:	cc 1c       	adc	r12, r12
    49a8:	dd 1c       	adc	r13, r13
    49aa:	2a 95       	dec	r18
    49ac:	d1 f7       	brne	.-12     	; 0x49a2 <f_lseek+0xaa>
			if (ifptr > 0 &&
    49ae:	00 97       	sbiw	r24, 0x00	; 0
    49b0:	a1 05       	cpc	r26, r1
    49b2:	b1 05       	cpc	r27, r1
    49b4:	e9 f1       	breq	.+122    	; 0x4a30 <f_lseek+0x138>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
    49b6:	2c 01       	movw	r4, r24
    49b8:	3d 01       	movw	r6, r26
    49ba:	08 94       	sec
    49bc:	41 08       	sbc	r4, r1
    49be:	51 08       	sbc	r5, r1
    49c0:	61 08       	sbc	r6, r1
    49c2:	71 08       	sbc	r7, r1
    49c4:	c8 01       	movw	r24, r16
    49c6:	b7 01       	movw	r22, r14
    49c8:	61 50       	subi	r22, 0x01	; 1
    49ca:	70 40       	sbci	r23, 0x00	; 0
    49cc:	80 40       	sbci	r24, 0x00	; 0
    49ce:	90 40       	sbci	r25, 0x00	; 0
    49d0:	a6 01       	movw	r20, r12
    49d2:	95 01       	movw	r18, r10
    49d4:	0e 94 ad 3c 	call	0x795a	; 0x795a <__udivmodsi4>
    49d8:	29 83       	std	Y+1, r18	; 0x01
    49da:	3a 83       	std	Y+2, r19	; 0x02
    49dc:	4b 83       	std	Y+3, r20	; 0x03
    49de:	5c 83       	std	Y+4, r21	; 0x04
    49e0:	c3 01       	movw	r24, r6
    49e2:	b2 01       	movw	r22, r4
    49e4:	a6 01       	movw	r20, r12
    49e6:	95 01       	movw	r18, r10
    49e8:	0e 94 ad 3c 	call	0x795a	; 0x795a <__udivmodsi4>

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
		if (ofs) {
			bcs = (DWORD)fp->fs->csize * SS(fp->fs);	/* Cluster size (byte) */
			if (ifptr > 0 &&
    49ec:	89 81       	ldd	r24, Y+1	; 0x01
    49ee:	9a 81       	ldd	r25, Y+2	; 0x02
    49f0:	ab 81       	ldd	r26, Y+3	; 0x03
    49f2:	bc 81       	ldd	r27, Y+4	; 0x04
    49f4:	82 17       	cp	r24, r18
    49f6:	93 07       	cpc	r25, r19
    49f8:	a4 07       	cpc	r26, r20
    49fa:	b5 07       	cpc	r27, r21
    49fc:	c8 f0       	brcs	.+50     	; 0x4a30 <f_lseek+0x138>
				(ofs - 1) / bcs >= (ifptr - 1) / bcs) {	/* When seek to same or following cluster, */
				fp->fptr = (ifptr - 1) & ~(bcs - 1);	/* start from the current cluster */
    49fe:	88 27       	eor	r24, r24
    4a00:	99 27       	eor	r25, r25
    4a02:	dc 01       	movw	r26, r24
    4a04:	8a 19       	sub	r24, r10
    4a06:	9b 09       	sbc	r25, r11
    4a08:	ac 09       	sbc	r26, r12
    4a0a:	bd 09       	sbc	r27, r13
    4a0c:	84 21       	and	r24, r4
    4a0e:	95 21       	and	r25, r5
    4a10:	a6 21       	and	r26, r6
    4a12:	b7 21       	and	r27, r7
    4a14:	f1 01       	movw	r30, r2
    4a16:	86 83       	std	Z+6, r24	; 0x06
    4a18:	97 83       	std	Z+7, r25	; 0x07
    4a1a:	a0 87       	std	Z+8, r26	; 0x08
    4a1c:	b1 87       	std	Z+9, r27	; 0x09
				ofs -= fp->fptr;
    4a1e:	e8 1a       	sub	r14, r24
    4a20:	f9 0a       	sbc	r15, r25
    4a22:	0a 0b       	sbc	r16, r26
    4a24:	1b 0b       	sbc	r17, r27
				clst = fp->clust;
    4a26:	42 89       	ldd	r20, Z+18	; 0x12
    4a28:	53 89       	ldd	r21, Z+19	; 0x13
    4a2a:	64 89       	ldd	r22, Z+20	; 0x14
    4a2c:	75 89       	ldd	r23, Z+21	; 0x15
    4a2e:	0c c0       	rjmp	.+24     	; 0x4a48 <f_lseek+0x150>
			} else {									/* When seek to back cluster, */
				clst = fp->sclust;						/* start from the first cluster */
    4a30:	d1 01       	movw	r26, r2
    4a32:	1e 96       	adiw	r26, 0x0e	; 14
    4a34:	4d 91       	ld	r20, X+
    4a36:	5d 91       	ld	r21, X+
    4a38:	6d 91       	ld	r22, X+
    4a3a:	7c 91       	ld	r23, X
    4a3c:	51 97       	sbiw	r26, 0x11	; 17
					if (clst == 1) ABORT(fp->fs, FR_INT_ERR);
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
					fp->sclust = clst;
				}
#endif
				fp->clust = clst;
    4a3e:	f1 01       	movw	r30, r2
    4a40:	42 8b       	std	Z+18, r20	; 0x12
    4a42:	53 8b       	std	Z+19, r21	; 0x13
    4a44:	64 8b       	std	Z+20, r22	; 0x14
    4a46:	75 8b       	std	Z+21, r23	; 0x15
			}
			if (clst != 0) {
    4a48:	41 15       	cp	r20, r1
    4a4a:	51 05       	cpc	r21, r1
    4a4c:	61 05       	cpc	r22, r1
    4a4e:	71 05       	cpc	r23, r1
    4a50:	09 f4       	brne	.+2      	; 0x4a54 <f_lseek+0x15c>
    4a52:	7f c0       	rjmp	.+254    	; 0x4b52 <f_lseek+0x25a>
    4a54:	45 c0       	rjmp	.+138    	; 0x4ae0 <f_lseek+0x1e8>
						if (clst == 0) {				/* When disk gets full, clip file size */
							ofs = bcs; break;
						}
					} else
#endif
						clst = get_fat(fp->fs, clst);	/* Follow cluster chain if not in write mode */
    4a56:	d1 01       	movw	r26, r2
    4a58:	8d 91       	ld	r24, X+
    4a5a:	9c 91       	ld	r25, X
    4a5c:	af d8       	rcall	.-3746   	; 0x3bbc <get_fat>
    4a5e:	ab 01       	movw	r20, r22
    4a60:	bc 01       	movw	r22, r24
					if (clst == 0xFFFFFFFF) ABORT(fp->fs, FR_DISK_ERR);
    4a62:	4f 3f       	cpi	r20, 0xFF	; 255
    4a64:	bf ef       	ldi	r27, 0xFF	; 255
    4a66:	5b 07       	cpc	r21, r27
    4a68:	bf ef       	ldi	r27, 0xFF	; 255
    4a6a:	6b 07       	cpc	r22, r27
    4a6c:	bf ef       	ldi	r27, 0xFF	; 255
    4a6e:	7b 07       	cpc	r23, r27
    4a70:	39 f4       	brne	.+14     	; 0x4a80 <f_lseek+0x188>
    4a72:	f1 01       	movw	r30, r2
    4a74:	84 81       	ldd	r24, Z+4	; 0x04
    4a76:	80 68       	ori	r24, 0x80	; 128
    4a78:	84 83       	std	Z+4, r24	; 0x04
    4a7a:	99 24       	eor	r9, r9
    4a7c:	93 94       	inc	r9
    4a7e:	8b c0       	rjmp	.+278    	; 0x4b96 <f_lseek+0x29e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
    4a80:	42 30       	cpi	r20, 0x02	; 2
    4a82:	51 05       	cpc	r21, r1
    4a84:	61 05       	cpc	r22, r1
    4a86:	71 05       	cpc	r23, r1
    4a88:	60 f0       	brcs	.+24     	; 0x4aa2 <f_lseek+0x1aa>
    4a8a:	d1 01       	movw	r26, r2
    4a8c:	ed 91       	ld	r30, X+
    4a8e:	fc 91       	ld	r31, X
    4a90:	82 85       	ldd	r24, Z+10	; 0x0a
    4a92:	93 85       	ldd	r25, Z+11	; 0x0b
    4a94:	a4 85       	ldd	r26, Z+12	; 0x0c
    4a96:	b5 85       	ldd	r27, Z+13	; 0x0d
    4a98:	48 17       	cp	r20, r24
    4a9a:	59 07       	cpc	r21, r25
    4a9c:	6a 07       	cpc	r22, r26
    4a9e:	7b 07       	cpc	r23, r27
    4aa0:	28 f0       	brcs	.+10     	; 0x4aac <f_lseek+0x1b4>
    4aa2:	f1 01       	movw	r30, r2
    4aa4:	84 81       	ldd	r24, Z+4	; 0x04
    4aa6:	80 68       	ori	r24, 0x80	; 128
    4aa8:	84 83       	std	Z+4, r24	; 0x04
    4aaa:	73 c0       	rjmp	.+230    	; 0x4b92 <f_lseek+0x29a>
					fp->clust = clst;
    4aac:	d1 01       	movw	r26, r2
    4aae:	52 96       	adiw	r26, 0x12	; 18
    4ab0:	4d 93       	st	X+, r20
    4ab2:	5d 93       	st	X+, r21
    4ab4:	6d 93       	st	X+, r22
    4ab6:	7c 93       	st	X, r23
    4ab8:	55 97       	sbiw	r26, 0x15	; 21
					fp->fptr += bcs;
    4aba:	16 96       	adiw	r26, 0x06	; 6
    4abc:	8d 91       	ld	r24, X+
    4abe:	9d 91       	ld	r25, X+
    4ac0:	0d 90       	ld	r0, X+
    4ac2:	bc 91       	ld	r27, X
    4ac4:	a0 2d       	mov	r26, r0
    4ac6:	8a 0d       	add	r24, r10
    4ac8:	9b 1d       	adc	r25, r11
    4aca:	ac 1d       	adc	r26, r12
    4acc:	bd 1d       	adc	r27, r13
    4ace:	f1 01       	movw	r30, r2
    4ad0:	86 83       	std	Z+6, r24	; 0x06
    4ad2:	97 83       	std	Z+7, r25	; 0x07
    4ad4:	a0 87       	std	Z+8, r26	; 0x08
    4ad6:	b1 87       	std	Z+9, r27	; 0x09
					ofs -= bcs;
    4ad8:	ea 18       	sub	r14, r10
    4ada:	fb 08       	sbc	r15, r11
    4adc:	0c 09       	sbc	r16, r12
    4ade:	1d 09       	sbc	r17, r13
				}
#endif
				fp->clust = clst;
			}
			if (clst != 0) {
				while (ofs > bcs) {						/* Cluster following loop */
    4ae0:	ae 14       	cp	r10, r14
    4ae2:	bf 04       	cpc	r11, r15
    4ae4:	c0 06       	cpc	r12, r16
    4ae6:	d1 06       	cpc	r13, r17
    4ae8:	08 f4       	brcc	.+2      	; 0x4aec <f_lseek+0x1f4>
    4aea:	b5 cf       	rjmp	.-150    	; 0x4a56 <f_lseek+0x15e>
					if (clst <= 1 || clst >= fp->fs->n_fatent) ABORT(fp->fs, FR_INT_ERR);
					fp->clust = clst;
					fp->fptr += bcs;
					ofs -= bcs;
				}
				fp->fptr += ofs;
    4aec:	f1 01       	movw	r30, r2
    4aee:	86 81       	ldd	r24, Z+6	; 0x06
    4af0:	97 81       	ldd	r25, Z+7	; 0x07
    4af2:	a0 85       	ldd	r26, Z+8	; 0x08
    4af4:	b1 85       	ldd	r27, Z+9	; 0x09
    4af6:	8e 0d       	add	r24, r14
    4af8:	9f 1d       	adc	r25, r15
    4afa:	a0 1f       	adc	r26, r16
    4afc:	b1 1f       	adc	r27, r17
    4afe:	86 83       	std	Z+6, r24	; 0x06
    4b00:	97 83       	std	Z+7, r25	; 0x07
    4b02:	a0 87       	std	Z+8, r26	; 0x08
    4b04:	b1 87       	std	Z+9, r27	; 0x09
				if (ofs % SS(fp->fs)) {
    4b06:	d8 01       	movw	r26, r16
    4b08:	c7 01       	movw	r24, r14
    4b0a:	91 70       	andi	r25, 0x01	; 1
    4b0c:	a0 70       	andi	r26, 0x00	; 0
    4b0e:	b0 70       	andi	r27, 0x00	; 0
    4b10:	00 97       	sbiw	r24, 0x00	; 0
    4b12:	a1 05       	cpc	r26, r1
    4b14:	b1 05       	cpc	r27, r1
    4b16:	e9 f0       	breq	.+58     	; 0x4b52 <f_lseek+0x25a>
					nsect = clust2sect(fp->fs, clst);	/* Current sector */
    4b18:	80 81       	ld	r24, Z
    4b1a:	91 81       	ldd	r25, Z+1	; 0x01
    4b1c:	20 d8       	rcall	.-4032   	; 0x3b5e <clust2sect>
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
    4b1e:	61 15       	cp	r22, r1
    4b20:	71 05       	cpc	r23, r1
    4b22:	81 05       	cpc	r24, r1
    4b24:	91 05       	cpc	r25, r1
    4b26:	49 f4       	brne	.+18     	; 0x4b3a <f_lseek+0x242>
    4b28:	d1 01       	movw	r26, r2
    4b2a:	14 96       	adiw	r26, 0x04	; 4
    4b2c:	8c 91       	ld	r24, X
    4b2e:	14 97       	sbiw	r26, 0x04	; 4
    4b30:	80 68       	ori	r24, 0x80	; 128
    4b32:	14 96       	adiw	r26, 0x04	; 4
    4b34:	8c 93       	st	X, r24
    4b36:	14 97       	sbiw	r26, 0x04	; 4
    4b38:	2c c0       	rjmp	.+88     	; 0x4b92 <f_lseek+0x29a>
					nsect += ofs / SS(fp->fs);
    4b3a:	f9 e0       	ldi	r31, 0x09	; 9
    4b3c:	16 95       	lsr	r17
    4b3e:	07 95       	ror	r16
    4b40:	f7 94       	ror	r15
    4b42:	e7 94       	ror	r14
    4b44:	fa 95       	dec	r31
    4b46:	d1 f7       	brne	.-12     	; 0x4b3c <f_lseek+0x244>
    4b48:	e6 0e       	add	r14, r22
    4b4a:	f7 1e       	adc	r15, r23
    4b4c:	08 1f       	adc	r16, r24
    4b4e:	19 1f       	adc	r17, r25
    4b50:	03 c0       	rjmp	.+6      	; 0x4b58 <f_lseek+0x260>
			 && !(fp->flag & FA_WRITE)
#endif
			) ofs = fp->fsize;

		ifptr = fp->fptr;
		fp->fptr = nsect = 0;
    4b52:	ee 24       	eor	r14, r14
    4b54:	ff 24       	eor	r15, r15
    4b56:	87 01       	movw	r16, r14
					if (!nsect) ABORT(fp->fs, FR_INT_ERR);
					nsect += ofs / SS(fp->fs);
				}
			}
		}
		if (fp->fptr % SS(fp->fs) && nsect != fp->dsect) {	/* Fill sector cache if needed */
    4b58:	f1 01       	movw	r30, r2
    4b5a:	86 81       	ldd	r24, Z+6	; 0x06
    4b5c:	97 81       	ldd	r25, Z+7	; 0x07
    4b5e:	a0 85       	ldd	r26, Z+8	; 0x08
    4b60:	b1 85       	ldd	r27, Z+9	; 0x09
    4b62:	91 70       	andi	r25, 0x01	; 1
    4b64:	a0 70       	andi	r26, 0x00	; 0
    4b66:	b0 70       	andi	r27, 0x00	; 0
    4b68:	00 97       	sbiw	r24, 0x00	; 0
    4b6a:	a1 05       	cpc	r26, r1
    4b6c:	b1 05       	cpc	r27, r1
    4b6e:	99 f0       	breq	.+38     	; 0x4b96 <f_lseek+0x29e>
    4b70:	86 89       	ldd	r24, Z+22	; 0x16
    4b72:	97 89       	ldd	r25, Z+23	; 0x17
    4b74:	a0 8d       	ldd	r26, Z+24	; 0x18
    4b76:	b1 8d       	ldd	r27, Z+25	; 0x19
    4b78:	e8 16       	cp	r14, r24
    4b7a:	f9 06       	cpc	r15, r25
    4b7c:	0a 07       	cpc	r16, r26
    4b7e:	1b 07       	cpc	r17, r27
    4b80:	51 f0       	breq	.+20     	; 0x4b96 <f_lseek+0x29e>
			}
#endif
			if (disk_read(fp->fs->drv, fp->buf, nsect, 1) != RES_OK)	/* Fill sector cache */
				ABORT(fp->fs, FR_DISK_ERR);
#endif
			fp->dsect = nsect;
    4b82:	d1 01       	movw	r26, r2
    4b84:	56 96       	adiw	r26, 0x16	; 22
    4b86:	ed 92       	st	X+, r14
    4b88:	fd 92       	st	X+, r15
    4b8a:	0d 93       	st	X+, r16
    4b8c:	1c 93       	st	X, r17
    4b8e:	59 97       	sbiw	r26, 0x19	; 25
    4b90:	02 c0       	rjmp	.+4      	; 0x4b96 <f_lseek+0x29e>


	res = validate(fp);					/* Check validity of the object */
	if (res != FR_OK) LEAVE_FF(fp->fs, res);
	if (fp->flag & FA__ERROR)			/* Check abort flag */
		LEAVE_FF(fp->fs, FR_INT_ERR);
    4b92:	e2 e0       	ldi	r30, 0x02	; 2
    4b94:	9e 2e       	mov	r9, r30
		}
#endif
	}

	LEAVE_FF(fp->fs, res);
}
    4b96:	89 2d       	mov	r24, r9
    4b98:	28 96       	adiw	r28, 0x08	; 8
    4b9a:	0f b6       	in	r0, 0x3f	; 63
    4b9c:	f8 94       	cli
    4b9e:	de bf       	out	0x3e, r29	; 62
    4ba0:	0f be       	out	0x3f, r0	; 63
    4ba2:	cd bf       	out	0x3d, r28	; 61
    4ba4:	cf 91       	pop	r28
    4ba6:	df 91       	pop	r29
    4ba8:	1f 91       	pop	r17
    4baa:	0f 91       	pop	r16
    4bac:	ff 90       	pop	r15
    4bae:	ef 90       	pop	r14
    4bb0:	df 90       	pop	r13
    4bb2:	cf 90       	pop	r12
    4bb4:	bf 90       	pop	r11
    4bb6:	af 90       	pop	r10
    4bb8:	9f 90       	pop	r9
    4bba:	7f 90       	pop	r7
    4bbc:	6f 90       	pop	r6
    4bbe:	5f 90       	pop	r5
    4bc0:	4f 90       	pop	r4
    4bc2:	3f 90       	pop	r3
    4bc4:	2f 90       	pop	r2
    4bc6:	08 95       	ret

00004bc8 <Endpoint_Null_Stream>:

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    4bc8:	df 92       	push	r13
    4bca:	ef 92       	push	r14
    4bcc:	ff 92       	push	r15
    4bce:	0f 93       	push	r16
    4bd0:	1f 93       	push	r17
    4bd2:	cf 93       	push	r28
    4bd4:	df 93       	push	r29
    4bd6:	ec 01       	movw	r28, r24
    4bd8:	8b 01       	movw	r16, r22
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4bda:	da d2       	rcall	.+1460   	; 0x5190 <Endpoint_WaitUntilReady>
    4bdc:	d8 2e       	mov	r13, r24
    4bde:	88 23       	and	r24, r24
    4be0:	79 f5       	brne	.+94     	; 0x4c40 <Endpoint_Null_Stream+0x78>
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
    4be2:	01 15       	cp	r16, r1
    4be4:	11 05       	cpc	r17, r1
    4be6:	29 f0       	breq	.+10     	; 0x4bf2 <Endpoint_Null_Stream+0x2a>
	  Length -= *BytesProcessed;
    4be8:	f8 01       	movw	r30, r16
    4bea:	20 81       	ld	r18, Z
    4bec:	31 81       	ldd	r19, Z+1	; 0x01
    4bee:	c2 1b       	sub	r28, r18
    4bf0:	d3 0b       	sbc	r29, r19
	return ENDPOINT_RWSTREAM_NoError;
}

uint8_t Endpoint_Null_Stream(uint16_t Length,
                             uint16_t* const BytesProcessed)
{
    4bf2:	ee 24       	eor	r14, r14
    4bf4:	ff 24       	eor	r15, r15
    4bf6:	20 c0       	rjmp	.+64     	; 0x4c38 <Endpoint_Null_Stream+0x70>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4bf8:	80 91 e8 00 	lds	r24, 0x00E8
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4bfc:	85 fd       	sbrc	r24, 5
    4bfe:	16 c0       	rjmp	.+44     	; 0x4c2c <Endpoint_Null_Stream+0x64>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4c00:	80 91 e8 00 	lds	r24, 0x00E8
    4c04:	8e 77       	andi	r24, 0x7E	; 126
    4c06:	80 93 e8 00 	sts	0x00E8, r24
		{
			Endpoint_ClearIN();

			if (BytesProcessed != NULL)
    4c0a:	01 15       	cp	r16, r1
    4c0c:	11 05       	cpc	r17, r1
    4c0e:	51 f0       	breq	.+20     	; 0x4c24 <Endpoint_Null_Stream+0x5c>
			{
				*BytesProcessed += BytesInTransfer;
    4c10:	f8 01       	movw	r30, r16
    4c12:	80 81       	ld	r24, Z
    4c14:	91 81       	ldd	r25, Z+1	; 0x01
    4c16:	8e 0d       	add	r24, r14
    4c18:	9f 1d       	adc	r25, r15
    4c1a:	91 83       	std	Z+1, r25	; 0x01
    4c1c:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4c1e:	95 e0       	ldi	r25, 0x05	; 5
    4c20:	d9 2e       	mov	r13, r25
    4c22:	0e c0       	rjmp	.+28     	; 0x4c40 <Endpoint_Null_Stream+0x78>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c24:	b5 d2       	rcall	.+1386   	; 0x5190 <Endpoint_WaitUntilReady>
    4c26:	88 23       	and	r24, r24
    4c28:	39 f0       	breq	.+14     	; 0x4c38 <Endpoint_Null_Stream+0x70>
    4c2a:	09 c0       	rjmp	.+18     	; 0x4c3e <Endpoint_Null_Stream+0x76>
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4c2c:	10 92 f1 00 	sts	0x00F1, r1
		}
		else
		{
			Endpoint_Write_8(0);

			Length--;
    4c30:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
    4c32:	08 94       	sec
    4c34:	e1 1c       	adc	r14, r1
    4c36:	f1 1c       	adc	r15, r1
	  return ErrorCode;
	  
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    4c38:	20 97       	sbiw	r28, 0x00	; 0
    4c3a:	f1 f6       	brne	.-68     	; 0x4bf8 <Endpoint_Null_Stream+0x30>
    4c3c:	01 c0       	rjmp	.+2      	; 0x4c40 <Endpoint_Null_Stream+0x78>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c3e:	d8 2e       	mov	r13, r24
			BytesInTransfer++;
		}
	}
	
	return ENDPOINT_RWSTREAM_NoError;
}
    4c40:	8d 2d       	mov	r24, r13
    4c42:	df 91       	pop	r29
    4c44:	cf 91       	pop	r28
    4c46:	1f 91       	pop	r17
    4c48:	0f 91       	pop	r16
    4c4a:	ff 90       	pop	r15
    4c4c:	ef 90       	pop	r14
    4c4e:	df 90       	pop	r13
    4c50:	08 95       	ret

00004c52 <Endpoint_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4c52:	8f 92       	push	r8
    4c54:	9f 92       	push	r9
    4c56:	bf 92       	push	r11
    4c58:	cf 92       	push	r12
    4c5a:	df 92       	push	r13
    4c5c:	ef 92       	push	r14
    4c5e:	ff 92       	push	r15
    4c60:	0f 93       	push	r16
    4c62:	1f 93       	push	r17
    4c64:	df 93       	push	r29
    4c66:	cf 93       	push	r28
    4c68:	0f 92       	push	r0
    4c6a:	cd b7       	in	r28, 0x3d	; 61
    4c6c:	de b7       	in	r29, 0x3e	; 62
    4c6e:	e8 2e       	mov	r14, r24
    4c70:	4b 01       	movw	r8, r22
    4c72:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4c74:	99 83       	std	Y+1, r25	; 0x01
    4c76:	8c d2       	rcall	.+1304   	; 0x5190 <Endpoint_WaitUntilReady>
    4c78:	b8 2e       	mov	r11, r24
    4c7a:	99 81       	ldd	r25, Y+1	; 0x01
    4c7c:	88 23       	and	r24, r24
    4c7e:	c1 f5       	brne	.+112    	; 0x4cf0 <Endpoint_Write_Stream_LE+0x9e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4c80:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4c82:	01 15       	cp	r16, r1
    4c84:	11 05       	cpc	r17, r1
    4c86:	39 f0       	breq	.+14     	; 0x4c96 <Endpoint_Write_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
    4c88:	f8 01       	movw	r30, r16
    4c8a:	20 81       	ld	r18, Z
    4c8c:	31 81       	ldd	r19, Z+1	; 0x01
    4c8e:	82 1a       	sub	r8, r18
    4c90:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4c92:	e2 0e       	add	r14, r18
    4c94:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4c96:	cc 24       	eor	r12, r12
    4c98:	dd 24       	eor	r13, r13
    4c9a:	25 c0       	rjmp	.+74     	; 0x4ce6 <Endpoint_Write_Stream_LE+0x94>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4c9c:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4ca0:	85 fd       	sbrc	r24, 5
    4ca2:	16 c0       	rjmp	.+44     	; 0x4cd0 <Endpoint_Write_Stream_LE+0x7e>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4ca4:	80 91 e8 00 	lds	r24, 0x00E8
    4ca8:	8e 77       	andi	r24, 0x7E	; 126
    4caa:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4cae:	01 15       	cp	r16, r1
    4cb0:	11 05       	cpc	r17, r1
    4cb2:	51 f0       	breq	.+20     	; 0x4cc8 <Endpoint_Write_Stream_LE+0x76>
			{
				*BytesProcessed += BytesInTransfer;
    4cb4:	f8 01       	movw	r30, r16
    4cb6:	80 81       	ld	r24, Z
    4cb8:	91 81       	ldd	r25, Z+1	; 0x01
    4cba:	8c 0d       	add	r24, r12
    4cbc:	9d 1d       	adc	r25, r13
    4cbe:	91 83       	std	Z+1, r25	; 0x01
    4cc0:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4cc2:	25 e0       	ldi	r18, 0x05	; 5
    4cc4:	b2 2e       	mov	r11, r18
    4cc6:	14 c0       	rjmp	.+40     	; 0x4cf0 <Endpoint_Write_Stream_LE+0x9e>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4cc8:	63 d2       	rcall	.+1222   	; 0x5190 <Endpoint_WaitUntilReady>
    4cca:	88 23       	and	r24, r24
    4ccc:	61 f0       	breq	.+24     	; 0x4ce6 <Endpoint_Write_Stream_LE+0x94>
    4cce:	0f c0       	rjmp	.+30     	; 0x4cee <Endpoint_Write_Stream_LE+0x9c>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4cd0:	f7 01       	movw	r30, r14
    4cd2:	81 91       	ld	r24, Z+
    4cd4:	7f 01       	movw	r14, r30
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4cd6:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4cda:	08 94       	sec
    4cdc:	81 08       	sbc	r8, r1
    4cde:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    4ce0:	08 94       	sec
    4ce2:	c1 1c       	adc	r12, r1
    4ce4:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4ce6:	81 14       	cp	r8, r1
    4ce8:	91 04       	cpc	r9, r1
    4cea:	c1 f6       	brne	.-80     	; 0x4c9c <Endpoint_Write_Stream_LE+0x4a>
    4cec:	01 c0       	rjmp	.+2      	; 0x4cf0 <Endpoint_Write_Stream_LE+0x9e>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4cee:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4cf0:	8b 2d       	mov	r24, r11
    4cf2:	0f 90       	pop	r0
    4cf4:	cf 91       	pop	r28
    4cf6:	df 91       	pop	r29
    4cf8:	1f 91       	pop	r17
    4cfa:	0f 91       	pop	r16
    4cfc:	ff 90       	pop	r15
    4cfe:	ef 90       	pop	r14
    4d00:	df 90       	pop	r13
    4d02:	cf 90       	pop	r12
    4d04:	bf 90       	pop	r11
    4d06:	9f 90       	pop	r9
    4d08:	8f 90       	pop	r8
    4d0a:	08 95       	ret

00004d0c <Endpoint_Write_Stream_BE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4d0c:	bf 92       	push	r11
    4d0e:	cf 92       	push	r12
    4d10:	df 92       	push	r13
    4d12:	ef 92       	push	r14
    4d14:	ff 92       	push	r15
    4d16:	0f 93       	push	r16
    4d18:	1f 93       	push	r17
    4d1a:	cf 93       	push	r28
    4d1c:	df 93       	push	r29
    4d1e:	6c 01       	movw	r12, r24
    4d20:	eb 01       	movw	r28, r22
    4d22:	7a 01       	movw	r14, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d24:	35 d2       	rcall	.+1130   	; 0x5190 <Endpoint_WaitUntilReady>
    4d26:	b8 2e       	mov	r11, r24
    4d28:	88 23       	and	r24, r24
    4d2a:	d1 f5       	brne	.+116    	; 0x4da0 <Endpoint_Write_Stream_BE+0x94>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4d2c:	8e 01       	movw	r16, r28
    4d2e:	01 50       	subi	r16, 0x01	; 1
    4d30:	10 40       	sbci	r17, 0x00	; 0
    4d32:	0c 0d       	add	r16, r12
    4d34:	1d 1d       	adc	r17, r13
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4d36:	e1 14       	cp	r14, r1
    4d38:	f1 04       	cpc	r15, r1
    4d3a:	39 f0       	breq	.+14     	; 0x4d4a <Endpoint_Write_Stream_BE+0x3e>
	{
		Length -= *BytesProcessed;
    4d3c:	f7 01       	movw	r30, r14
    4d3e:	20 81       	ld	r18, Z
    4d40:	31 81       	ldd	r19, Z+1	; 0x01
    4d42:	c2 1b       	sub	r28, r18
    4d44:	d3 0b       	sbc	r29, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4d46:	02 1b       	sub	r16, r18
    4d48:	13 0b       	sbc	r17, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4d4a:	cc 24       	eor	r12, r12
    4d4c:	dd 24       	eor	r13, r13
    4d4e:	24 c0       	rjmp	.+72     	; 0x4d98 <Endpoint_Write_Stream_BE+0x8c>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4d50:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4d54:	85 fd       	sbrc	r24, 5
    4d56:	16 c0       	rjmp	.+44     	; 0x4d84 <Endpoint_Write_Stream_BE+0x78>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4d58:	80 91 e8 00 	lds	r24, 0x00E8
    4d5c:	8e 77       	andi	r24, 0x7E	; 126
    4d5e:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4d62:	e1 14       	cp	r14, r1
    4d64:	f1 04       	cpc	r15, r1
    4d66:	51 f0       	breq	.+20     	; 0x4d7c <Endpoint_Write_Stream_BE+0x70>
			{
				*BytesProcessed += BytesInTransfer;
    4d68:	f7 01       	movw	r30, r14
    4d6a:	80 81       	ld	r24, Z
    4d6c:	91 81       	ldd	r25, Z+1	; 0x01
    4d6e:	8c 0d       	add	r24, r12
    4d70:	9d 1d       	adc	r25, r13
    4d72:	91 83       	std	Z+1, r25	; 0x01
    4d74:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4d76:	35 e0       	ldi	r19, 0x05	; 5
    4d78:	b3 2e       	mov	r11, r19
    4d7a:	12 c0       	rjmp	.+36     	; 0x4da0 <Endpoint_Write_Stream_BE+0x94>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d7c:	09 d2       	rcall	.+1042   	; 0x5190 <Endpoint_WaitUntilReady>
    4d7e:	88 23       	and	r24, r24
    4d80:	59 f0       	breq	.+22     	; 0x4d98 <Endpoint_Write_Stream_BE+0x8c>
    4d82:	0d c0       	rjmp	.+26     	; 0x4d9e <Endpoint_Write_Stream_BE+0x92>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4d84:	f8 01       	movw	r30, r16
    4d86:	80 81       	ld	r24, Z
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4d88:	80 93 f1 00 	sts	0x00F1, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
    4d8c:	01 50       	subi	r16, 0x01	; 1
    4d8e:	10 40       	sbci	r17, 0x00	; 0
			Length--;
    4d90:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
    4d92:	08 94       	sec
    4d94:	c1 1c       	adc	r12, r1
    4d96:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4d98:	20 97       	sbiw	r28, 0x00	; 0
    4d9a:	d1 f6       	brne	.-76     	; 0x4d50 <Endpoint_Write_Stream_BE+0x44>
    4d9c:	01 c0       	rjmp	.+2      	; 0x4da0 <Endpoint_Write_Stream_BE+0x94>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4d9e:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4da0:	8b 2d       	mov	r24, r11
    4da2:	df 91       	pop	r29
    4da4:	cf 91       	pop	r28
    4da6:	1f 91       	pop	r17
    4da8:	0f 91       	pop	r16
    4daa:	ff 90       	pop	r15
    4dac:	ef 90       	pop	r14
    4dae:	df 90       	pop	r13
    4db0:	cf 90       	pop	r12
    4db2:	bf 90       	pop	r11
    4db4:	08 95       	ret

00004db6 <Endpoint_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4db6:	8f 92       	push	r8
    4db8:	9f 92       	push	r9
    4dba:	bf 92       	push	r11
    4dbc:	cf 92       	push	r12
    4dbe:	df 92       	push	r13
    4dc0:	ef 92       	push	r14
    4dc2:	ff 92       	push	r15
    4dc4:	0f 93       	push	r16
    4dc6:	1f 93       	push	r17
    4dc8:	df 93       	push	r29
    4dca:	cf 93       	push	r28
    4dcc:	0f 92       	push	r0
    4dce:	cd b7       	in	r28, 0x3d	; 61
    4dd0:	de b7       	in	r29, 0x3e	; 62
    4dd2:	e8 2e       	mov	r14, r24
    4dd4:	4b 01       	movw	r8, r22
    4dd6:	8a 01       	movw	r16, r20
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
    4dd8:	99 83       	std	Y+1, r25	; 0x01
    4dda:	da d1       	rcall	.+948    	; 0x5190 <Endpoint_WaitUntilReady>
    4ddc:	b8 2e       	mov	r11, r24
    4dde:	99 81       	ldd	r25, Y+1	; 0x01
    4de0:	88 23       	and	r24, r24
    4de2:	c1 f5       	brne	.+112    	; 0x4e54 <Endpoint_Read_Stream_LE+0x9e>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4de4:	f9 2e       	mov	r15, r25
	uint8_t  ErrorCode;

	if ((ErrorCode = Endpoint_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    4de6:	01 15       	cp	r16, r1
    4de8:	11 05       	cpc	r17, r1
    4dea:	39 f0       	breq	.+14     	; 0x4dfa <Endpoint_Read_Stream_LE+0x44>
	{
		Length -= *BytesProcessed;
    4dec:	f8 01       	movw	r30, r16
    4dee:	20 81       	ld	r18, Z
    4df0:	31 81       	ldd	r19, Z+1	; 0x01
    4df2:	82 1a       	sub	r8, r18
    4df4:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    4df6:	e2 0e       	add	r14, r18
    4df8:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    4dfa:	cc 24       	eor	r12, r12
    4dfc:	dd 24       	eor	r13, r13
    4dfe:	25 c0       	rjmp	.+74     	; 0x4e4a <Endpoint_Read_Stream_LE+0x94>
			 *          on its direction.
			 */
			static inline bool Endpoint_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsReadWriteAllowed(void)
			{
				return ((UEINTX & (1 << RWAL)) ? true : false);
    4e00:	80 91 e8 00 	lds	r24, 0x00E8
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Endpoint_IsReadWriteAllowed()))
    4e04:	85 fd       	sbrc	r24, 5
    4e06:	16 c0       	rjmp	.+44     	; 0x4e34 <Endpoint_Read_Stream_LE+0x7e>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4e08:	80 91 e8 00 	lds	r24, 0x00E8
    4e0c:	8b 77       	andi	r24, 0x7B	; 123
    4e0e:	80 93 e8 00 	sts	0x00E8, r24

			#if !defined(INTERRUPT_CONTROL_ENDPOINT)
			USB_USBTask();
			#endif

			if (BytesProcessed != NULL)
    4e12:	01 15       	cp	r16, r1
    4e14:	11 05       	cpc	r17, r1
    4e16:	51 f0       	breq	.+20     	; 0x4e2c <Endpoint_Read_Stream_LE+0x76>
			{
				*BytesProcessed += BytesInTransfer;
    4e18:	f8 01       	movw	r30, r16
    4e1a:	80 81       	ld	r24, Z
    4e1c:	91 81       	ldd	r25, Z+1	; 0x01
    4e1e:	8c 0d       	add	r24, r12
    4e20:	9d 1d       	adc	r25, r13
    4e22:	91 83       	std	Z+1, r25	; 0x01
    4e24:	80 83       	st	Z, r24
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
    4e26:	45 e0       	ldi	r20, 0x05	; 5
    4e28:	b4 2e       	mov	r11, r20
    4e2a:	14 c0       	rjmp	.+40     	; 0x4e54 <Endpoint_Read_Stream_LE+0x9e>
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4e2c:	b1 d1       	rcall	.+866    	; 0x5190 <Endpoint_WaitUntilReady>
    4e2e:	88 23       	and	r24, r24
    4e30:	61 f0       	breq	.+24     	; 0x4e4a <Endpoint_Read_Stream_LE+0x94>
    4e32:	0f c0       	rjmp	.+30     	; 0x4e52 <Endpoint_Read_Stream_LE+0x9c>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4e34:	80 91 f1 00 	lds	r24, 0x00F1
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    4e38:	f7 01       	movw	r30, r14
    4e3a:	81 93       	st	Z+, r24
    4e3c:	7f 01       	movw	r14, r30
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    4e3e:	08 94       	sec
    4e40:	81 08       	sbc	r8, r1
    4e42:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    4e44:	08 94       	sec
    4e46:	c1 1c       	adc	r12, r1
    4e48:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    4e4a:	81 14       	cp	r8, r1
    4e4c:	91 04       	cpc	r9, r1
    4e4e:	c1 f6       	brne	.-80     	; 0x4e00 <Endpoint_Read_Stream_LE+0x4a>
    4e50:	01 c0       	rjmp	.+2      	; 0x4e54 <Endpoint_Read_Stream_LE+0x9e>
			{
				*BytesProcessed += BytesInTransfer;
				return ENDPOINT_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Endpoint_WaitUntilReady()))
    4e52:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return ENDPOINT_RWSTREAM_NoError;
}
    4e54:	8b 2d       	mov	r24, r11
    4e56:	0f 90       	pop	r0
    4e58:	cf 91       	pop	r28
    4e5a:	df 91       	pop	r29
    4e5c:	1f 91       	pop	r17
    4e5e:	0f 91       	pop	r16
    4e60:	ff 90       	pop	r15
    4e62:	ef 90       	pop	r14
    4e64:	df 90       	pop	r13
    4e66:	cf 90       	pop	r12
    4e68:	bf 90       	pop	r11
    4e6a:	9f 90       	pop	r9
    4e6c:	8f 90       	pop	r8
    4e6e:	08 95       	ret

00004e70 <Endpoint_Write_Control_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4e70:	28 2f       	mov	r18, r24
    4e72:	39 2f       	mov	r19, r25
    4e74:	f9 01       	movw	r30, r18
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4e76:	80 91 b4 0d 	lds	r24, 0x0DB4
    4e7a:	90 91 b5 0d 	lds	r25, 0x0DB5
    4e7e:	86 17       	cp	r24, r22
    4e80:	97 07       	cpc	r25, r23
    4e82:	18 f4       	brcc	.+6      	; 0x4e8a <Endpoint_Write_Control_Stream_LE+0x1a>
    4e84:	bc 01       	movw	r22, r24
    4e86:	20 e0       	ldi	r18, 0x00	; 0
    4e88:	35 c0       	rjmp	.+106    	; 0x4ef4 <Endpoint_Write_Control_Stream_LE+0x84>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4e8a:	61 15       	cp	r22, r1
    4e8c:	71 05       	cpc	r23, r1
    4e8e:	d9 f7       	brne	.-10     	; 0x4e86 <Endpoint_Write_Control_Stream_LE+0x16>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4e90:	80 91 e8 00 	lds	r24, 0x00E8
    4e94:	8e 77       	andi	r24, 0x7E	; 126
    4e96:	80 93 e8 00 	sts	0x00E8, r24
    4e9a:	f5 cf       	rjmp	.-22     	; 0x4e86 <Endpoint_Write_Control_Stream_LE+0x16>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4e9c:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4e9e:	88 23       	and	r24, r24
    4ea0:	f1 f1       	breq	.+124    	; 0x4f1e <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4ea2:	85 30       	cpi	r24, 0x05	; 5
    4ea4:	c1 f1       	breq	.+112    	; 0x4f16 <Endpoint_Write_Control_Stream_LE+0xa6>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4ea6:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4eaa:	83 fd       	sbrc	r24, 3
    4eac:	36 c0       	rjmp	.+108    	; 0x4f1a <Endpoint_Write_Control_Stream_LE+0xaa>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4eae:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4eb2:	82 fd       	sbrc	r24, 2
    4eb4:	2a c0       	rjmp	.+84     	; 0x4f0a <Endpoint_Write_Control_Stream_LE+0x9a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4eb6:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    4eba:	80 ff       	sbrs	r24, 0
    4ebc:	1b c0       	rjmp	.+54     	; 0x4ef4 <Endpoint_Write_Control_Stream_LE+0x84>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4ebe:	80 91 f2 00 	lds	r24, 0x00F2
    4ec2:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4ec6:	06 c0       	rjmp	.+12     	; 0x4ed4 <Endpoint_Write_Control_Stream_LE+0x64>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4ec8:	21 91       	ld	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4eca:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    4ece:	61 50       	subi	r22, 0x01	; 1
    4ed0:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    4ed2:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4ed4:	61 15       	cp	r22, r1
    4ed6:	71 05       	cpc	r23, r1
    4ed8:	19 f0       	breq	.+6      	; 0x4ee0 <Endpoint_Write_Control_Stream_LE+0x70>
    4eda:	88 30       	cpi	r24, 0x08	; 8
    4edc:	91 05       	cpc	r25, r1
    4ede:	a0 f3       	brcs	.-24     	; 0x4ec8 <Endpoint_Write_Control_Stream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    4ee0:	21 e0       	ldi	r18, 0x01	; 1
    4ee2:	88 30       	cpi	r24, 0x08	; 8
    4ee4:	91 05       	cpc	r25, r1
    4ee6:	09 f0       	breq	.+2      	; 0x4eea <Endpoint_Write_Control_Stream_LE+0x7a>
    4ee8:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4eea:	80 91 e8 00 	lds	r24, 0x00E8
    4eee:	8e 77       	andi	r24, 0x7E	; 126
    4ef0:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    4ef4:	61 15       	cp	r22, r1
    4ef6:	71 05       	cpc	r23, r1
    4ef8:	89 f6       	brne	.-94     	; 0x4e9c <Endpoint_Write_Control_Stream_LE+0x2c>
    4efa:	22 23       	and	r18, r18
    4efc:	79 f6       	brne	.-98     	; 0x4e9c <Endpoint_Write_Control_Stream_LE+0x2c>
    4efe:	05 c0       	rjmp	.+10     	; 0x4f0a <Endpoint_Write_Control_Stream_LE+0x9a>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4f00:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4f02:	88 23       	and	r24, r24
    4f04:	61 f0       	breq	.+24     	; 0x4f1e <Endpoint_Write_Control_Stream_LE+0xae>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4f06:	85 30       	cpi	r24, 0x05	; 5
    4f08:	61 f0       	breq	.+24     	; 0x4f22 <Endpoint_Write_Control_Stream_LE+0xb2>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4f0a:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    4f0e:	82 ff       	sbrs	r24, 2
    4f10:	f7 cf       	rjmp	.-18     	; 0x4f00 <Endpoint_Write_Control_Stream_LE+0x90>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4f12:	80 e0       	ldi	r24, 0x00	; 0
    4f14:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4f16:	83 e0       	ldi	r24, 0x03	; 3
    4f18:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4f1a:	81 e0       	ldi	r24, 0x01	; 1
    4f1c:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4f1e:	82 e0       	ldi	r24, 0x02	; 2
    4f20:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4f22:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4f24:	08 95       	ret

00004f26 <Endpoint_Read_Control_Stream_LE>:
uint8_t TEMPLATE_FUNC_NAME (void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
    4f26:	61 15       	cp	r22, r1
    4f28:	71 05       	cpc	r23, r1
    4f2a:	29 f5       	brne	.+74     	; 0x4f76 <Endpoint_Read_Control_Stream_LE+0x50>
    4f2c:	1f c0       	rjmp	.+62     	; 0x4f6c <Endpoint_Read_Control_Stream_LE+0x46>
	  Endpoint_ClearOUT();

	while (Length)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4f2e:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4f30:	22 23       	and	r18, r18
    4f32:	a1 f1       	breq	.+104    	; 0x4f9c <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4f34:	25 30       	cpi	r18, 0x05	; 5
    4f36:	71 f1       	breq	.+92     	; 0x4f94 <Endpoint_Read_Control_Stream_LE+0x6e>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4f38:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4f3c:	23 fd       	sbrc	r18, 3
    4f3e:	2c c0       	rjmp	.+88     	; 0x4f98 <Endpoint_Read_Control_Stream_LE+0x72>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4f40:	20 91 e8 00 	lds	r18, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
    4f44:	22 ff       	sbrs	r18, 2
    4f46:	f3 cf       	rjmp	.-26     	; 0x4f2e <Endpoint_Read_Control_Stream_LE+0x8>
    4f48:	e8 2f       	mov	r30, r24
    4f4a:	f9 2f       	mov	r31, r25
    4f4c:	07 c0       	rjmp	.+14     	; 0x4f5c <Endpoint_Read_Control_Stream_LE+0x36>
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    4f4e:	80 91 f1 00 	lds	r24, 0x00F1
		{
			while (Length && Endpoint_BytesInEndpoint())
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4f52:	81 93       	st	Z+, r24
    4f54:	cf 01       	movw	r24, r30
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
    4f56:	61 50       	subi	r22, 0x01	; 1
    4f58:	70 40       	sbci	r23, 0x00	; 0
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;

		if (Endpoint_IsOUTReceived())
		{
			while (Length && Endpoint_BytesInEndpoint())
    4f5a:	41 f0       	breq	.+16     	; 0x4f6c <Endpoint_Read_Control_Stream_LE+0x46>
    4f5c:	cf 01       	movw	r24, r30
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4f5e:	20 91 f2 00 	lds	r18, 0x00F2
    4f62:	30 91 f3 00 	lds	r19, 0x00F3
    4f66:	21 15       	cp	r18, r1
    4f68:	31 05       	cpc	r19, r1
    4f6a:	89 f7       	brne	.-30     	; 0x4f4e <Endpoint_Read_Control_Stream_LE+0x28>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    4f6c:	20 91 e8 00 	lds	r18, 0x00E8
    4f70:	2b 77       	andi	r18, 0x7B	; 123
    4f72:	20 93 e8 00 	sts	0x00E8, r18
	uint8_t* DataStream = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));

	if (!(Length))
	  Endpoint_ClearOUT();

	while (Length)
    4f76:	61 15       	cp	r22, r1
    4f78:	71 05       	cpc	r23, r1
    4f7a:	c9 f6       	brne	.-78     	; 0x4f2e <Endpoint_Read_Control_Stream_LE+0x8>
    4f7c:	05 c0       	rjmp	.+10     	; 0x4f88 <Endpoint_Read_Control_Stream_LE+0x62>
		}
	}

	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4f7e:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4f80:	88 23       	and	r24, r24
    4f82:	61 f0       	breq	.+24     	; 0x4f9c <Endpoint_Read_Control_Stream_LE+0x76>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4f84:	85 30       	cpi	r24, 0x05	; 5
    4f86:	61 f0       	breq	.+24     	; 0x4fa0 <Endpoint_Read_Control_Stream_LE+0x7a>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4f88:	80 91 e8 00 	lds	r24, 0x00E8

			Endpoint_ClearOUT();
		}
	}

	while (!(Endpoint_IsINReady()))
    4f8c:	80 ff       	sbrs	r24, 0
    4f8e:	f7 cf       	rjmp	.-18     	; 0x4f7e <Endpoint_Read_Control_Stream_LE+0x58>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    4f90:	80 e0       	ldi	r24, 0x00	; 0
    4f92:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4f94:	83 e0       	ldi	r24, 0x03	; 3
    4f96:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    4f98:	81 e0       	ldi	r24, 0x01	; 1
    4f9a:	08 95       	ret
	while (!(Endpoint_IsINReady()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    4f9c:	82 e0       	ldi	r24, 0x02	; 2
    4f9e:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    4fa0:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    4fa2:	08 95       	ret

00004fa4 <Endpoint_Write_Control_PStream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (const void* const Buffer,
                            uint16_t Length)
{
	uint8_t* DataStream     = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    4fa4:	e8 2f       	mov	r30, r24
    4fa6:	f9 2f       	mov	r31, r25
	bool     LastPacketFull = false;

	if (Length > USB_ControlRequest.wLength)
    4fa8:	80 91 b4 0d 	lds	r24, 0x0DB4
    4fac:	90 91 b5 0d 	lds	r25, 0x0DB5
    4fb0:	86 17       	cp	r24, r22
    4fb2:	97 07       	cpc	r25, r23
    4fb4:	18 f4       	brcc	.+6      	; 0x4fbc <Endpoint_Write_Control_PStream_LE+0x18>
    4fb6:	bc 01       	movw	r22, r24
    4fb8:	20 e0       	ldi	r18, 0x00	; 0
    4fba:	37 c0       	rjmp	.+110    	; 0x502a <Endpoint_Write_Control_PStream_LE+0x86>
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
    4fbc:	61 15       	cp	r22, r1
    4fbe:	71 05       	cpc	r23, r1
    4fc0:	d9 f7       	brne	.-10     	; 0x4fb8 <Endpoint_Write_Control_PStream_LE+0x14>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    4fc2:	80 91 e8 00 	lds	r24, 0x00E8
    4fc6:	8e 77       	andi	r24, 0x7E	; 126
    4fc8:	80 93 e8 00 	sts	0x00E8, r24
    4fcc:	f5 cf       	rjmp	.-22     	; 0x4fb8 <Endpoint_Write_Control_PStream_LE+0x14>
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    4fce:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    4fd0:	88 23       	and	r24, r24
    4fd2:	09 f4       	brne	.+2      	; 0x4fd6 <Endpoint_Write_Control_PStream_LE+0x32>
    4fd4:	3f c0       	rjmp	.+126    	; 0x5054 <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    4fd6:	85 30       	cpi	r24, 0x05	; 5
    4fd8:	c9 f1       	breq	.+114    	; 0x504c <Endpoint_Write_Control_PStream_LE+0xa8>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    4fda:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_BusSuspended;
		else if (Endpoint_IsSETUPReceived())
    4fde:	83 fd       	sbrc	r24, 3
    4fe0:	37 c0       	rjmp	.+110    	; 0x5050 <Endpoint_Write_Control_PStream_LE+0xac>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    4fe2:	80 91 e8 00 	lds	r24, 0x00E8
		  return ENDPOINT_RWCSTREAM_HostAborted;
		else if (Endpoint_IsOUTReceived())
    4fe6:	82 fd       	sbrc	r24, 2
    4fe8:	2b c0       	rjmp	.+86     	; 0x5040 <Endpoint_Write_Control_PStream_LE+0x9c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    4fea:	80 91 e8 00 	lds	r24, 0x00E8
		  break;

		if (Endpoint_IsINReady())
    4fee:	80 ff       	sbrs	r24, 0
    4ff0:	1c c0       	rjmp	.+56     	; 0x502a <Endpoint_Write_Control_PStream_LE+0x86>
			 */
			static inline uint16_t Endpoint_BytesInEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Endpoint_BytesInEndpoint(void)
			{
				#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					return UEBCX;
    4ff2:	80 91 f2 00 	lds	r24, 0x00F2
    4ff6:	90 91 f3 00 	lds	r25, 0x00F3
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    4ffa:	07 c0       	rjmp	.+14     	; 0x500a <Endpoint_Write_Control_PStream_LE+0x66>
			{
				TEMPLATE_TRANSFER_BYTE(DataStream);
    4ffc:	24 91       	lpm	r18, Z+
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    4ffe:	20 93 f1 00 	sts	0x00F1, r18
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
    5002:	31 96       	adiw	r30, 0x01	; 1
				Length--;
    5004:	61 50       	subi	r22, 0x01	; 1
    5006:	70 40       	sbci	r23, 0x00	; 0
				BytesInEndpoint++;
    5008:	01 96       	adiw	r24, 0x01	; 1

		if (Endpoint_IsINReady())
		{
			uint16_t BytesInEndpoint = Endpoint_BytesInEndpoint();

			while (Length && (BytesInEndpoint < USB_Device_ControlEndpointSize))
    500a:	61 15       	cp	r22, r1
    500c:	71 05       	cpc	r23, r1
    500e:	19 f0       	breq	.+6      	; 0x5016 <Endpoint_Write_Control_PStream_LE+0x72>
    5010:	88 30       	cpi	r24, 0x08	; 8
    5012:	91 05       	cpc	r25, r1
    5014:	98 f3       	brcs	.-26     	; 0x4ffc <Endpoint_Write_Control_PStream_LE+0x58>
				TEMPLATE_BUFFER_MOVE(DataStream, 1);
				Length--;
				BytesInEndpoint++;
			}

			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
    5016:	21 e0       	ldi	r18, 0x01	; 1
    5018:	88 30       	cpi	r24, 0x08	; 8
    501a:	91 05       	cpc	r25, r1
    501c:	09 f0       	breq	.+2      	; 0x5020 <Endpoint_Write_Control_PStream_LE+0x7c>
    501e:	20 e0       	ldi	r18, 0x00	; 0
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5020:	80 91 e8 00 	lds	r24, 0x00E8
    5024:	8e 77       	andi	r24, 0x7E	; 126
    5026:	80 93 e8 00 	sts	0x00E8, r24
	if (Length > USB_ControlRequest.wLength)
	  Length = USB_ControlRequest.wLength;
	else if (!(Length))
	  Endpoint_ClearIN();

	while (Length || LastPacketFull)
    502a:	61 15       	cp	r22, r1
    502c:	71 05       	cpc	r23, r1
    502e:	79 f6       	brne	.-98     	; 0x4fce <Endpoint_Write_Control_PStream_LE+0x2a>
    5030:	22 23       	and	r18, r18
    5032:	69 f6       	brne	.-102    	; 0x4fce <Endpoint_Write_Control_PStream_LE+0x2a>
    5034:	05 c0       	rjmp	.+10     	; 0x5040 <Endpoint_Write_Control_PStream_LE+0x9c>
		}
	}

	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    5036:	8e b3       	in	r24, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    5038:	88 23       	and	r24, r24
    503a:	61 f0       	breq	.+24     	; 0x5054 <Endpoint_Write_Control_PStream_LE+0xb0>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    503c:	85 30       	cpi	r24, 0x05	; 5
    503e:	61 f0       	breq	.+24     	; 0x5058 <Endpoint_Write_Control_PStream_LE+0xb4>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5040:	80 91 e8 00 	lds	r24, 0x00E8
			LastPacketFull = (BytesInEndpoint == USB_Device_ControlEndpointSize);
			Endpoint_ClearIN();
		}
	}

	while (!(Endpoint_IsOUTReceived()))
    5044:	82 ff       	sbrs	r24, 2
    5046:	f7 cf       	rjmp	.-18     	; 0x5036 <Endpoint_Write_Control_PStream_LE+0x92>
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
	}

	return ENDPOINT_RWCSTREAM_NoError;
    5048:	80 e0       	ldi	r24, 0x00	; 0
    504a:	08 95       	ret
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    504c:	83 e0       	ldi	r24, 0x03	; 3
    504e:	08 95       	ret
		else if (Endpoint_IsSETUPReceived())
		  return ENDPOINT_RWCSTREAM_HostAborted;
    5050:	81 e0       	ldi	r24, 0x01	; 1
    5052:	08 95       	ret
	while (!(Endpoint_IsOUTReceived()))
	{
		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_RWCSTREAM_DeviceDisconnected;
    5054:	82 e0       	ldi	r24, 0x02	; 2
    5056:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_RWCSTREAM_BusSuspended;
    5058:	83 e0       	ldi	r24, 0x03	; 3
	}

	return ENDPOINT_RWCSTREAM_NoError;
}
    505a:	08 95       	ret

0000505c <Endpoint_ConfigureEndpoint_Prv>:
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    505c:	98 2f       	mov	r25, r24
    505e:	2c c0       	rjmp	.+88     	; 0x50b8 <Endpoint_ConfigureEndpoint_Prv+0x5c>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5060:	29 2f       	mov	r18, r25
    5062:	2f 70       	andi	r18, 0x0F	; 15
    5064:	20 93 e9 00 	sts	0x00E9, r18
		uint8_t UECFG1XTemp;
		uint8_t UEIENXTemp;

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
    5068:	98 17       	cp	r25, r24
    506a:	39 f0       	breq	.+14     	; 0x507a <Endpoint_ConfigureEndpoint_Prv+0x1e>
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
		}
		else
		{
			UECFG0XTemp = UECFG0X;
    506c:	70 91 ec 00 	lds	r23, 0x00EC
			UECFG1XTemp = UECFG1X;
    5070:	20 91 ed 00 	lds	r18, 0x00ED
			UEIENXTemp  = UEIENX;
    5074:	50 91 f0 00 	lds	r21, 0x00F0
    5078:	03 c0       	rjmp	.+6      	; 0x5080 <Endpoint_ConfigureEndpoint_Prv+0x24>
		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
			UECFG1XTemp = UECFG1XData;
    507a:	24 2f       	mov	r18, r20

		Endpoint_SelectEndpoint(EPNum);

		if (EPNum == Number)
		{
			UECFG0XTemp = UECFG0XData;
    507c:	76 2f       	mov	r23, r22
			UECFG1XTemp = UECFG1XData;
			UEIENXTemp  = 0;
    507e:	50 e0       	ldi	r21, 0x00	; 0
			UECFG0XTemp = UECFG0X;
			UECFG1XTemp = UECFG1X;
			UEIENXTemp  = UEIENX;
		}

		if (!(UECFG1XTemp & (1 << ALLOC)))
    5080:	21 ff       	sbrs	r18, 1
    5082:	19 c0       	rjmp	.+50     	; 0x50b6 <Endpoint_ConfigureEndpoint_Prv+0x5a>
			 *  to and from a host.
			 */
			static inline void Endpoint_DisableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_DisableEndpoint(void)
			{
				UECONX &= ~(1 << EPEN);
    5084:	30 91 eb 00 	lds	r19, 0x00EB
    5088:	3e 7f       	andi	r19, 0xFE	; 254
    508a:	30 93 eb 00 	sts	0x00EB, r19
		  continue;

		Endpoint_DisableEndpoint();
		UECFG1X &= ~(1 << ALLOC);
    508e:	30 91 ed 00 	lds	r19, 0x00ED
    5092:	3d 7f       	andi	r19, 0xFD	; 253
    5094:	30 93 ed 00 	sts	0x00ED, r19
			 *  \note Endpoints must first be configured properly via \ref Endpoint_ConfigureEndpoint().
			 */
			static inline void Endpoint_EnableEndpoint(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_EnableEndpoint(void)
			{
				UECONX |= (1 << EPEN);
    5098:	30 91 eb 00 	lds	r19, 0x00EB
    509c:	31 60       	ori	r19, 0x01	; 1
    509e:	30 93 eb 00 	sts	0x00EB, r19

		Endpoint_EnableEndpoint();
		UECFG0X = UECFG0XTemp;
    50a2:	70 93 ec 00 	sts	0x00EC, r23
		UECFG1X = UECFG1XTemp;
    50a6:	20 93 ed 00 	sts	0x00ED, r18
		UEIENX  = UEIENXTemp;
    50aa:	50 93 f0 00 	sts	0x00F0, r21
			 *  \return Boolean \c true if the currently selected endpoint has been configured, \c false otherwise.
			 */
			static inline bool Endpoint_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsConfigured(void)
			{
				return ((UESTA0X & (1 << CFGOK)) ? true : false);
    50ae:	20 91 ee 00 	lds	r18, 0x00EE

		if (!(Endpoint_IsConfigured()))
    50b2:	27 ff       	sbrs	r18, 7
    50b4:	08 c0       	rjmp	.+16     	; 0x50c6 <Endpoint_ConfigureEndpoint_Prv+0x6a>
	UECFG0X = UECFG0XData;
	UECFG1X = UECFG1XData;

	return Endpoint_IsConfigured();
#else
	for (uint8_t EPNum = Number; EPNum < ENDPOINT_TOTAL_ENDPOINTS; EPNum++)
    50b6:	9f 5f       	subi	r25, 0xFF	; 255
    50b8:	97 30       	cpi	r25, 0x07	; 7
    50ba:	90 f2       	brcs	.-92     	; 0x5060 <Endpoint_ConfigureEndpoint_Prv+0x4>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    50bc:	8f 70       	andi	r24, 0x0F	; 15
    50be:	80 93 e9 00 	sts	0x00E9, r24
		if (!(Endpoint_IsConfigured()))
		  return false;
	}

	Endpoint_SelectEndpoint(Number);
	return true;
    50c2:	81 e0       	ldi	r24, 0x01	; 1
    50c4:	08 95       	ret
		UECFG0X = UECFG0XTemp;
		UECFG1X = UECFG1XTemp;
		UEIENX  = UEIENXTemp;

		if (!(Endpoint_IsConfigured()))
		  return false;
    50c6:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(Number);
	return true;
#endif
}
    50c8:	08 95       	ret

000050ca <Endpoint_ConfigureEndpointTable>:
uint8_t USB_Device_ControlEndpointSize = ENDPOINT_CONTROLEP_DEFAULT_SIZE;
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
    50ca:	ef 92       	push	r14
    50cc:	ff 92       	push	r15
    50ce:	0f 93       	push	r16
    50d0:	1f 93       	push	r17
    50d2:	cf 93       	push	r28
    50d4:	df 93       	push	r29
    50d6:	16 2f       	mov	r17, r22
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    50d8:	e8 2e       	mov	r14, r24
    50da:	e7 01       	movw	r28, r14
    50dc:	7e 01       	movw	r14, r28
    50de:	f9 2e       	mov	r15, r25
    50e0:	e7 01       	movw	r28, r14
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    50e2:	00 e0       	ldi	r16, 0x00	; 0
    50e4:	2a c0       	rjmp	.+84     	; 0x513a <Endpoint_ConfigureEndpointTable+0x70>
	{
		if (!(Table[i].Address))
    50e6:	98 81       	ld	r25, Y
    50e8:	99 23       	and	r25, r25
    50ea:	29 f1       	breq	.+74     	; 0x5136 <Endpoint_ConfigureEndpointTable+0x6c>
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
    50ec:	6b 81       	ldd	r22, Y+3	; 0x03
    50ee:	e9 81       	ldd	r30, Y+1	; 0x01
    50f0:	fa 81       	ldd	r31, Y+2	; 0x02
    50f2:	2c 81       	ldd	r18, Y+4	; 0x04
			static inline bool Endpoint_ConfigureEndpoint(const uint8_t Address,
			                                              const uint8_t Type,
			                                              const uint16_t Size,
			                                              const uint8_t Banks)
			{
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);
    50f4:	89 2f       	mov	r24, r25
    50f6:	8f 70       	andi	r24, 0x0F	; 15

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
    50f8:	87 30       	cpi	r24, 0x07	; 7
    50fa:	18 f5       	brcc	.+70     	; 0x5142 <Endpoint_ConfigureEndpointTable+0x78>
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
				                                      ((Type << EPTYPE0) | ((Address & ENDPOINT_DIR_IN) ? (1 << EPDIR) : 0)),
    50fc:	62 95       	swap	r22
    50fe:	66 0f       	add	r22, r22
    5100:	66 0f       	add	r22, r22
    5102:	60 7c       	andi	r22, 0xC0	; 192
    5104:	99 1f       	adc	r25, r25
    5106:	99 27       	eor	r25, r25
    5108:	99 1f       	adc	r25, r25
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    510a:	69 2b       	or	r22, r25
    510c:	22 30       	cpi	r18, 0x02	; 2
    510e:	10 f0       	brcs	.+4      	; 0x5114 <Endpoint_ConfigureEndpointTable+0x4a>
    5110:	96 e0       	ldi	r25, 0x06	; 6
    5112:	01 c0       	rjmp	.+2      	; 0x5116 <Endpoint_ConfigureEndpointTable+0x4c>
    5114:	92 e0       	ldi	r25, 0x02	; 2
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;
    5116:	28 e0       	ldi	r18, 0x08	; 8
    5118:	30 e0       	ldi	r19, 0x00	; 0
		/* Inline Functions: */
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes) ATTR_WARN_UNUSED_RESULT ATTR_CONST
			                                                                       ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
    511a:	40 e0       	ldi	r20, 0x00	; 0
    511c:	03 c0       	rjmp	.+6      	; 0x5124 <Endpoint_ConfigureEndpointTable+0x5a>
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
				{
					MaskVal++;
    511e:	4f 5f       	subi	r20, 0xFF	; 255
					CheckBytes <<= 1;
    5120:	22 0f       	add	r18, r18
    5122:	33 1f       	adc	r19, r19
			static inline uint8_t Endpoint_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while (CheckBytes < Bytes)
    5124:	2e 17       	cp	r18, r30
    5126:	3f 07       	cpc	r19, r31
    5128:	d0 f3       	brcs	.-12     	; 0x511e <Endpoint_ConfigureEndpointTable+0x54>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    512a:	42 95       	swap	r20
    512c:	40 7f       	andi	r20, 0xF0	; 240
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    512e:	49 2b       	or	r20, r25
    5130:	95 df       	rcall	.-214    	; 0x505c <Endpoint_ConfigureEndpoint_Prv>
    5132:	88 23       	and	r24, r24
    5134:	31 f0       	breq	.+12     	; 0x5142 <Endpoint_ConfigureEndpointTable+0x78>
#endif

bool Endpoint_ConfigureEndpointTable(const USB_Endpoint_Table_t* const Table,
                                     const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    5136:	0f 5f       	subi	r16, 0xFF	; 255
    5138:	25 96       	adiw	r28, 0x05	; 5
    513a:	01 17       	cp	r16, r17
    513c:	a0 f2       	brcs	.-88     	; 0x50e6 <Endpoint_ConfigureEndpointTable+0x1c>
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
	}
	
	return true;
    513e:	81 e0       	ldi	r24, 0x01	; 1
    5140:	01 c0       	rjmp	.+2      	; 0x5144 <Endpoint_ConfigureEndpointTable+0x7a>
	{
		if (!(Table[i].Address))
		  continue;
	
		if (!(Endpoint_ConfigureEndpoint(Table[i].Address, Table[i].Type, Table[i].Size, Table[i].Banks)))
		  return false;
    5142:	80 e0       	ldi	r24, 0x00	; 0
	}
	
	return true;
}
    5144:	df 91       	pop	r29
    5146:	cf 91       	pop	r28
    5148:	1f 91       	pop	r17
    514a:	0f 91       	pop	r16
    514c:	ff 90       	pop	r15
    514e:	ef 90       	pop	r14
    5150:	08 95       	ret

00005152 <Endpoint_ClearStatusStage>:
	}
}

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
    5152:	80 91 ae 0d 	lds	r24, 0x0DAE
    5156:	87 ff       	sbrs	r24, 7
    5158:	11 c0       	rjmp	.+34     	; 0x517c <Endpoint_ClearStatusStage+0x2a>
    515a:	03 c0       	rjmp	.+6      	; 0x5162 <Endpoint_ClearStatusStage+0x10>
	{
		while (!(Endpoint_IsOUTReceived()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    515c:	8e b3       	in	r24, 0x1e	; 30
    515e:	88 23       	and	r24, r24
    5160:	b1 f0       	breq	.+44     	; 0x518e <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    5162:	80 91 e8 00 	lds	r24, 0x00E8

void Endpoint_ClearStatusStage(void)
{
	if (USB_ControlRequest.bmRequestType & REQDIR_DEVICETOHOST)
	{
		while (!(Endpoint_IsOUTReceived()))
    5166:	82 ff       	sbrs	r24, 2
    5168:	f9 cf       	rjmp	.-14     	; 0x515c <Endpoint_ClearStatusStage+0xa>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    516a:	80 91 e8 00 	lds	r24, 0x00E8
    516e:	8b 77       	andi	r24, 0x7B	; 123
    5170:	80 93 e8 00 	sts	0x00E8, r24
    5174:	08 95       	ret
	}
	else
	{
		while (!(Endpoint_IsINReady()))
		{
			if (USB_DeviceState == DEVICE_STATE_Unattached)
    5176:	8e b3       	in	r24, 0x1e	; 30
    5178:	88 23       	and	r24, r24
    517a:	49 f0       	breq	.+18     	; 0x518e <Endpoint_ClearStatusStage+0x3c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    517c:	80 91 e8 00 	lds	r24, 0x00E8

		Endpoint_ClearOUT();
	}
	else
	{
		while (!(Endpoint_IsINReady()))
    5180:	80 ff       	sbrs	r24, 0
    5182:	f9 cf       	rjmp	.-14     	; 0x5176 <Endpoint_ClearStatusStage+0x24>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    5184:	80 91 e8 00 	lds	r24, 0x00E8
    5188:	8e 77       	andi	r24, 0x7E	; 126
    518a:	80 93 e8 00 	sts	0x00E8, r24
    518e:	08 95       	ret

00005190 <Endpoint_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Device_GetFrameNumber(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline uint16_t USB_Device_GetFrameNumber(void)
			{
				return UDFNUM;
    5190:	80 91 e4 00 	lds	r24, 0x00E4
    5194:	90 91 e5 00 	lds	r25, 0x00E5

#if !defined(CONTROL_ONLY_DEVICE)
uint8_t Endpoint_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    5198:	44 e6       	ldi	r20, 0x64	; 100
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    519a:	20 91 ec 00 	lds	r18, 0x00EC
    519e:	20 ff       	sbrs	r18, 0
    51a0:	25 c0       	rjmp	.+74     	; 0x51ec <Endpoint_WaitUntilReady+0x5c>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    51a2:	20 91 e8 00 	lds	r18, 0x00E8

	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
    51a6:	20 fd       	sbrc	r18, 0
    51a8:	15 c0       	rjmp	.+42     	; 0x51d4 <Endpoint_WaitUntilReady+0x44>
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;
    51aa:	2e b3       	in	r18, 0x1e	; 30

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
    51ac:	22 23       	and	r18, r18
    51ae:	a1 f0       	breq	.+40     	; 0x51d8 <Endpoint_WaitUntilReady+0x48>
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
    51b0:	25 30       	cpi	r18, 0x05	; 5
    51b2:	a1 f0       	breq	.+40     	; 0x51dc <Endpoint_WaitUntilReady+0x4c>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    51b4:	20 91 eb 00 	lds	r18, 0x00EB
		  return ENDPOINT_READYWAIT_BusSuspended;
		else if (Endpoint_IsStalled())
    51b8:	25 fd       	sbrc	r18, 5
    51ba:	12 c0       	rjmp	.+36     	; 0x51e0 <Endpoint_WaitUntilReady+0x50>
    51bc:	20 91 e4 00 	lds	r18, 0x00E4
    51c0:	30 91 e5 00 	lds	r19, 0x00E5
		  return ENDPOINT_READYWAIT_EndpointStalled;

		uint16_t CurrentFrameNumber = USB_Device_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    51c4:	28 17       	cp	r18, r24
    51c6:	39 07       	cpc	r19, r25
    51c8:	41 f3       	breq	.-48     	; 0x519a <Endpoint_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    51ca:	44 23       	and	r20, r20
    51cc:	59 f0       	breq	.+22     	; 0x51e4 <Endpoint_WaitUntilReady+0x54>
    51ce:	41 50       	subi	r20, 0x01	; 1
    51d0:	c9 01       	movw	r24, r18
    51d2:	e3 cf       	rjmp	.-58     	; 0x519a <Endpoint_WaitUntilReady+0xa>
	for (;;)
	{
		if (Endpoint_GetEndpointDirection() == ENDPOINT_DIR_IN)
		{
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
    51d4:	80 e0       	ldi	r24, 0x00	; 0
    51d6:	08 95       	ret
		}

		uint8_t USB_DeviceState_LCL = USB_DeviceState;

		if (USB_DeviceState_LCL == DEVICE_STATE_Unattached)
		  return ENDPOINT_READYWAIT_DeviceDisconnected;
    51d8:	82 e0       	ldi	r24, 0x02	; 2
    51da:	08 95       	ret
		else if (USB_DeviceState_LCL == DEVICE_STATE_Suspended)
		  return ENDPOINT_READYWAIT_BusSuspended;
    51dc:	83 e0       	ldi	r24, 0x03	; 3
    51de:	08 95       	ret
		else if (Endpoint_IsStalled())
		  return ENDPOINT_READYWAIT_EndpointStalled;
    51e0:	81 e0       	ldi	r24, 0x01	; 1
    51e2:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
    51e4:	84 e0       	ldi	r24, 0x04	; 4
    51e6:	08 95       	ret
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
			  return ENDPOINT_READYWAIT_NoError;
    51e8:	80 e0       	ldi	r24, 0x00	; 0

			if (!(TimeoutMSRem--))
			  return ENDPOINT_READYWAIT_Timeout;
		}
	}
}
    51ea:	08 95       	ret
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    51ec:	20 91 e8 00 	lds	r18, 0x00E8
			if (Endpoint_IsINReady())
			  return ENDPOINT_READYWAIT_NoError;
		}
		else
		{
			if (Endpoint_IsOUTReceived())
    51f0:	22 ff       	sbrs	r18, 2
    51f2:	db cf       	rjmp	.-74     	; 0x51aa <Endpoint_WaitUntilReady+0x1a>
    51f4:	f9 cf       	rjmp	.-14     	; 0x51e8 <Endpoint_WaitUntilReady+0x58>

000051f6 <USB_Host_ResetDevice>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    51f6:	80 91 9e 00 	lds	r24, 0x009E
    51fa:	90 e0       	ldi	r25, 0x00	; 0
    51fc:	81 70       	andi	r24, 0x01	; 1
    51fe:	90 70       	andi	r25, 0x00	; 0
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    5200:	20 91 a0 00 	lds	r18, 0x00A0
    5204:	2d 7f       	andi	r18, 0xFD	; 253
    5206:	20 93 a0 00 	sts	0x00A0, r18
			 *  woken up automatically and the bus resumed after the reset has been correctly issued.
			 */
			static inline void USB_Host_ResetBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResetBus(void)
			{
				UHCON |=  (1 << RESET);
    520a:	20 91 9e 00 	lds	r18, 0x009E
    520e:	22 60       	ori	r18, 0x02	; 2
    5210:	20 93 9e 00 	sts	0x009E, r18
			 *  \return Boolean \c true if no bus reset is currently being sent, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusResetComplete(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusResetComplete(void)
			{
				return ((UHCON & (1 << RESET)) ? false : true);
    5214:	20 91 9e 00 	lds	r18, 0x009E
	bool BusSuspended = USB_Host_IsBusSuspended();

	USB_INT_Disable(USB_INT_DDISCI);

	USB_Host_ResetBus();
	while (!(USB_Host_IsBusResetComplete()));
    5218:	21 fd       	sbrc	r18, 1
    521a:	fc cf       	rjmp	.-8      	; 0x5214 <USB_Host_ResetDevice+0x1e>
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    521c:	20 91 9e 00 	lds	r18, 0x009E
    5220:	21 60       	ori	r18, 0x01	; 1
    5222:	20 93 9e 00 	sts	0x009E, r18
	USB_Host_ResumeBus();

	USB_Host_ConfigurationNumber = 0;
    5226:	10 92 ac 0d 	sts	0x0DAC, r1
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    522a:	20 91 a0 00 	lds	r18, 0x00A0
    522e:	30 e0       	ldi	r19, 0x00	; 0
    5230:	20 72       	andi	r18, 0x20	; 32
    5232:	30 70       	andi	r19, 0x00	; 0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    5234:	40 91 a0 00 	lds	r20, 0x00A0
    5238:	4f 7d       	andi	r20, 0xDF	; 223
    523a:	40 93 a0 00 	sts	0x00A0, r20
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    523e:	40 91 9f 00 	lds	r20, 0x009F
    5242:	4f 7d       	andi	r20, 0xDF	; 223
    5244:	40 93 9f 00 	sts	0x009F, r20
    5248:	4a e0       	ldi	r20, 0x0A	; 10
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    524a:	50 91 9f 00 	lds	r21, 0x009F
		/* Workaround for powerless-pull-up devices. After a USB bus reset,
		   all disconnection interrupts are suppressed while a USB frame is
		   looked for - if it is found within 10ms, the device is still
		   present.                                                        */

		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    524e:	55 ff       	sbrs	r21, 5
    5250:	0b c0       	rjmp	.+22     	; 0x5268 <USB_Host_ResetDevice+0x72>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5252:	40 91 9f 00 	lds	r20, 0x009F
    5256:	4f 7d       	andi	r20, 0xDF	; 223
    5258:	40 93 9f 00 	sts	0x009F, r20
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    525c:	40 91 9f 00 	lds	r20, 0x009F
    5260:	4d 7f       	andi	r20, 0xFD	; 253
    5262:	40 93 9f 00 	sts	0x009F, r20
    5266:	08 c0       	rjmp	.+16     	; 0x5278 <USB_Host_ResetDevice+0x82>
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
    5268:	ef ec       	ldi	r30, 0xCF	; 207
    526a:	f7 e0       	ldi	r31, 0x07	; 7
    526c:	31 97       	sbiw	r30, 0x01	; 1
    526e:	f1 f7       	brne	.-4      	; 0x526c <USB_Host_ResetDevice+0x76>
    5270:	00 c0       	rjmp	.+0      	; 0x5272 <USB_Host_ResetDevice+0x7c>
    5272:	00 00       	nop
    5274:	41 50       	subi	r20, 0x01	; 1
	bool HSOFIEnabled = USB_INT_IsEnabled(USB_INT_HSOFI);

	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	for (uint8_t MSRem = 10; MSRem != 0; MSRem--)
    5276:	49 f7       	brne	.-46     	; 0x524a <USB_Host_ResetDevice+0x54>
		}

		Delay_MS(1);
	}

	if (HSOFIEnabled)
    5278:	21 15       	cp	r18, r1
    527a:	31 05       	cpc	r19, r1
    527c:	29 f0       	breq	.+10     	; 0x5288 <USB_Host_ResetDevice+0x92>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    527e:	20 91 a0 00 	lds	r18, 0x00A0
    5282:	20 62       	ori	r18, 0x20	; 32
    5284:	20 93 a0 00 	sts	0x00A0, r18
	  USB_INT_Enable(USB_INT_HSOFI);

	if (BusSuspended)
    5288:	00 97       	sbiw	r24, 0x00	; 0
    528a:	29 f4       	brne	.+10     	; 0x5296 <USB_Host_ResetDevice+0xa0>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    528c:	80 91 9e 00 	lds	r24, 0x009E
    5290:	8e 7f       	andi	r24, 0xFE	; 254
    5292:	80 93 9e 00 	sts	0x009E, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    5296:	80 91 a0 00 	lds	r24, 0x00A0
    529a:	82 60       	ori	r24, 0x02	; 2
    529c:	80 93 a0 00 	sts	0x00A0, r24
	  USB_Host_SuspendBus();

	USB_INT_Enable(USB_INT_DDISCI);
}
    52a0:	08 95       	ret

000052a2 <USB_Host_WaitMS>:
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    52a2:	40 91 9e 00 	lds	r20, 0x009E
    52a6:	50 e0       	ldi	r21, 0x00	; 0
    52a8:	41 70       	andi	r20, 0x01	; 1
    52aa:	50 70       	andi	r21, 0x00	; 0
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    52ac:	20 91 a0 00 	lds	r18, 0x00A0
    52b0:	30 e0       	ldi	r19, 0x00	; 0
    52b2:	20 72       	andi	r18, 0x20	; 32
    52b4:	30 70       	andi	r19, 0x00	; 0
						UEIENX &= ~(1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  &= ~(1 << HSOFE);
    52b6:	90 91 a0 00 	lds	r25, 0x00A0
    52ba:	9f 7d       	andi	r25, 0xDF	; 223
    52bc:	90 93 a0 00 	sts	0x00A0, r25
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    52c0:	90 91 9f 00 	lds	r25, 0x009F
    52c4:	9f 7d       	andi	r25, 0xDF	; 223
    52c6:	90 93 9f 00 	sts	0x009F, r25
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    52ca:	90 91 9e 00 	lds	r25, 0x009E
    52ce:	91 60       	ori	r25, 0x01	; 1
    52d0:	90 93 9e 00 	sts	0x009E, r25
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    52d4:	29 c0       	rjmp	.+82     	; 0x5328 <USB_Host_WaitMS+0x86>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    52d6:	90 91 9f 00 	lds	r25, 0x009F
	{
		if (USB_INT_HasOccurred(USB_INT_HSOFI))
    52da:	95 ff       	sbrs	r25, 5
    52dc:	06 c0       	rjmp	.+12     	; 0x52ea <USB_Host_WaitMS+0x48>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    52de:	90 91 9f 00 	lds	r25, 0x009F
    52e2:	9f 7d       	andi	r25, 0xDF	; 223
    52e4:	90 93 9f 00 	sts	0x009F, r25
		{
			USB_INT_Clear(USB_INT_HSOFI);
			MS--;
    52e8:	81 50       	subi	r24, 0x01	; 1
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
    52ea:	9e b3       	in	r25, 0x1e	; 30
    52ec:	91 30       	cpi	r25, 0x01	; 1
    52ee:	f9 f0       	breq	.+62     	; 0x532e <USB_Host_WaitMS+0x8c>
    52f0:	90 91 d9 03 	lds	r25, 0x03D9
    52f4:	92 30       	cpi	r25, 0x02	; 2
    52f6:	d9 f4       	brne	.+54     	; 0x532e <USB_Host_WaitMS+0x8c>
			 *  \return Boolean \c true if an error has occurred on the selected pipe, \c false otherwise.
			 */
			static inline bool Pipe_IsError(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsError(void)
			{
				return ((UPINTX & (1 << PERRI)) ? true : false);
    52f8:	90 91 a6 00 	lds	r25, 0x00A6
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;

			break;
		}

		if (Pipe_IsError())
    52fc:	94 ff       	sbrs	r25, 4
    52fe:	09 c0       	rjmp	.+18     	; 0x5312 <USB_Host_WaitMS+0x70>

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    5300:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    5304:	80 91 a6 00 	lds	r24, 0x00A6
    5308:	8f 7e       	andi	r24, 0xEF	; 239
    530a:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearError();
			ErrorCode = HOST_WAITERROR_PipeError;
    530e:	82 e0       	ldi	r24, 0x02	; 2

			break;
    5310:	0f c0       	rjmp	.+30     	; 0x5330 <USB_Host_WaitMS+0x8e>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    5312:	90 91 a6 00 	lds	r25, 0x00A6
		}

		if (Pipe_IsStalled())
    5316:	91 ff       	sbrs	r25, 1
    5318:	07 c0       	rjmp	.+14     	; 0x5328 <USB_Host_WaitMS+0x86>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearStall(void)
			{
				UPINTX &= ~(1 << RXSTALLI);
    531a:	80 91 a6 00 	lds	r24, 0x00A6
    531e:	8d 7f       	andi	r24, 0xFD	; 253
    5320:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearStall();
			ErrorCode = HOST_WAITERROR_SetupStalled;
    5324:	83 e0       	ldi	r24, 0x03	; 3

			break;
    5326:	04 c0       	rjmp	.+8      	; 0x5330 <USB_Host_WaitMS+0x8e>
	USB_INT_Disable(USB_INT_HSOFI);
	USB_INT_Clear(USB_INT_HSOFI);

	USB_Host_ResumeBus();

	while (MS)
    5328:	88 23       	and	r24, r24
    532a:	a9 f6       	brne	.-86     	; 0x52d6 <USB_Host_WaitMS+0x34>
    532c:	01 c0       	rjmp	.+2      	; 0x5330 <USB_Host_WaitMS+0x8e>
			MS--;
		}

		if ((USB_HostState == HOST_STATE_Unattached) || (USB_CurrentMode != USB_MODE_Host))
		{
			ErrorCode = HOST_WAITERROR_DeviceDisconnect;
    532e:	81 e0       	ldi	r24, 0x01	; 1

			break;
		}
	}

	if (BusSuspended)
    5330:	41 15       	cp	r20, r1
    5332:	51 05       	cpc	r21, r1
    5334:	29 f4       	brne	.+10     	; 0x5340 <USB_Host_WaitMS+0x9e>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    5336:	90 91 9e 00 	lds	r25, 0x009E
    533a:	9e 7f       	andi	r25, 0xFE	; 254
    533c:	90 93 9e 00 	sts	0x009E, r25
	  USB_Host_SuspendBus();

	if (HSOFIEnabled)
    5340:	21 15       	cp	r18, r1
    5342:	31 05       	cpc	r19, r1
    5344:	29 f0       	breq	.+10     	; 0x5350 <USB_Host_WaitMS+0xae>
						UEIENX |= (1 << RXSTPE);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHIEN  |= (1 << HSOFE);
    5346:	90 91 a0 00 	lds	r25, 0x00A0
    534a:	90 62       	ori	r25, 0x20	; 32
    534c:	90 93 a0 00 	sts	0x00A0, r25
	  USB_INT_Enable(USB_INT_HSOFI);

	return ErrorCode;
}
    5350:	08 95       	ret

00005352 <USB_Host_ProcessNextHostState>:

#define  __INCLUDE_FROM_HOST_C
#include "../Host.h"

void USB_Host_ProcessNextHostState(void)
{
    5352:	0f 93       	push	r16
    5354:	1f 93       	push	r17
    5356:	df 93       	push	r29
    5358:	cf 93       	push	r28
    535a:	cd b7       	in	r28, 0x3d	; 61
    535c:	de b7       	in	r29, 0x3e	; 62
    535e:	28 97       	sbiw	r28, 0x08	; 8
    5360:	0f b6       	in	r0, 0x3f	; 63
    5362:	f8 94       	cli
    5364:	de bf       	out	0x3e, r29	; 62
    5366:	0f be       	out	0x3f, r0	; 63
    5368:	cd bf       	out	0x3d, r28	; 61
	uint8_t SubErrorCode = HOST_ENUMERROR_NoError;

	static uint16_t WaitMSRemaining;
	static uint8_t  PostWaitState;

	switch (USB_HostState)
    536a:	8e b3       	in	r24, 0x1e	; 30
    536c:	85 30       	cpi	r24, 0x05	; 5
    536e:	09 f4       	brne	.+2      	; 0x5372 <USB_Host_ProcessNextHostState+0x20>
    5370:	96 c0       	rjmp	.+300    	; 0x549e <USB_Host_ProcessNextHostState+0x14c>
    5372:	86 30       	cpi	r24, 0x06	; 6
    5374:	68 f4       	brcc	.+26     	; 0x5390 <USB_Host_ProcessNextHostState+0x3e>
    5376:	82 30       	cpi	r24, 0x02	; 2
    5378:	b9 f1       	breq	.+110    	; 0x53e8 <USB_Host_ProcessNextHostState+0x96>
    537a:	83 30       	cpi	r24, 0x03	; 3
    537c:	18 f4       	brcc	.+6      	; 0x5384 <USB_Host_ProcessNextHostState+0x32>
    537e:	88 23       	and	r24, r24
    5380:	a1 f0       	breq	.+40     	; 0x53aa <USB_Host_ProcessNextHostState+0x58>
    5382:	ff c0       	rjmp	.+510    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
    5384:	83 30       	cpi	r24, 0x03	; 3
    5386:	c9 f1       	breq	.+114    	; 0x53fa <USB_Host_ProcessNextHostState+0xa8>
    5388:	84 30       	cpi	r24, 0x04	; 4
    538a:	09 f0       	breq	.+2      	; 0x538e <USB_Host_ProcessNextHostState+0x3c>
    538c:	fa c0       	rjmp	.+500    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
    538e:	60 c0       	rjmp	.+192    	; 0x5450 <USB_Host_ProcessNextHostState+0xfe>
    5390:	87 30       	cpi	r24, 0x07	; 7
    5392:	09 f4       	brne	.+2      	; 0x5396 <USB_Host_ProcessNextHostState+0x44>
    5394:	9a c0       	rjmp	.+308    	; 0x54ca <USB_Host_ProcessNextHostState+0x178>
    5396:	87 30       	cpi	r24, 0x07	; 7
    5398:	08 f4       	brcc	.+2      	; 0x539c <USB_Host_ProcessNextHostState+0x4a>
    539a:	8b c0       	rjmp	.+278    	; 0x54b2 <USB_Host_ProcessNextHostState+0x160>
    539c:	88 30       	cpi	r24, 0x08	; 8
    539e:	09 f4       	brne	.+2      	; 0x53a2 <USB_Host_ProcessNextHostState+0x50>
    53a0:	b3 c0       	rjmp	.+358    	; 0x5508 <USB_Host_ProcessNextHostState+0x1b6>
    53a2:	89 30       	cpi	r24, 0x09	; 9
    53a4:	09 f0       	breq	.+2      	; 0x53a8 <USB_Host_ProcessNextHostState+0x56>
    53a6:	ed c0       	rjmp	.+474    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
    53a8:	d3 c0       	rjmp	.+422    	; 0x5550 <USB_Host_ProcessNextHostState+0x1fe>
	{
		case HOST_STATE_WaitForDevice:
			if (WaitMSRemaining)
    53aa:	00 91 d7 03 	lds	r16, 0x03D7
    53ae:	10 91 d8 03 	lds	r17, 0x03D8
    53b2:	01 15       	cp	r16, r1
    53b4:	11 05       	cpc	r17, r1
    53b6:	09 f4       	brne	.+2      	; 0x53ba <USB_Host_ProcessNextHostState+0x68>
    53b8:	e4 c0       	rjmp	.+456    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
			{
				if ((SubErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    53ba:	81 e0       	ldi	r24, 0x01	; 1
    53bc:	72 df       	rcall	.-284    	; 0x52a2 <USB_Host_WaitMS>
    53be:	68 2f       	mov	r22, r24
    53c0:	88 23       	and	r24, r24
    53c2:	29 f0       	breq	.+10     	; 0x53ce <USB_Host_ProcessNextHostState+0x7c>
				{
					USB_HostState = PostWaitState;
    53c4:	80 91 d6 03 	lds	r24, 0x03D6
    53c8:	8e bb       	out	0x1e, r24	; 30
					ErrorCode     = HOST_ENUMERROR_WaitStage;
    53ca:	81 e0       	ldi	r24, 0x01	; 1
					break;
    53cc:	cd c0       	rjmp	.+410    	; 0x5568 <USB_Host_ProcessNextHostState+0x216>
				}

				if (!(--WaitMSRemaining))
    53ce:	01 50       	subi	r16, 0x01	; 1
    53d0:	10 40       	sbci	r17, 0x00	; 0
    53d2:	10 93 d8 03 	sts	0x03D8, r17
    53d6:	00 93 d7 03 	sts	0x03D7, r16
    53da:	01 15       	cp	r16, r1
    53dc:	11 05       	cpc	r17, r1
    53de:	09 f0       	breq	.+2      	; 0x53e2 <USB_Host_ProcessNextHostState+0x90>
    53e0:	d0 c0       	rjmp	.+416    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
				  USB_HostState = PostWaitState;
    53e2:	80 91 d6 03 	lds	r24, 0x03D6
    53e6:	07 c0       	rjmp	.+14     	; 0x53f6 <USB_Host_ProcessNextHostState+0xa4>
			}

			break;
		case HOST_STATE_Powered:
			WaitMSRemaining = HOST_DEVICE_SETTLE_DELAY_MS;
    53e8:	88 ee       	ldi	r24, 0xE8	; 232
    53ea:	93 e0       	ldi	r25, 0x03	; 3
    53ec:	90 93 d8 03 	sts	0x03D8, r25
    53f0:	80 93 d7 03 	sts	0x03D7, r24

			USB_HostState = HOST_STATE_Powered_WaitForDeviceSettle;
    53f4:	83 e0       	ldi	r24, 0x03	; 3
    53f6:	8e bb       	out	0x1e, r24	; 30
			break;
    53f8:	c4 c0       	rjmp	.+392    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
		case HOST_STATE_Powered_WaitForDeviceSettle:
			if (WaitMSRemaining--)
    53fa:	80 91 d7 03 	lds	r24, 0x03D7
    53fe:	90 91 d8 03 	lds	r25, 0x03D8
    5402:	9c 01       	movw	r18, r24
    5404:	21 50       	subi	r18, 0x01	; 1
    5406:	30 40       	sbci	r19, 0x00	; 0
    5408:	30 93 d8 03 	sts	0x03D8, r19
    540c:	20 93 d7 03 	sts	0x03D7, r18
    5410:	00 97       	sbiw	r24, 0x00	; 0
    5412:	39 f0       	breq	.+14     	; 0x5422 <USB_Host_ProcessNextHostState+0xd0>
    5414:	8f ec       	ldi	r24, 0xCF	; 207
    5416:	97 e0       	ldi	r25, 0x07	; 7
    5418:	01 97       	sbiw	r24, 0x01	; 1
    541a:	f1 f7       	brne	.-4      	; 0x5418 <USB_Host_ProcessNextHostState+0xc6>
    541c:	00 c0       	rjmp	.+0      	; 0x541e <USB_Host_ProcessNextHostState+0xcc>
    541e:	00 00       	nop
    5420:	b0 c0       	rjmp	.+352    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    5422:	77 98       	cbi	0x0e, 7	; 14

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    5424:	80 91 d8 00 	lds	r24, 0x00D8
    5428:	80 61       	ori	r24, 0x10	; 16
    542a:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Enable(void)
			{
				OTGCON &= ~(1 << VBUSHWC);
    542e:	80 91 dd 00 	lds	r24, 0x00DD
    5432:	8b 7f       	andi	r24, 0xFB	; 251
    5434:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON |=  (1 << UVCONE);
    5438:	80 91 d7 00 	lds	r24, 0x00D7
    543c:	80 61       	ori	r24, 0x10	; 16
    543e:	80 93 d7 00 	sts	0x00D7, r24
			}

			static inline void USB_Host_VBUS_Auto_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_On(void)
			{
				OTGCON |=  (1 << VBUSREQ);
    5442:	80 91 dd 00 	lds	r24, 0x00DD
    5446:	82 60       	ori	r24, 0x02	; 2
    5448:	80 93 dd 00 	sts	0x00DD, r24
				#if defined(NO_AUTO_VBUS_MANAGEMENT)
				USB_Host_VBUS_Manual_Enable();
				USB_Host_VBUS_Manual_On();
				#endif

				USB_HostState = HOST_STATE_Powered_WaitForConnect;
    544c:	84 e0       	ldi	r24, 0x04	; 4
    544e:	d3 cf       	rjmp	.-90     	; 0x53f6 <USB_Host_ProcessNextHostState+0xa4>
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
    5450:	80 91 9f 00 	lds	r24, 0x009F
			}

			break;
		case HOST_STATE_Powered_WaitForConnect:
			if (USB_INT_HasOccurred(USB_INT_DCONNI))
    5454:	80 ff       	sbrs	r24, 0
    5456:	95 c0       	rjmp	.+298    	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    5458:	80 91 9f 00 	lds	r24, 0x009F
    545c:	8e 7f       	andi	r24, 0xFE	; 254
    545e:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5462:	80 91 9f 00 	lds	r24, 0x009F
    5466:	8d 7f       	andi	r24, 0xFD	; 253
    5468:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    546c:	80 91 df 00 	lds	r24, 0x00DF
    5470:	8d 7f       	andi	r24, 0xFD	; 253
    5472:	80 93 df 00 	sts	0x00DF, r24
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
    5476:	80 91 de 00 	lds	r24, 0x00DE
    547a:	82 60       	ori	r24, 0x02	; 2
    547c:	80 93 de 00 	sts	0x00DE, r24
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    5480:	80 91 9e 00 	lds	r24, 0x009E
    5484:	81 60       	ori	r24, 0x01	; 1
    5486:	80 93 9e 00 	sts	0x009E, r24

				USB_INT_Clear(USB_INT_VBERRI);
				USB_INT_Enable(USB_INT_VBERRI);

				USB_Host_ResumeBus();
				Pipe_ClearPipes();
    548a:	25 d2       	rcall	.+1098   	; 0x58d6 <Pipe_ClearPipes>

				HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Powered_DoReset);
    548c:	1e ba       	out	0x1e, r1	; 30
    548e:	84 e6       	ldi	r24, 0x64	; 100
    5490:	90 e0       	ldi	r25, 0x00	; 0
    5492:	90 93 d8 03 	sts	0x03D8, r25
    5496:	80 93 d7 03 	sts	0x03D7, r24
    549a:	85 e0       	ldi	r24, 0x05	; 5
    549c:	56 c0       	rjmp	.+172    	; 0x554a <USB_Host_ProcessNextHostState+0x1f8>
			}

			break;
		case HOST_STATE_Powered_DoReset:
			USB_Host_ResetDevice();
    549e:	ab de       	rcall	.-682    	; 0x51f6 <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Powered_ConfigPipe);
    54a0:	1e ba       	out	0x1e, r1	; 30
    54a2:	88 ec       	ldi	r24, 0xC8	; 200
    54a4:	90 e0       	ldi	r25, 0x00	; 0
    54a6:	90 93 d8 03 	sts	0x03D8, r25
    54aa:	80 93 d7 03 	sts	0x03D7, r24
    54ae:	86 e0       	ldi	r24, 0x06	; 6
    54b0:	4c c0       	rjmp	.+152    	; 0x554a <USB_Host_ProcessNextHostState+0x1f8>
			break;
		case HOST_STATE_Powered_ConfigPipe:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, PIPE_CONTROLPIPE_DEFAULT_SIZE, 1)))
    54b2:	80 e0       	ldi	r24, 0x00	; 0
    54b4:	60 e0       	ldi	r22, 0x00	; 0
    54b6:	40 e0       	ldi	r20, 0x00	; 0
    54b8:	20 e4       	ldi	r18, 0x40	; 64
    54ba:	30 e0       	ldi	r19, 0x00	; 0
    54bc:	01 e0       	ldi	r16, 0x01	; 1
    54be:	7d d1       	rcall	.+762    	; 0x57ba <Pipe_ConfigurePipe>
    54c0:	88 23       	and	r24, r24
    54c2:	09 f4       	brne	.+2      	; 0x54c6 <USB_Host_ProcessNextHostState+0x174>
    54c4:	4d c0       	rjmp	.+154    	; 0x5560 <USB_Host_ProcessNextHostState+0x20e>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_HostState = HOST_STATE_Default;
    54c6:	87 e0       	ldi	r24, 0x07	; 7
    54c8:	96 cf       	rjmp	.-212    	; 0x53f6 <USB_Host_ProcessNextHostState+0xa4>
			break;
		case HOST_STATE_Default:
			USB_ControlRequest = (USB_Request_Header_t)
    54ca:	ae ea       	ldi	r26, 0xAE	; 174
    54cc:	bd e0       	ldi	r27, 0x0D	; 13
    54ce:	e5 e4       	ldi	r30, 0x45	; 69
    54d0:	f3 e0       	ldi	r31, 0x03	; 3
    54d2:	88 e0       	ldi	r24, 0x08	; 8
    54d4:	01 90       	ld	r0, Z+
    54d6:	0d 92       	st	X+, r0
    54d8:	81 50       	subi	r24, 0x01	; 1
    54da:	e1 f7       	brne	.-8      	; 0x54d4 <USB_Host_ProcessNextHostState+0x182>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    54dc:	10 92 a7 00 	sts	0x00A7, r1
				};

			uint8_t DataBuffer[8];

			Pipe_SelectPipe(PIPE_CONTROLPIPE);
			if ((SubErrorCode = USB_Host_SendControlRequest(DataBuffer)) != HOST_SENDCONTROL_Successful)
    54e0:	ce 01       	movw	r24, r28
    54e2:	01 96       	adiw	r24, 0x01	; 1
    54e4:	0e d7       	rcall	.+3612   	; 0x6302 <USB_Host_SendControlRequest>
    54e6:	68 2f       	mov	r22, r24
    54e8:	88 23       	and	r24, r24
    54ea:	09 f0       	breq	.+2      	; 0x54ee <USB_Host_ProcessNextHostState+0x19c>
    54ec:	3c c0       	rjmp	.+120    	; 0x5566 <USB_Host_ProcessNextHostState+0x214>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			USB_Host_ControlPipeSize = DataBuffer[offsetof(USB_Descriptor_Device_t, Endpoint0Size)];
    54ee:	88 85       	ldd	r24, Y+8	; 0x08
    54f0:	80 93 4d 03 	sts	0x034D, r24

			USB_Host_ResetDevice();
    54f4:	80 de       	rcall	.-768    	; 0x51f6 <USB_Host_ResetDevice>

			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
    54f6:	1e ba       	out	0x1e, r1	; 30
    54f8:	88 ec       	ldi	r24, 0xC8	; 200
    54fa:	90 e0       	ldi	r25, 0x00	; 0
    54fc:	90 93 d8 03 	sts	0x03D8, r25
    5500:	80 93 d7 03 	sts	0x03D7, r24
    5504:	88 e0       	ldi	r24, 0x08	; 8
    5506:	21 c0       	rjmp	.+66     	; 0x554a <USB_Host_ProcessNextHostState+0x1f8>
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
    5508:	20 91 4d 03 	lds	r18, 0x034D
    550c:	80 e0       	ldi	r24, 0x00	; 0
    550e:	60 e0       	ldi	r22, 0x00	; 0
    5510:	40 e0       	ldi	r20, 0x00	; 0
    5512:	30 e0       	ldi	r19, 0x00	; 0
    5514:	01 e0       	ldi	r16, 0x01	; 1
    5516:	51 d1       	rcall	.+674    	; 0x57ba <Pipe_ConfigurePipe>
    5518:	88 23       	and	r24, r24
    551a:	11 f1       	breq	.+68     	; 0x5560 <USB_Host_ProcessNextHostState+0x20e>
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
				break;
			}

			USB_ControlRequest = (USB_Request_Header_t)
    551c:	ae ea       	ldi	r26, 0xAE	; 174
    551e:	bd e0       	ldi	r27, 0x0D	; 13
    5520:	ed e3       	ldi	r30, 0x3D	; 61
    5522:	f3 e0       	ldi	r31, 0x03	; 3
    5524:	88 e0       	ldi	r24, 0x08	; 8
    5526:	01 90       	ld	r0, Z+
    5528:	0d 92       	st	X+, r0
    552a:	81 50       	subi	r24, 0x01	; 1
    552c:	e1 f7       	brne	.-8      	; 0x5526 <USB_Host_ProcessNextHostState+0x1d4>
					.wValue        = USB_HOST_DEVICEADDRESS,
					.wIndex        = 0,
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
    552e:	80 e0       	ldi	r24, 0x00	; 0
    5530:	90 e0       	ldi	r25, 0x00	; 0
    5532:	e7 d6       	rcall	.+3534   	; 0x6302 <USB_Host_SendControlRequest>
    5534:	68 2f       	mov	r22, r24
    5536:	88 23       	and	r24, r24
    5538:	b1 f4       	brne	.+44     	; 0x5566 <USB_Host_ProcessNextHostState+0x214>
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
				break;
			}

			HOST_TASK_NONBLOCK_WAIT(100, HOST_STATE_Default_PostAddressSet);
    553a:	1e ba       	out	0x1e, r1	; 30
    553c:	84 e6       	ldi	r24, 0x64	; 100
    553e:	90 e0       	ldi	r25, 0x00	; 0
    5540:	90 93 d8 03 	sts	0x03D8, r25
    5544:	80 93 d7 03 	sts	0x03D7, r24
    5548:	89 e0       	ldi	r24, 0x09	; 9
    554a:	80 93 d6 03 	sts	0x03D6, r24
			break;
    554e:	19 c0       	rjmp	.+50     	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
			}

			static inline void USB_Host_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SetDeviceAddress(const uint8_t Address)
			{
				UHADDR  =  (Address & 0x7F);
    5550:	81 e0       	ldi	r24, 0x01	; 1
    5552:	80 93 a1 00 	sts	0x00A1, r24
		case HOST_STATE_Default_PostAddressSet:
			USB_Host_SetDeviceAddress(USB_HOST_DEVICEADDRESS);

			USB_HostState = HOST_STATE_Addressed;
    5556:	8a e0       	ldi	r24, 0x0A	; 10
    5558:	8e bb       	out	0x1e, r24	; 30

			EVENT_USB_Host_DeviceEnumerationComplete();
    555a:	0e 94 ea 02 	call	0x5d4	; 0x5d4 <EVENT_USB_Host_DeviceEnumerationComplete>
			break;
    555e:	11 c0       	rjmp	.+34     	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
				SubErrorCode = 0;
    5560:	60 e0       	ldi	r22, 0x00	; 0
			HOST_TASK_NONBLOCK_WAIT(200, HOST_STATE_Default_PostReset);
			break;
		case HOST_STATE_Default_PostReset:
			if (!(Pipe_ConfigurePipe(PIPE_CONTROLPIPE, EP_TYPE_CONTROL, ENDPOINT_CONTROLEP, USB_Host_ControlPipeSize, 1)))
			{
				ErrorCode    = HOST_ENUMERROR_PipeConfigError;
    5562:	84 e0       	ldi	r24, 0x04	; 4
    5564:	01 c0       	rjmp	.+2      	; 0x5568 <USB_Host_ProcessNextHostState+0x216>
					.wLength       = 0,
				};

			if ((SubErrorCode = USB_Host_SendControlRequest(NULL)) != HOST_SENDCONTROL_Successful)
			{
				ErrorCode = HOST_ENUMERROR_ControlError;
    5566:	83 e0       	ldi	r24, 0x03	; 3

		default:
			break;
	}

	if ((ErrorCode != HOST_ENUMERROR_NoError) && (USB_HostState != HOST_STATE_Unattached))
    5568:	9e b3       	in	r25, 0x1e	; 30
    556a:	91 30       	cpi	r25, 0x01	; 1
    556c:	51 f0       	breq	.+20     	; 0x5582 <USB_Host_ProcessNextHostState+0x230>
	{
		EVENT_USB_Host_DeviceEnumerationFailed(ErrorCode, SubErrorCode);
    556e:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <EVENT_USB_Host_DeviceEnumerationFailed>
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5572:	80 91 dd 00 	lds	r24, 0x00DD
    5576:	81 60       	ori	r24, 0x01	; 1
    5578:	80 93 dd 00 	sts	0x00DD, r24

		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_DeviceUnattached();
    557c:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5580:	2c d2       	rcall	.+1112   	; 0x59da <USB_ResetInterface>
	}
}
    5582:	28 96       	adiw	r28, 0x08	; 8
    5584:	0f b6       	in	r0, 0x3f	; 63
    5586:	f8 94       	cli
    5588:	de bf       	out	0x3e, r29	; 62
    558a:	0f be       	out	0x3f, r0	; 63
    558c:	cd bf       	out	0x3d, r28	; 61
    558e:	cf 91       	pop	r28
    5590:	df 91       	pop	r29
    5592:	1f 91       	pop	r17
    5594:	0f 91       	pop	r16
    5596:	08 95       	ret

00005598 <Pipe_Discard_Stream>:

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5598:	df 92       	push	r13
    559a:	ef 92       	push	r14
    559c:	ff 92       	push	r15
    559e:	0f 93       	push	r16
    55a0:	1f 93       	push	r17
    55a2:	cf 93       	push	r28
    55a4:	df 93       	push	r29
    55a6:	ec 01       	movw	r28, r24
    55a8:	8b 01       	movw	r16, r22
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    55aa:	80 91 aa 00 	lds	r24, 0x00AA
    55ae:	8f 7c       	andi	r24, 0xCF	; 207
    55b0:	80 61       	ori	r24, 0x10	; 16
    55b2:	80 93 aa 00 	sts	0x00AA, r24
	uint8_t  ErrorCode;
	uint16_t BytesInTransfer = 0;
	
	Pipe_SetPipeToken(PIPE_TOKEN_IN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    55b6:	c9 d1       	rcall	.+914    	; 0x594a <Pipe_WaitUntilReady>
    55b8:	d8 2e       	mov	r13, r24
    55ba:	88 23       	and	r24, r24
    55bc:	79 f5       	brne	.+94     	; 0x561c <Pipe_Discard_Stream+0x84>
	  return ErrorCode;

	if (BytesProcessed != NULL)
    55be:	01 15       	cp	r16, r1
    55c0:	11 05       	cpc	r17, r1
    55c2:	29 f0       	breq	.+10     	; 0x55ce <Pipe_Discard_Stream+0x36>
	  Length -= *BytesProcessed;
    55c4:	f8 01       	movw	r30, r16
    55c6:	20 81       	ld	r18, Z
    55c8:	31 81       	ldd	r19, Z+1	; 0x01
    55ca:	c2 1b       	sub	r28, r18
    55cc:	d3 0b       	sbc	r29, r19

#include "PipeStream_AVR8.h"

uint8_t Pipe_Discard_Stream(uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    55ce:	ee 24       	eor	r14, r14
    55d0:	ff 24       	eor	r15, r15
    55d2:	20 c0       	rjmp	.+64     	; 0x5614 <Pipe_Discard_Stream+0x7c>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    55d4:	80 91 a6 00 	lds	r24, 0x00A6
	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    55d8:	85 fd       	sbrc	r24, 5
    55da:	16 c0       	rjmp	.+44     	; 0x5608 <Pipe_Discard_Stream+0x70>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    55dc:	80 91 a6 00 	lds	r24, 0x00A6
    55e0:	8e 77       	andi	r24, 0x7E	; 126
    55e2:	80 93 a6 00 	sts	0x00A6, r24
		{
			Pipe_ClearIN();
				
			if (BytesProcessed != NULL)
    55e6:	01 15       	cp	r16, r1
    55e8:	11 05       	cpc	r17, r1
    55ea:	51 f0       	breq	.+20     	; 0x5600 <Pipe_Discard_Stream+0x68>
			{
				*BytesProcessed += BytesInTransfer;
    55ec:	f8 01       	movw	r30, r16
    55ee:	80 81       	ld	r24, Z
    55f0:	91 81       	ldd	r25, Z+1	; 0x01
    55f2:	8e 0d       	add	r24, r14
    55f4:	9f 1d       	adc	r25, r15
    55f6:	91 83       	std	Z+1, r25	; 0x01
    55f8:	80 83       	st	Z, r24
				return PIPE_RWSTREAM_IncompleteTransfer;
    55fa:	84 e0       	ldi	r24, 0x04	; 4
    55fc:	d8 2e       	mov	r13, r24
    55fe:	0e c0       	rjmp	.+28     	; 0x561c <Pipe_Discard_Stream+0x84>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5600:	a4 d1       	rcall	.+840    	; 0x594a <Pipe_WaitUntilReady>
    5602:	88 23       	and	r24, r24
    5604:	39 f0       	breq	.+14     	; 0x5614 <Pipe_Discard_Stream+0x7c>
    5606:	09 c0       	rjmp	.+18     	; 0x561a <Pipe_Discard_Stream+0x82>
			static inline void Pipe_Discard_8(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Discard_8(void)
			{
				uint8_t Dummy;

				Dummy = UPDATX;
    5608:	80 91 af 00 	lds	r24, 0x00AF
		}
		else
		{
			Pipe_Discard_8();
			
			Length--;
    560c:	21 97       	sbiw	r28, 0x01	; 1
			BytesInTransfer++;
    560e:	08 94       	sec
    5610:	e1 1c       	adc	r14, r1
    5612:	f1 1c       	adc	r15, r1
	  return ErrorCode;

	if (BytesProcessed != NULL)
	  Length -= *BytesProcessed;

	while (Length)
    5614:	20 97       	sbiw	r28, 0x00	; 0
    5616:	f1 f6       	brne	.-68     	; 0x55d4 <Pipe_Discard_Stream+0x3c>
    5618:	01 c0       	rjmp	.+2      	; 0x561c <Pipe_Discard_Stream+0x84>
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    561a:	d8 2e       	mov	r13, r24
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    561c:	8d 2d       	mov	r24, r13
    561e:	df 91       	pop	r29
    5620:	cf 91       	pop	r28
    5622:	1f 91       	pop	r17
    5624:	0f 91       	pop	r16
    5626:	ff 90       	pop	r15
    5628:	ef 90       	pop	r14
    562a:	df 90       	pop	r13
    562c:	08 95       	ret

0000562e <Pipe_Write_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    562e:	8f 92       	push	r8
    5630:	9f 92       	push	r9
    5632:	bf 92       	push	r11
    5634:	cf 92       	push	r12
    5636:	df 92       	push	r13
    5638:	ef 92       	push	r14
    563a:	ff 92       	push	r15
    563c:	0f 93       	push	r16
    563e:	1f 93       	push	r17
    5640:	df 93       	push	r29
    5642:	cf 93       	push	r28
    5644:	0f 92       	push	r0
    5646:	cd b7       	in	r28, 0x3d	; 61
    5648:	de b7       	in	r29, 0x3e	; 62
    564a:	e8 2e       	mov	r14, r24
    564c:	4b 01       	movw	r8, r22
    564e:	8a 01       	movw	r16, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5650:	80 91 aa 00 	lds	r24, 0x00AA
    5654:	8f 7c       	andi	r24, 0xCF	; 207
    5656:	80 62       	ori	r24, 0x20	; 32
    5658:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    565c:	99 83       	std	Y+1, r25	; 0x01
    565e:	75 d1       	rcall	.+746    	; 0x594a <Pipe_WaitUntilReady>
    5660:	b8 2e       	mov	r11, r24
    5662:	99 81       	ldd	r25, Y+1	; 0x01
    5664:	88 23       	and	r24, r24
    5666:	c1 f5       	brne	.+112    	; 0x56d8 <Pipe_Write_Stream_LE+0xaa>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    5668:	f9 2e       	mov	r15, r25
	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    566a:	01 15       	cp	r16, r1
    566c:	11 05       	cpc	r17, r1
    566e:	39 f0       	breq	.+14     	; 0x567e <Pipe_Write_Stream_LE+0x50>
	{
		Length -= *BytesProcessed;
    5670:	f8 01       	movw	r30, r16
    5672:	20 81       	ld	r18, Z
    5674:	31 81       	ldd	r19, Z+1	; 0x01
    5676:	82 1a       	sub	r8, r18
    5678:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    567a:	e2 0e       	add	r14, r18
    567c:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    567e:	cc 24       	eor	r12, r12
    5680:	dd 24       	eor	r13, r13
    5682:	25 c0       	rjmp	.+74     	; 0x56ce <Pipe_Write_Stream_LE+0xa0>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    5684:	80 91 a6 00 	lds	r24, 0x00A6
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    5688:	85 fd       	sbrc	r24, 5
    568a:	16 c0       	rjmp	.+44     	; 0x56b8 <Pipe_Write_Stream_LE+0x8a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    568c:	80 91 a6 00 	lds	r24, 0x00A6
    5690:	8b 77       	andi	r24, 0x7B	; 123
    5692:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    5696:	01 15       	cp	r16, r1
    5698:	11 05       	cpc	r17, r1
    569a:	51 f0       	breq	.+20     	; 0x56b0 <Pipe_Write_Stream_LE+0x82>
			{
				*BytesProcessed += BytesInTransfer;
    569c:	f8 01       	movw	r30, r16
    569e:	80 81       	ld	r24, Z
    56a0:	91 81       	ldd	r25, Z+1	; 0x01
    56a2:	8c 0d       	add	r24, r12
    56a4:	9d 1d       	adc	r25, r13
    56a6:	91 83       	std	Z+1, r25	; 0x01
    56a8:	80 83       	st	Z, r24
				return PIPE_RWSTREAM_IncompleteTransfer;
    56aa:	24 e0       	ldi	r18, 0x04	; 4
    56ac:	b2 2e       	mov	r11, r18
    56ae:	14 c0       	rjmp	.+40     	; 0x56d8 <Pipe_Write_Stream_LE+0xaa>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    56b0:	4c d1       	rcall	.+664    	; 0x594a <Pipe_WaitUntilReady>
    56b2:	88 23       	and	r24, r24
    56b4:	61 f0       	breq	.+24     	; 0x56ce <Pipe_Write_Stream_LE+0xa0>
    56b6:	0f c0       	rjmp	.+30     	; 0x56d6 <Pipe_Write_Stream_LE+0xa8>
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    56b8:	f7 01       	movw	r30, r14
    56ba:	81 91       	ld	r24, Z+
    56bc:	7f 01       	movw	r14, r30
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    56be:	80 93 af 00 	sts	0x00AF, r24
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    56c2:	08 94       	sec
    56c4:	81 08       	sbc	r8, r1
    56c6:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    56c8:	08 94       	sec
    56ca:	c1 1c       	adc	r12, r1
    56cc:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    56ce:	81 14       	cp	r8, r1
    56d0:	91 04       	cpc	r9, r1
    56d2:	c1 f6       	brne	.-80     	; 0x5684 <Pipe_Write_Stream_LE+0x56>
    56d4:	01 c0       	rjmp	.+2      	; 0x56d8 <Pipe_Write_Stream_LE+0xaa>
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    56d6:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    56d8:	8b 2d       	mov	r24, r11
    56da:	0f 90       	pop	r0
    56dc:	cf 91       	pop	r28
    56de:	df 91       	pop	r29
    56e0:	1f 91       	pop	r17
    56e2:	0f 91       	pop	r16
    56e4:	ff 90       	pop	r15
    56e6:	ef 90       	pop	r14
    56e8:	df 90       	pop	r13
    56ea:	cf 90       	pop	r12
    56ec:	bf 90       	pop	r11
    56ee:	9f 90       	pop	r9
    56f0:	8f 90       	pop	r8
    56f2:	08 95       	ret

000056f4 <Pipe_Read_Stream_LE>:
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    56f4:	8f 92       	push	r8
    56f6:	9f 92       	push	r9
    56f8:	bf 92       	push	r11
    56fa:	cf 92       	push	r12
    56fc:	df 92       	push	r13
    56fe:	ef 92       	push	r14
    5700:	ff 92       	push	r15
    5702:	0f 93       	push	r16
    5704:	1f 93       	push	r17
    5706:	df 93       	push	r29
    5708:	cf 93       	push	r28
    570a:	0f 92       	push	r0
    570c:	cd b7       	in	r28, 0x3d	; 61
    570e:	de b7       	in	r29, 0x3e	; 62
    5710:	e8 2e       	mov	r14, r24
    5712:	4b 01       	movw	r8, r22
    5714:	8a 01       	movw	r16, r20
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    5716:	80 91 aa 00 	lds	r24, 0x00AA
    571a:	8f 7c       	andi	r24, 0xCF	; 207
    571c:	80 61       	ori	r24, 0x10	; 16
    571e:	80 93 aa 00 	sts	0x00AA, r24
	uint16_t BytesInTransfer = 0;
	uint8_t  ErrorCode;

	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
    5722:	99 83       	std	Y+1, r25	; 0x01
    5724:	12 d1       	rcall	.+548    	; 0x594a <Pipe_WaitUntilReady>
    5726:	b8 2e       	mov	r11, r24
    5728:	99 81       	ldd	r25, Y+1	; 0x01
    572a:	88 23       	and	r24, r24
    572c:	c1 f5       	brne	.+112    	; 0x579e <Pipe_Read_Stream_LE+0xaa>

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
	uint8_t* DataStream      = ((uint8_t*)Buffer + TEMPLATE_BUFFER_OFFSET(Length));
    572e:	f9 2e       	mov	r15, r25
	Pipe_SetPipeToken(TEMPLATE_TOKEN);

	if ((ErrorCode = Pipe_WaitUntilReady()))
	  return ErrorCode;

	if (BytesProcessed != NULL)
    5730:	01 15       	cp	r16, r1
    5732:	11 05       	cpc	r17, r1
    5734:	39 f0       	breq	.+14     	; 0x5744 <Pipe_Read_Stream_LE+0x50>
	{
		Length -= *BytesProcessed;
    5736:	f8 01       	movw	r30, r16
    5738:	20 81       	ld	r18, Z
    573a:	31 81       	ldd	r19, Z+1	; 0x01
    573c:	82 1a       	sub	r8, r18
    573e:	93 0a       	sbc	r9, r19
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
    5740:	e2 0e       	add	r14, r18
    5742:	f3 1e       	adc	r15, r19
#if defined(TEMPLATE_FUNC_NAME)

uint8_t TEMPLATE_FUNC_NAME (TEMPLATE_BUFFER_TYPE const Buffer,
                            uint16_t Length,
                            uint16_t* const BytesProcessed)
{
    5744:	cc 24       	eor	r12, r12
    5746:	dd 24       	eor	r13, r13
    5748:	25 c0       	rjmp	.+74     	; 0x5794 <Pipe_Read_Stream_LE+0xa0>
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    574a:	80 91 a6 00 	lds	r24, 0x00A6
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
	{
		if (!(Pipe_IsReadWriteAllowed()))
    574e:	85 fd       	sbrc	r24, 5
    5750:	16 c0       	rjmp	.+44     	; 0x577e <Pipe_Read_Stream_LE+0x8a>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    5752:	80 91 a6 00 	lds	r24, 0x00A6
    5756:	8e 77       	andi	r24, 0x7E	; 126
    5758:	80 93 a6 00 	sts	0x00A6, r24
		{
			TEMPLATE_CLEAR_PIPE();

			if (BytesProcessed != NULL)
    575c:	01 15       	cp	r16, r1
    575e:	11 05       	cpc	r17, r1
    5760:	51 f0       	breq	.+20     	; 0x5776 <Pipe_Read_Stream_LE+0x82>
			{
				*BytesProcessed += BytesInTransfer;
    5762:	f8 01       	movw	r30, r16
    5764:	80 81       	ld	r24, Z
    5766:	91 81       	ldd	r25, Z+1	; 0x01
    5768:	8c 0d       	add	r24, r12
    576a:	9d 1d       	adc	r25, r13
    576c:	91 83       	std	Z+1, r25	; 0x01
    576e:	80 83       	st	Z, r24
				return PIPE_RWSTREAM_IncompleteTransfer;
    5770:	44 e0       	ldi	r20, 0x04	; 4
    5772:	b4 2e       	mov	r11, r20
    5774:	14 c0       	rjmp	.+40     	; 0x579e <Pipe_Read_Stream_LE+0xaa>
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    5776:	e9 d0       	rcall	.+466    	; 0x594a <Pipe_WaitUntilReady>
    5778:	88 23       	and	r24, r24
    577a:	61 f0       	breq	.+24     	; 0x5794 <Pipe_Read_Stream_LE+0xa0>
    577c:	0f c0       	rjmp	.+30     	; 0x579c <Pipe_Read_Stream_LE+0xa8>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    577e:	80 91 af 00 	lds	r24, 0x00AF
			  return ErrorCode;
		}
		else
		{
			TEMPLATE_TRANSFER_BYTE(DataStream);
    5782:	f7 01       	movw	r30, r14
    5784:	81 93       	st	Z+, r24
    5786:	7f 01       	movw	r14, r30
			TEMPLATE_BUFFER_MOVE(DataStream, 1);
			Length--;
    5788:	08 94       	sec
    578a:	81 08       	sbc	r8, r1
    578c:	91 08       	sbc	r9, r1
			BytesInTransfer++;
    578e:	08 94       	sec
    5790:	c1 1c       	adc	r12, r1
    5792:	d1 1c       	adc	r13, r1
	{
		Length -= *BytesProcessed;
		TEMPLATE_BUFFER_MOVE(DataStream, *BytesProcessed);
	}

	while (Length)
    5794:	81 14       	cp	r8, r1
    5796:	91 04       	cpc	r9, r1
    5798:	c1 f6       	brne	.-80     	; 0x574a <Pipe_Read_Stream_LE+0x56>
    579a:	01 c0       	rjmp	.+2      	; 0x579e <Pipe_Read_Stream_LE+0xaa>
			{
				*BytesProcessed += BytesInTransfer;
				return PIPE_RWSTREAM_IncompleteTransfer;
			}

			if ((ErrorCode = Pipe_WaitUntilReady()))
    579c:	b8 2e       	mov	r11, r24
			BytesInTransfer++;
		}
	}

	return PIPE_RWSTREAM_NoError;
}
    579e:	8b 2d       	mov	r24, r11
    57a0:	0f 90       	pop	r0
    57a2:	cf 91       	pop	r28
    57a4:	df 91       	pop	r29
    57a6:	1f 91       	pop	r17
    57a8:	0f 91       	pop	r16
    57aa:	ff 90       	pop	r15
    57ac:	ef 90       	pop	r14
    57ae:	df 90       	pop	r13
    57b0:	cf 90       	pop	r12
    57b2:	bf 90       	pop	r11
    57b4:	9f 90       	pop	r9
    57b6:	8f 90       	pop	r8
    57b8:	08 95       	ret

000057ba <Pipe_ConfigurePipe>:
bool Pipe_ConfigurePipe(const uint8_t Address,
                        const uint8_t Type,
                        const uint8_t EndpointAddress,
                        const uint16_t Size,
                        const uint8_t Banks)
{
    57ba:	0f 93       	push	r16
	uint8_t Number = (Address & PIPE_EPNUM_MASK);
    57bc:	58 2f       	mov	r21, r24
    57be:	5f 70       	andi	r21, 0x0F	; 15
	uint8_t Token  = (Address & PIPE_DIR_IN) ? PIPE_TOKEN_IN : PIPE_TOKEN_OUT;
    57c0:	87 ff       	sbrs	r24, 7
    57c2:	02 c0       	rjmp	.+4      	; 0x57c8 <Pipe_ConfigurePipe+0xe>
    57c4:	80 e1       	ldi	r24, 0x10	; 16
    57c6:	01 c0       	rjmp	.+2      	; 0x57ca <Pipe_ConfigurePipe+0x10>
    57c8:	80 e2       	ldi	r24, 0x20	; 32
	
	if (Number >= PIPE_TOTAL_PIPES)
    57ca:	57 30       	cpi	r21, 0x07	; 7
    57cc:	08 f0       	brcs	.+2      	; 0x57d0 <Pipe_ConfigurePipe+0x16>
    57ce:	59 c0       	rjmp	.+178    	; 0x5882 <Pipe_ConfigurePipe+0xc8>
	  return false;

	if (Type == EP_TYPE_CONTROL)
    57d0:	66 23       	and	r22, r22
    57d2:	09 f4       	brne	.+2      	; 0x57d6 <Pipe_ConfigurePipe+0x1c>
	  Token = PIPE_TOKEN_SETUP;
    57d4:	80 e0       	ldi	r24, 0x00	; 0

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    57d6:	4f 70       	andi	r20, 0x0F	; 15
    57d8:	62 95       	swap	r22
    57da:	66 0f       	add	r22, r22
    57dc:	66 0f       	add	r22, r22
    57de:	60 7c       	andi	r22, 0xC0	; 192
    57e0:	64 2b       	or	r22, r20
    57e2:	68 2b       	or	r22, r24
    57e4:	45 2f       	mov	r20, r21
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    57e6:	02 60       	ori	r16, 0x02	; 2
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    57e8:	84 2f       	mov	r24, r20
    57ea:	8f 70       	andi	r24, 0x0F	; 15
    57ec:	80 93 a7 00 	sts	0x00A7, r24
		uint8_t UPCFG2XTemp;
		uint8_t UPIENXTemp;

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
    57f0:	45 17       	cp	r20, r21
    57f2:	a1 f4       	brne	.+40     	; 0x581c <Pipe_ConfigurePipe+0x62>
    57f4:	88 e0       	ldi	r24, 0x08	; 8
    57f6:	90 e0       	ldi	r25, 0x00	; 0
    57f8:	70 e0       	ldi	r23, 0x00	; 0
    57fa:	03 c0       	rjmp	.+6      	; 0x5802 <Pipe_ConfigurePipe+0x48>
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
				{
					MaskVal++;
    57fc:	7f 5f       	subi	r23, 0xFF	; 255
					CheckBytes <<= 1;
    57fe:	88 0f       	add	r24, r24
    5800:	99 1f       	adc	r25, r25
			static inline uint8_t Pipe_BytesToEPSizeMask(const uint16_t Bytes)
			{
				uint8_t  MaskVal    = 0;
				uint16_t CheckBytes = 8;

				while ((CheckBytes < Bytes) && (CheckBytes < PIPE_MAX_SIZE))
    5802:	82 17       	cp	r24, r18
    5804:	93 07       	cpc	r25, r19
    5806:	10 f4       	brcc	.+4      	; 0x580c <Pipe_ConfigurePipe+0x52>
    5808:	75 30       	cpi	r23, 0x05	; 5
    580a:	c1 f7       	brne	.-16     	; 0x57fc <Pipe_ConfigurePipe+0x42>
				{
					MaskVal++;
					CheckBytes <<= 1;
				}

				return (MaskVal << EPSIZE0);
    580c:	87 2f       	mov	r24, r23
    580e:	82 95       	swap	r24
    5810:	80 7f       	andi	r24, 0xF0	; 240
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
    5812:	80 2b       	or	r24, r16

		Pipe_SelectPipe(PNum);

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
    5814:	f6 2f       	mov	r31, r22
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
			UPIENXTemp  = 0;
    5816:	70 e0       	ldi	r23, 0x00	; 0

		if (PNum == Number)
		{
			UPCFG0XTemp = ((Type << EPTYPE0) | Token | ((EndpointAddress & PIPE_EPNUM_MASK) << PEPNUM0));
			UPCFG1XTemp = ((1 << ALLOC) | Banks | Pipe_BytesToEPSizeMask(Size));
			UPCFG2XTemp = 0;
    5818:	e0 e0       	ldi	r30, 0x00	; 0
    581a:	08 c0       	rjmp	.+16     	; 0x582c <Pipe_ConfigurePipe+0x72>
			UPIENXTemp  = 0;
		}
		else
		{
			UPCFG0XTemp = UPCFG0X;
    581c:	f0 91 aa 00 	lds	r31, 0x00AA
			UPCFG1XTemp = UPCFG1X;
    5820:	80 91 ab 00 	lds	r24, 0x00AB
			UPCFG2XTemp = UPCFG2X;
    5824:	e0 91 ad 00 	lds	r30, 0x00AD
			UPIENXTemp  = UPIENX;
    5828:	70 91 ae 00 	lds	r23, 0x00AE
		}

		if (!(UPCFG1XTemp & (1 << ALLOC)))
    582c:	81 ff       	sbrs	r24, 1
    582e:	20 c0       	rjmp	.+64     	; 0x5870 <Pipe_ConfigurePipe+0xb6>
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    5830:	90 91 a9 00 	lds	r25, 0x00A9
    5834:	9e 7f       	andi	r25, 0xFE	; 254
    5836:	90 93 a9 00 	sts	0x00A9, r25
		  continue;

		Pipe_DisablePipe();
		UPCFG1X &= ~(1 << ALLOC);
    583a:	90 91 ab 00 	lds	r25, 0x00AB
    583e:	9d 7f       	andi	r25, 0xFD	; 253
    5840:	90 93 ab 00 	sts	0x00AB, r25
			 *  \pre The currently selected pipe must first be configured properly via \ref Pipe_ConfigurePipe().
			 */
			static inline void Pipe_EnablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_EnablePipe(void)
			{
				UPCONX |= (1 << PEN);
    5844:	90 91 a9 00 	lds	r25, 0x00A9
    5848:	91 60       	ori	r25, 0x01	; 1
    584a:	90 93 a9 00 	sts	0x00A9, r25

		Pipe_EnablePipe();
		UPCFG0X = UPCFG0XTemp;
    584e:	f0 93 aa 00 	sts	0x00AA, r31
		UPCFG1X = UPCFG1XTemp;
    5852:	80 93 ab 00 	sts	0x00AB, r24
		UPCFG2X = UPCFG2XTemp;
    5856:	e0 93 ad 00 	sts	0x00AD, r30
		UPIENX  = UPIENXTemp;
    585a:	70 93 ae 00 	sts	0x00AE, r23

			/** Configures the currently selected pipe to allow for an unlimited number of IN requests. */
			static inline void Pipe_SetInfiniteINRequests(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetInfiniteINRequests(void)
			{
				UPCONX |= (1 << INMODE);
    585e:	80 91 a9 00 	lds	r24, 0x00A9
    5862:	80 62       	ori	r24, 0x20	; 32
    5864:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    5868:	80 91 ac 00 	lds	r24, 0x00AC

		Pipe_SetInfiniteINRequests();

		if (!(Pipe_IsConfigured()))
    586c:	87 ff       	sbrs	r24, 7
    586e:	09 c0       	rjmp	.+18     	; 0x5882 <Pipe_ConfigurePipe+0xc8>

	Pipe_SetInfiniteINRequests();

	return Pipe_IsConfigured();
#else
	for (uint8_t PNum = Number; PNum < PIPE_TOTAL_PIPES; PNum++)
    5870:	4f 5f       	subi	r20, 0xFF	; 255
    5872:	47 30       	cpi	r20, 0x07	; 7
    5874:	09 f0       	breq	.+2      	; 0x5878 <Pipe_ConfigurePipe+0xbe>
    5876:	b8 cf       	rjmp	.-144    	; 0x57e8 <Pipe_ConfigurePipe+0x2e>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    5878:	5f 70       	andi	r21, 0x0F	; 15
    587a:	50 93 a7 00 	sts	0x00A7, r21
		if (!(Pipe_IsConfigured()))
		  return false;
	}

	Pipe_SelectPipe(Number);
	return true;
    587e:	81 e0       	ldi	r24, 0x01	; 1
    5880:	01 c0       	rjmp	.+2      	; 0x5884 <Pipe_ConfigurePipe+0xca>
		UPIENX  = UPIENXTemp;

		Pipe_SetInfiniteINRequests();

		if (!(Pipe_IsConfigured()))
		  return false;
    5882:	80 e0       	ldi	r24, 0x00	; 0
	}

	Pipe_SelectPipe(Number);
	return true;
#endif
}
    5884:	0f 91       	pop	r16
    5886:	08 95       	ret

00005888 <Pipe_ConfigurePipeTable>:

uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
    5888:	ef 92       	push	r14
    588a:	ff 92       	push	r15
    588c:	0f 93       	push	r16
    588e:	1f 93       	push	r17
    5890:	cf 93       	push	r28
    5892:	df 93       	push	r29
    5894:	16 2f       	mov	r17, r22
		{
			return false;
		}
	}
	
	return true;
    5896:	e8 2e       	mov	r14, r24
    5898:	e7 01       	movw	r28, r14
    589a:	7e 01       	movw	r14, r28
    589c:	f9 2e       	mov	r15, r25
    589e:	e7 01       	movw	r28, r14
uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    58a0:	ff 24       	eor	r15, r15
    58a2:	0d c0       	rjmp	.+26     	; 0x58be <Pipe_ConfigurePipeTable+0x36>
	{
		if (!(Table[i].Address))
    58a4:	88 81       	ld	r24, Y
    58a6:	88 23       	and	r24, r24
    58a8:	41 f0       	breq	.+16     	; 0x58ba <Pipe_ConfigurePipeTable+0x32>
		  continue;
	
		if (!(Pipe_ConfigurePipe(Table[i].Address, Table[i].Type, Table[i].EndpointAddress, Table[i].Size, Table[i].Banks)))
    58aa:	29 81       	ldd	r18, Y+1	; 0x01
    58ac:	3a 81       	ldd	r19, Y+2	; 0x02
    58ae:	6c 81       	ldd	r22, Y+4	; 0x04
    58b0:	4b 81       	ldd	r20, Y+3	; 0x03
    58b2:	0d 81       	ldd	r16, Y+5	; 0x05
    58b4:	82 df       	rcall	.-252    	; 0x57ba <Pipe_ConfigurePipe>
    58b6:	88 23       	and	r24, r24
    58b8:	31 f0       	breq	.+12     	; 0x58c6 <Pipe_ConfigurePipeTable+0x3e>
uint8_t USB_Host_ControlPipeSize = PIPE_CONTROLPIPE_DEFAULT_SIZE;

bool Pipe_ConfigurePipeTable(const USB_Pipe_Table_t* const Table,
                             const uint8_t Entries)
{
	for (uint8_t i = 0; i < Entries; i++)
    58ba:	f3 94       	inc	r15
    58bc:	26 96       	adiw	r28, 0x06	; 6
    58be:	f1 16       	cp	r15, r17
    58c0:	88 f3       	brcs	.-30     	; 0x58a4 <Pipe_ConfigurePipeTable+0x1c>
		{
			return false;
		}
	}
	
	return true;
    58c2:	81 e0       	ldi	r24, 0x01	; 1
    58c4:	01 c0       	rjmp	.+2      	; 0x58c8 <Pipe_ConfigurePipeTable+0x40>
		if (!(Table[i].Address))
		  continue;
	
		if (!(Pipe_ConfigurePipe(Table[i].Address, Table[i].Type, Table[i].EndpointAddress, Table[i].Size, Table[i].Banks)))
		{
			return false;
    58c6:	80 e0       	ldi	r24, 0x00	; 0
		}
	}
	
	return true;
}
    58c8:	df 91       	pop	r29
    58ca:	cf 91       	pop	r28
    58cc:	1f 91       	pop	r17
    58ce:	0f 91       	pop	r16
    58d0:	ff 90       	pop	r15
    58d2:	ef 90       	pop	r14
    58d4:	08 95       	ret

000058d6 <Pipe_ClearPipes>:
#endif
}

void Pipe_ClearPipes(void)
{
	UPINT = 0;
    58d6:	10 92 f8 00 	sts	0x00F8, r1

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    58da:	80 e0       	ldi	r24, 0x00	; 0
    58dc:	98 2f       	mov	r25, r24
    58de:	9f 70       	andi	r25, 0x0F	; 15
    58e0:	90 93 a7 00 	sts	0x00A7, r25
	{
		Pipe_SelectPipe(PNum);
		UPIENX  = 0;
    58e4:	10 92 ae 00 	sts	0x00AE, r1
		UPINTX  = 0;
    58e8:	10 92 a6 00 	sts	0x00A6, r1
		UPCFG1X = 0;
    58ec:	10 92 ab 00 	sts	0x00AB, r1
			 *  from an attached device.
			 */
			static inline void Pipe_DisablePipe(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_DisablePipe(void)
			{
				UPCONX &= ~(1 << PEN);
    58f0:	90 91 a9 00 	lds	r25, 0x00A9
    58f4:	9e 7f       	andi	r25, 0xFE	; 254
    58f6:	90 93 a9 00 	sts	0x00A9, r25

void Pipe_ClearPipes(void)
{
	UPINT = 0;

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    58fa:	8f 5f       	subi	r24, 0xFF	; 255
    58fc:	87 30       	cpi	r24, 0x07	; 7
    58fe:	71 f7       	brne	.-36     	; 0x58dc <Pipe_ClearPipes+0x6>
		UPIENX  = 0;
		UPINTX  = 0;
		UPCFG1X = 0;
		Pipe_DisablePipe();
	}
}
    5900:	08 95       	ret

00005902 <Pipe_IsEndpointBound>:
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    5902:	40 91 a7 00 	lds	r20, 0x00A7
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    5906:	90 91 aa 00 	lds	r25, 0x00AA

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    590a:	90 e0       	ldi	r25, 0x00	; 0
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    590c:	29 2f       	mov	r18, r25
    590e:	2f 70       	andi	r18, 0x0F	; 15
    5910:	20 93 a7 00 	sts	0x00A7, r18
			 *  \return Boolean \c true if the selected pipe is configured, \c false otherwise.
			 */
			static inline bool Pipe_IsConfigured(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsConfigured(void)
			{
				return ((UPSTAX & (1 << CFGOK)) ? true : false);
    5914:	20 91 ac 00 	lds	r18, 0x00AC
	{
		Pipe_SelectPipe(PNum);

		if (!(Pipe_IsConfigured()))
    5918:	27 ff       	sbrs	r18, 7
    591a:	0c c0       	rjmp	.+24     	; 0x5934 <Pipe_IsEndpointBound+0x32>
			 *  \return Endpoint address the currently selected pipe is bound to.
			 */
			static inline uint8_t Pipe_GetBoundEndpointAddress(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetBoundEndpointAddress(void)
			{
				uint8_t UPCFG0X_Temp = UPCFG0X;
    591c:	30 91 aa 00 	lds	r19, 0x00AA
				
				return (((UPCFG0X_Temp >> PEPNUM0) & PIPE_EPNUM_MASK) | ((UPCFG0X_Temp & PEPNUM1) ? ENDPOINT_DIR_OUT : ENDPOINT_DIR_IN));
    5920:	53 2f       	mov	r21, r19
    5922:	5f 70       	andi	r21, 0x0F	; 15
    5924:	30 ff       	sbrs	r19, 0
    5926:	02 c0       	rjmp	.+4      	; 0x592c <Pipe_IsEndpointBound+0x2a>
    5928:	20 e0       	ldi	r18, 0x00	; 0
    592a:	01 c0       	rjmp	.+2      	; 0x592e <Pipe_IsEndpointBound+0x2c>
    592c:	20 e8       	ldi	r18, 0x80	; 128
    592e:	25 2b       	or	r18, r21
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
    5930:	28 17       	cp	r18, r24
    5932:	49 f0       	breq	.+18     	; 0x5946 <Pipe_IsEndpointBound+0x44>

bool Pipe_IsEndpointBound(const uint8_t EndpointAddress)
{
	uint8_t PrevPipeNumber = Pipe_GetCurrentPipe();

	for (uint8_t PNum = 0; PNum < PIPE_TOTAL_PIPES; PNum++)
    5934:	9f 5f       	subi	r25, 0xFF	; 255
    5936:	97 30       	cpi	r25, 0x07	; 7
    5938:	49 f7       	brne	.-46     	; 0x590c <Pipe_IsEndpointBound+0xa>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    593a:	84 2f       	mov	r24, r20
    593c:	8f 70       	andi	r24, 0x0F	; 15
    593e:	80 93 a7 00 	sts	0x00A7, r24
		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
    5942:	80 e0       	ldi	r24, 0x00	; 0
    5944:	08 95       	ret

		if (!(Pipe_IsConfigured()))
		  continue;

		if (Pipe_GetBoundEndpointAddress() == EndpointAddress)
		  return true;
    5946:	81 e0       	ldi	r24, 0x01	; 1
	}

	Pipe_SelectPipe(PrevPipeNumber);
	return false;
}
    5948:	08 95       	ret

0000594a <Pipe_WaitUntilReady>:
			 *  \return Current USB frame number from the USB controller.
			 */
			static inline uint16_t USB_Host_GetFrameNumber(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t USB_Host_GetFrameNumber(void)
			{
				return UHFNUM;
    594a:	80 91 a2 00 	lds	r24, 0x00A2
    594e:	90 91 a3 00 	lds	r25, 0x00A3

uint8_t Pipe_WaitUntilReady(void)
{
	#if (USB_STREAM_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutMSRem = USB_STREAM_TIMEOUT_MS;
    5952:	44 e6       	ldi	r20, 0x64	; 100
			 *  \return The current pipe token, as a \c PIPE_TOKEN_* mask.
			 */
			static inline uint8_t Pipe_GetPipeToken(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeToken(void)
			{
				return (UPCFG0X & (0x03 << PTOKEN0));
    5954:	20 91 aa 00 	lds	r18, 0x00AA
    5958:	20 73       	andi	r18, 0x30	; 48

	uint16_t PreviousFrameNumber = USB_Host_GetFrameNumber();

	for (;;)
	{
		if (Pipe_GetPipeToken() == PIPE_TOKEN_IN)
    595a:	20 31       	cpi	r18, 0x10	; 16
    595c:	29 f4       	brne	.+10     	; 0x5968 <Pipe_WaitUntilReady+0x1e>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    595e:	20 91 a6 00 	lds	r18, 0x00A6
		{
			if (Pipe_IsINReceived())
    5962:	20 ff       	sbrs	r18, 0
    5964:	05 c0       	rjmp	.+10     	; 0x5970 <Pipe_WaitUntilReady+0x26>
    5966:	17 c0       	rjmp	.+46     	; 0x5996 <Pipe_WaitUntilReady+0x4c>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    5968:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
    596c:	22 fd       	sbrc	r18, 2
    596e:	13 c0       	rjmp	.+38     	; 0x5996 <Pipe_WaitUntilReady+0x4c>
			 *  \return Boolean \c true if the current pipe has been stalled by the attached device, \c false otherwise.
			 */
			static inline bool Pipe_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsStalled(void)
			{
				return ((UPINTX & (1 << RXSTALLI)) ? true : false);
    5970:	20 91 a6 00 	lds	r18, 0x00A6
			  return PIPE_READYWAIT_NoError;
		}

		if (Pipe_IsStalled())
    5974:	21 fd       	sbrc	r18, 1
    5976:	11 c0       	rjmp	.+34     	; 0x599a <Pipe_WaitUntilReady+0x50>
		  return PIPE_READYWAIT_PipeStalled;
		else if (USB_HostState == HOST_STATE_Unattached)
    5978:	2e b3       	in	r18, 0x1e	; 30
    597a:	21 30       	cpi	r18, 0x01	; 1
    597c:	81 f0       	breq	.+32     	; 0x599e <Pipe_WaitUntilReady+0x54>
    597e:	20 91 a2 00 	lds	r18, 0x00A2
    5982:	30 91 a3 00 	lds	r19, 0x00A3
		  return PIPE_READYWAIT_DeviceDisconnected;

		uint16_t CurrentFrameNumber = USB_Host_GetFrameNumber();

		if (CurrentFrameNumber != PreviousFrameNumber)
    5986:	28 17       	cp	r18, r24
    5988:	39 07       	cpc	r19, r25
    598a:	21 f3       	breq	.-56     	; 0x5954 <Pipe_WaitUntilReady+0xa>
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
    598c:	44 23       	and	r20, r20
    598e:	49 f0       	breq	.+18     	; 0x59a2 <Pipe_WaitUntilReady+0x58>
    5990:	41 50       	subi	r20, 0x01	; 1
    5992:	c9 01       	movw	r24, r18
    5994:	df cf       	rjmp	.-66     	; 0x5954 <Pipe_WaitUntilReady+0xa>
			  return PIPE_READYWAIT_NoError;
		}
		else
		{
			if (Pipe_IsOUTReady())
			  return PIPE_READYWAIT_NoError;
    5996:	80 e0       	ldi	r24, 0x00	; 0
    5998:	08 95       	ret
		}

		if (Pipe_IsStalled())
		  return PIPE_READYWAIT_PipeStalled;
    599a:	81 e0       	ldi	r24, 0x01	; 1
    599c:	08 95       	ret
		else if (USB_HostState == HOST_STATE_Unattached)
		  return PIPE_READYWAIT_DeviceDisconnected;
    599e:	82 e0       	ldi	r24, 0x02	; 2
    59a0:	08 95       	ret
		if (CurrentFrameNumber != PreviousFrameNumber)
		{
			PreviousFrameNumber = CurrentFrameNumber;

			if (!(TimeoutMSRem--))
			  return PIPE_READYWAIT_Timeout;
    59a2:	83 e0       	ldi	r24, 0x03	; 3
		}
	}
}
    59a4:	08 95       	ret

000059a6 <USB_Disable>:
	USB_ResetInterface();
}

void USB_Disable(void)
{
	USB_INT_DisableAllInterrupts();
    59a6:	cf d0       	rcall	.+414    	; 0x5b46 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    59a8:	da d0       	rcall	.+436    	; 0x5b5e <USB_INT_ClearAllInterrupts>
			 *  enumerating the device once attached until \ref USB_Attach() is called.
			 */
			static inline void USB_Detach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Detach(void)
			{
				UDCON  |=  (1 << DETACH);
    59aa:	e0 ee       	ldi	r30, 0xE0	; 224
    59ac:	f0 e0       	ldi	r31, 0x00	; 0
    59ae:	80 81       	ld	r24, Z
    59b0:	81 60       	ori	r24, 0x01	; 1
    59b2:	80 83       	st	Z, r24
			}

			static inline void USB_Controller_Disable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Disable(void)
			{
				USBCON &= ~(1 << USBE);
    59b4:	e8 ed       	ldi	r30, 0xD8	; 216
    59b6:	f0 e0       	ldi	r31, 0x00	; 0
    59b8:	80 81       	ld	r24, Z
    59ba:	8f 77       	andi	r24, 0x7F	; 127
    59bc:	80 83       	st	Z, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    59be:	19 bc       	out	0x29, r1	; 41

			static inline void USB_REG_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_Off(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON &= ~(1 << UVREGE);
    59c0:	a7 ed       	ldi	r26, 0xD7	; 215
    59c2:	b0 e0       	ldi	r27, 0x00	; 0
    59c4:	8c 91       	ld	r24, X
    59c6:	8e 7f       	andi	r24, 0xFE	; 254
    59c8:	8c 93       	st	X, r24
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    59ca:	80 81       	ld	r24, Z
    59cc:	8f 7e       	andi	r24, 0xEF	; 239
    59ce:	80 83       	st	Z, r24
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USB_OTGPAD_Off();
	#endif

	#if defined(USB_CAN_BE_BOTH)
	USB_CurrentMode = USB_MODE_None;
    59d0:	10 92 d9 03 	sts	0x03D9, r1
	#endif

	USB_IsInitialized = false;
    59d4:	10 92 ad 0d 	sts	0x0DAD, r1
}
    59d8:	08 95       	ret

000059da <USB_ResetInterface>:

void USB_ResetInterface(void)
{
    59da:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
	bool UIDModeSelectEnabled = ((UHWCON & (1 << UIDE)) != 0);
    59dc:	10 91 d7 00 	lds	r17, 0x00D7
	#endif

	USB_INT_DisableAllInterrupts();
    59e0:	b2 d0       	rcall	.+356    	; 0x5b46 <USB_INT_DisableAllInterrupts>
	USB_INT_ClearAllInterrupts();
    59e2:	bd d0       	rcall	.+378    	; 0x5b5e <USB_INT_ClearAllInterrupts>
			}

			static inline void USB_Controller_Reset(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Controller_Reset(void)
			{
				USBCON &= ~(1 << USBE);
    59e4:	80 91 d8 00 	lds	r24, 0x00D8
    59e8:	8f 77       	andi	r24, 0x7F	; 127
    59ea:	80 93 d8 00 	sts	0x00D8, r24
				USBCON |=  (1 << USBE);
    59ee:	80 91 d8 00 	lds	r24, 0x00D8
    59f2:	80 68       	ori	r24, 0x80	; 128
    59f4:	80 93 d8 00 	sts	0x00D8, r24

	USB_Controller_Reset();

	#if defined(USB_CAN_BE_BOTH)
	if (UIDModeSelectEnabled)
    59f8:	16 ff       	sbrs	r17, 6
    59fa:	05 c0       	rjmp	.+10     	; 0x5a06 <USB_ResetInterface+0x2c>
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    59fc:	80 91 d8 00 	lds	r24, 0x00D8
    5a00:	82 60       	ori	r24, 0x02	; 2
    5a02:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5a06:	80 91 d8 00 	lds	r24, 0x00D8
    5a0a:	8f 7d       	andi	r24, 0xDF	; 223
    5a0c:	80 93 d8 00 	sts	0x00D8, r24
	  USB_INT_Enable(USB_INT_IDTI);
	#endif

	USB_CLK_Unfreeze();

	if (USB_CurrentMode == USB_MODE_Device)
    5a10:	80 91 d9 03 	lds	r24, 0x03D9
    5a14:	81 30       	cpi	r24, 0x01	; 1
    5a16:	59 f5       	brne	.+86     	; 0x5a6e <USB_ResetInterface+0x94>
	{
		#if defined(USB_CAN_BE_DEVICE)
		#if (defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
		UHWCON |=  (1 << UIMOD);
    5a18:	80 91 d7 00 	lds	r24, 0x00D7
    5a1c:	80 68       	ori	r24, 0x80	; 128
    5a1e:	80 93 d7 00 	sts	0x00D7, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5a22:	19 bc       	out	0x29, r1	; 41
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_Init_Device(void)
{
	USB_DeviceState                 = DEVICE_STATE_Unattached;
    5a24:	1e ba       	out	0x1e, r1	; 30
	USB_Device_ConfigurationNumber  = 0;
    5a26:	10 92 a9 0d 	sts	0x0DA9, r1

	#if !defined(NO_DEVICE_REMOTE_WAKEUP)
	USB_Device_RemoteWakeupEnabled  = false;
    5a2a:	10 92 ab 0d 	sts	0x0DAB, r1
	#endif

	#if !defined(NO_DEVICE_SELF_POWER)
	USB_Device_CurrentlySelfPowered = false;
    5a2e:	10 92 aa 0d 	sts	0x0DAA, r1
			}

			static inline void USB_Device_SetFullSpeed(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetFullSpeed(void)
			{
				UDCON &= ~(1 << LSM);
    5a32:	80 91 e0 00 	lds	r24, 0x00E0
    5a36:	8b 7f       	andi	r24, 0xFB	; 251
    5a38:	80 93 e0 00 	sts	0x00E0, r24
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBCON |= (1 << VBUSTE);
    5a3c:	80 91 d8 00 	lds	r24, 0x00D8
    5a40:	81 60       	ori	r24, 0x01	; 1
    5a42:	80 93 d8 00 	sts	0x00D8, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5a46:	80 e0       	ldi	r24, 0x00	; 0
    5a48:	60 e0       	ldi	r22, 0x00	; 0
    5a4a:	42 e0       	ldi	r20, 0x02	; 2
    5a4c:	07 db       	rcall	.-2546   	; 0x505c <Endpoint_ConfigureEndpoint_Prv>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5a4e:	80 91 e1 00 	lds	r24, 0x00E1
    5a52:	8e 7f       	andi	r24, 0xFE	; 254
    5a54:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5a58:	80 91 e2 00 	lds	r24, 0x00E2
    5a5c:	81 60       	ori	r24, 0x01	; 1
    5a5e:	80 93 e2 00 	sts	0x00E2, r24
						break;
					case USB_INT_EORSTI:
						UDIEN  |= (1 << EORSTE);
    5a62:	80 91 e2 00 	lds	r24, 0x00E2
    5a66:	88 60       	ori	r24, 0x08	; 8
    5a68:	80 93 e2 00 	sts	0x00E2, r24
    5a6c:	37 c0       	rjmp	.+110    	; 0x5adc <USB_ResetInterface+0x102>
		}

		USB_Init_Device();
		#endif
	}
	else if (USB_CurrentMode == USB_MODE_Host)
    5a6e:	80 91 d9 03 	lds	r24, 0x03D9
    5a72:	82 30       	cpi	r24, 0x02	; 2
    5a74:	c1 f5       	brne	.+112    	; 0x5ae6 <USB_ResetInterface+0x10c>
	{
		#if defined(USB_CAN_BE_HOST)
		UHWCON &= ~(1 << UIMOD);
    5a76:	80 91 d7 00 	lds	r24, 0x00D7
    5a7a:	8f 77       	andi	r24, 0x7F	; 127
    5a7c:	80 93 d7 00 	sts	0x00D7, r24

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5a80:	8c e0       	ldi	r24, 0x0C	; 12
    5a82:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5a84:	8e e0       	ldi	r24, 0x0E	; 14
    5a86:	89 bd       	out	0x29, r24	; 41

		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			#if defined(USB_CAN_BE_HOST)
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    5a88:	09 b4       	in	r0, 0x29	; 41
    5a8a:	00 fe       	sbrs	r0, 0
    5a8c:	fd cf       	rjmp	.-6      	; 0x5a88 <USB_ResetInterface+0xae>
#endif

#if defined(USB_CAN_BE_HOST)
static void USB_Init_Host(void)
{
	USB_HostState                = HOST_STATE_Unattached;
    5a8e:	81 e0       	ldi	r24, 0x01	; 1
    5a90:	8e bb       	out	0x1e, r24	; 30
	USB_Host_ConfigurationNumber = 0;
    5a92:	10 92 ac 0d 	sts	0x0DAC, r1
	USB_Host_ControlPipeSize     = PIPE_CONTROLPIPE_DEFAULT_SIZE;
    5a96:	80 e4       	ldi	r24, 0x40	; 64
    5a98:	80 93 4d 03 	sts	0x034D, r24
	#if !defined(__DOXYGEN__)
		/* Macros: */
			static inline void USB_Host_HostMode_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_HostMode_On(void)
			{
				USBCON |=  (1 << HOST);
    5a9c:	80 91 d8 00 	lds	r24, 0x00D8
    5aa0:	80 64       	ori	r24, 0x40	; 64
    5aa2:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5aa6:	80 91 dd 00 	lds	r24, 0x00DD
    5aaa:	81 60       	ori	r24, 0x01	; 1
    5aac:	80 93 dd 00 	sts	0x00DD, r24
			}

			static inline void USB_Host_VBUS_Manual_Enable(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Manual_Enable(void)
			{
				OTGCON |=  (1 << VBUSHWC);
    5ab0:	80 91 dd 00 	lds	r24, 0x00DD
    5ab4:	84 60       	ori	r24, 0x04	; 4
    5ab6:	80 93 dd 00 	sts	0x00DD, r24
				UHWCON &= ~(1 << UVCONE);
    5aba:	80 91 d7 00 	lds	r24, 0x00D7
    5abe:	8f 7e       	andi	r24, 0xEF	; 239
    5ac0:	80 93 d7 00 	sts	0x00D7, r24

				DDRE   |=  (1 << 7);
    5ac4:	6f 9a       	sbi	0x0d, 7	; 13
			static inline void USB_Host_VBUS_Manual_On(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  &= ~(1 << 7);
				#else
				PORTE  |=  (1 << 7);
    5ac6:	77 9a       	sbi	0x0e, 7	; 14
						break;
					case USB_INT_VBERRI:
						OTGIEN |= (1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN |= (1 << SRPE);
    5ac8:	80 91 de 00 	lds	r24, 0x00DE
    5acc:	81 60       	ori	r24, 0x01	; 1
    5ace:	80 93 de 00 	sts	0x00DE, r24
						break;
					case USB_INT_RSTI:
						UHIEN  |= (1 << RSTE);
						break;
					case USB_INT_BCERRI:
						OTGIEN |= (1 << BCERRE);
    5ad2:	80 91 de 00 	lds	r24, 0x00DE
    5ad6:	84 60       	ori	r24, 0x04	; 4
    5ad8:	80 93 de 00 	sts	0x00DE, r24
			 *  register and despite the datasheet making no mention of its requirement in host mode.
			 */
			static inline void USB_Attach(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Attach(void)
			{
				UDCON  &= ~(1 << DETACH);
    5adc:	80 91 e0 00 	lds	r24, 0x00E0
    5ae0:	8e 7f       	andi	r24, 0xFE	; 254
    5ae2:	80 93 e0 00 	sts	0x00E0, r24

			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
			static inline void USB_OTGPAD_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_On(void)
			{
				USBCON |=  (1 << OTGPADE);
    5ae6:	80 91 d8 00 	lds	r24, 0x00D8
    5aea:	80 61       	ori	r24, 0x10	; 16
    5aec:	80 93 d8 00 	sts	0x00D8, r24
	}

	#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
	USB_OTGPAD_On();
	#endif
}
    5af0:	1f 91       	pop	r17
    5af2:	08 95       	ret

00005af4 <USB_Init>:
			}

			static inline void USB_OTGPAD_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_OTGPAD_Off(void)
			{
				USBCON &= ~(1 << OTGPADE);
    5af4:	90 91 d8 00 	lds	r25, 0x00D8
    5af8:	9f 7e       	andi	r25, 0xEF	; 239
    5afa:	90 93 d8 00 	sts	0x00D8, r25

			static inline void USB_REG_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_REG_On(void)
			{
			#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
				UHWCON |=  (1 << UVREGE);
    5afe:	90 91 d7 00 	lds	r25, 0x00D7
    5b02:	91 60       	ori	r25, 0x01	; 1
    5b04:	90 93 d7 00 	sts	0x00D7, r25
		PLLFRQ = (1 << PDIV2);
		#endif
	}

	#if defined(USB_CAN_BE_BOTH)
	if (Mode == USB_MODE_UID)
    5b08:	83 30       	cpi	r24, 0x03	; 3
    5b0a:	91 f4       	brne	.+36     	; 0x5b30 <USB_Init+0x3c>
	{
		UHWCON |=  (1 << UIDE);
    5b0c:	80 91 d7 00 	lds	r24, 0x00D7
    5b10:	80 64       	ori	r24, 0x40	; 64
    5b12:	80 93 d7 00 	sts	0x00D7, r24
						USBCON |= (1 << VBUSTE);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBCON |= (1 << IDTE);
    5b16:	80 91 d8 00 	lds	r24, 0x00D8
    5b1a:	82 60       	ori	r24, 0x02	; 2
    5b1c:	80 93 d8 00 	sts	0x00D8, r24

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5b20:	80 91 d9 00 	lds	r24, 0x00D9
    5b24:	81 ff       	sbrs	r24, 1
    5b26:	02 c0       	rjmp	.+4      	; 0x5b2c <USB_Init+0x38>
				  return USB_MODE_Device;
    5b28:	81 e0       	ldi	r24, 0x01	; 1
    5b2a:	07 c0       	rjmp	.+14     	; 0x5b3a <USB_Init+0x46>
				else
				  return USB_MODE_Host;
    5b2c:	82 e0       	ldi	r24, 0x02	; 2
    5b2e:	05 c0       	rjmp	.+10     	; 0x5b3a <USB_Init+0x46>
		USB_INT_Enable(USB_INT_IDTI);
		USB_CurrentMode = USB_GetUSBModeFromUID();
	}
	else
	{
		UHWCON &= ~(1 << UIDE);
    5b30:	90 91 d7 00 	lds	r25, 0x00D7
    5b34:	9f 7b       	andi	r25, 0xBF	; 191
    5b36:	90 93 d7 00 	sts	0x00D7, r25
		USB_CurrentMode = Mode;
    5b3a:	80 93 d9 03 	sts	0x03D9, r24
	}
	#endif

	USB_IsInitialized = true;
    5b3e:	81 e0       	ldi	r24, 0x01	; 1
    5b40:	80 93 ad 0d 	sts	0x0DAD, r24

	USB_ResetInterface();
}
    5b44:	4a cf       	rjmp	.-364    	; 0x59da <USB_ResetInterface>

00005b46 <USB_INT_DisableAllInterrupts>:
#include "../USBInterrupt.h"

void USB_INT_DisableAllInterrupts(void)
{
	#if defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBCON &= ~((1 << VBUSTE) | (1 << IDTE));
    5b46:	e8 ed       	ldi	r30, 0xD8	; 216
    5b48:	f0 e0       	ldi	r31, 0x00	; 0
    5b4a:	80 81       	ld	r24, Z
    5b4c:	8c 7f       	andi	r24, 0xFC	; 252
    5b4e:	80 83       	st	Z, r24
	#elif defined(USB_SERIES_4_AVR)
	USBCON &= ~(1 << VBUSTE);
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGIEN  = 0;
    5b50:	10 92 de 00 	sts	0x00DE, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHIEN   = 0;
    5b54:	10 92 a0 00 	sts	0x00A0, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDIEN   = 0;
    5b58:	10 92 e2 00 	sts	0x00E2, r1
	#endif
}
    5b5c:	08 95       	ret

00005b5e <USB_INT_ClearAllInterrupts>:

void USB_INT_ClearAllInterrupts(void)
{
	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	USBINT = 0;
    5b5e:	10 92 da 00 	sts	0x00DA, r1
	#endif

	#if defined(USB_CAN_BE_BOTH)
	OTGINT = 0;
    5b62:	10 92 df 00 	sts	0x00DF, r1
	#endif

	#if defined(USB_CAN_BE_HOST)
	UHINT  = 0;
    5b66:	10 92 9f 00 	sts	0x009F, r1
	#endif

	#if defined(USB_CAN_BE_DEVICE)
	UDINT  = 0;
    5b6a:	10 92 e1 00 	sts	0x00E1, r1
	#endif
}
    5b6e:	08 95       	ret

00005b70 <__vector_10>:

ISR(USB_GEN_vect, ISR_BLOCK)
{
    5b70:	1f 92       	push	r1
    5b72:	0f 92       	push	r0
    5b74:	0f b6       	in	r0, 0x3f	; 63
    5b76:	0f 92       	push	r0
    5b78:	0b b6       	in	r0, 0x3b	; 59
    5b7a:	0f 92       	push	r0
    5b7c:	11 24       	eor	r1, r1
    5b7e:	2f 93       	push	r18
    5b80:	3f 93       	push	r19
    5b82:	4f 93       	push	r20
    5b84:	5f 93       	push	r21
    5b86:	6f 93       	push	r22
    5b88:	7f 93       	push	r23
    5b8a:	8f 93       	push	r24
    5b8c:	9f 93       	push	r25
    5b8e:	af 93       	push	r26
    5b90:	bf 93       	push	r27
    5b92:	ef 93       	push	r30
    5b94:	ff 93       	push	r31
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
					case USB_INT_SOFI:
						return (UDINT  & (1 << SOFI));
    5b96:	80 91 e1 00 	lds	r24, 0x00E1
	#if defined(USB_CAN_BE_DEVICE)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_SOFI) && USB_INT_IsEnabled(USB_INT_SOFI))
    5b9a:	82 ff       	sbrs	r24, 2
    5b9c:	0a c0       	rjmp	.+20     	; 0x5bb2 <__vector_10+0x42>
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
					case USB_INT_SOFI:
						return (UDIEN  & (1 << SOFE));
    5b9e:	80 91 e2 00 	lds	r24, 0x00E2
    5ba2:	82 ff       	sbrs	r24, 2
    5ba4:	06 c0       	rjmp	.+12     	; 0x5bb2 <__vector_10+0x42>
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
						break;
					case USB_INT_SOFI:
						UDINT  &= ~(1 << SOFI);
    5ba6:	80 91 e1 00 	lds	r24, 0x00E1
    5baa:	8b 7f       	andi	r24, 0xFB	; 251
    5bac:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_SOFI);

		EVENT_USB_Device_StartOfFrame();
    5bb0:	7d d3       	rcall	.+1786   	; 0x62ac <USB_Event_Stub>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
    5bb2:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR)
	if (USB_INT_HasOccurred(USB_INT_VBUSTI) && USB_INT_IsEnabled(USB_INT_VBUSTI))
    5bb6:	80 ff       	sbrs	r24, 0
    5bb8:	1d c0       	rjmp	.+58     	; 0x5bf4 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
    5bba:	80 91 d8 00 	lds	r24, 0x00D8
    5bbe:	80 ff       	sbrs	r24, 0
    5bc0:	19 c0       	rjmp	.+50     	; 0x5bf4 <__vector_10+0x84>
			{
				switch (Interrupt)
				{
					#if (defined(USB_SERIES_4_AVR) || defined(USB_SERIES_6_AVR) || defined(USB_SERIES_7_AVR))
					case USB_INT_VBUSTI:
						USBINT &= ~(1 << VBUSTI);
    5bc2:	80 91 da 00 	lds	r24, 0x00DA
    5bc6:	8e 7f       	andi	r24, 0xFE	; 254
    5bc8:	80 93 da 00 	sts	0x00DA, r24
				 *  \return Boolean \c true if the VBUS line is currently detecting power from a host, \c false otherwise.
				 */
				static inline bool USB_VBUS_GetStatus(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
				static inline bool USB_VBUS_GetStatus(void)
				{
					return ((USBSTA & (1 << VBUS)) ? true : false);
    5bcc:	80 91 d9 00 	lds	r24, 0x00D9
	{
		USB_INT_Clear(USB_INT_VBUSTI);

		if (USB_VBUS_GetStatus())
    5bd0:	80 ff       	sbrs	r24, 0
    5bd2:	0c c0       	rjmp	.+24     	; 0x5bec <__vector_10+0x7c>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5bd4:	8c e0       	ldi	r24, 0x0C	; 12
    5bd6:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5bd8:	8e e0       	ldi	r24, 0x0E	; 14
    5bda:	89 bd       	out	0x29, r24	; 41
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			{
				USB_PLL_On();
				while (!(USB_PLL_IsReady()));
    5bdc:	09 b4       	in	r0, 0x29	; 41
    5bde:	00 fe       	sbrs	r0, 0
    5be0:	fd cf       	rjmp	.-6      	; 0x5bdc <__vector_10+0x6c>
			}

			USB_DeviceState = DEVICE_STATE_Powered;
    5be2:	81 e0       	ldi	r24, 0x01	; 1
    5be4:	8e bb       	out	0x1e, r24	; 30
			EVENT_USB_Device_Connect();
    5be6:	0e 94 a7 02 	call	0x54e	; 0x54e <EVENT_USB_Device_Connect>
    5bea:	04 c0       	rjmp	.+8      	; 0x5bf4 <__vector_10+0x84>
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5bec:	19 bc       	out	0x29, r1	; 41
		else
		{
			if (!(USB_Options & USB_OPT_MANUAL_PLL))
			  USB_PLL_Off();

			USB_DeviceState = DEVICE_STATE_Unattached;
    5bee:	1e ba       	out	0x1e, r1	; 30
			EVENT_USB_Device_Disconnect();
    5bf0:	0e 94 aa 02 	call	0x554	; 0x554 <EVENT_USB_Device_Disconnect>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
    5bf4:	80 91 e1 00 	lds	r24, 0x00E1
		}
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_SUSPI) && USB_INT_IsEnabled(USB_INT_SUSPI))
    5bf8:	80 ff       	sbrs	r24, 0
    5bfa:	17 c0       	rjmp	.+46     	; 0x5c2a <__vector_10+0xba>
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
    5bfc:	80 91 e2 00 	lds	r24, 0x00E2
    5c00:	80 ff       	sbrs	r24, 0
    5c02:	13 c0       	rjmp	.+38     	; 0x5c2a <__vector_10+0xba>
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5c04:	80 91 e2 00 	lds	r24, 0x00E2
    5c08:	8e 7f       	andi	r24, 0xFE	; 254
    5c0a:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5c0e:	80 91 e2 00 	lds	r24, 0x00E2
    5c12:	80 61       	ori	r24, 0x10	; 16
    5c14:	80 93 e2 00 	sts	0x00E2, r24
			#endif

			static inline void USB_CLK_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Freeze(void)
			{
				USBCON |=  (1 << FRZCLK);
    5c18:	80 91 d8 00 	lds	r24, 0x00D8
    5c1c:	80 62       	ori	r24, 0x20	; 32
    5c1e:	80 93 d8 00 	sts	0x00D8, r24
			}

			static inline void USB_PLL_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_Off(void)
			{
				PLLCSR = 0;
    5c22:	19 bc       	out	0x29, r1	; 41

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		USB_DeviceState = DEVICE_STATE_Unattached;
		EVENT_USB_Device_Disconnect();
		#else
		USB_DeviceState = DEVICE_STATE_Suspended;
    5c24:	85 e0       	ldi	r24, 0x05	; 5
    5c26:	8e bb       	out	0x1e, r24	; 30
		EVENT_USB_Device_Suspend();
    5c28:	41 d3       	rcall	.+1666   	; 0x62ac <USB_Event_Stub>
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
    5c2a:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_WAKEUPI) && USB_INT_IsEnabled(USB_INT_WAKEUPI))
    5c2e:	84 ff       	sbrs	r24, 4
    5c30:	2c c0       	rjmp	.+88     	; 0x5c8a <__vector_10+0x11a>
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
    5c32:	80 91 e2 00 	lds	r24, 0x00E2
    5c36:	84 ff       	sbrs	r24, 4
    5c38:	28 c0       	rjmp	.+80     	; 0x5c8a <__vector_10+0x11a>

		/* Inline Functions: */
			static inline void USB_PLL_On(void) ATTR_ALWAYS_INLINE;
			static inline void USB_PLL_On(void)
			{
				PLLCSR = USB_PLL_PSC;
    5c3a:	8c e0       	ldi	r24, 0x0C	; 12
    5c3c:	89 bd       	out	0x29, r24	; 41
				PLLCSR = (USB_PLL_PSC | (1 << PLLE));
    5c3e:	8e e0       	ldi	r24, 0x0E	; 14
    5c40:	89 bd       	out	0x29, r24	; 41
	{
		if (!(USB_Options & USB_OPT_MANUAL_PLL))
		{
			USB_PLL_On();
			while (!(USB_PLL_IsReady()));
    5c42:	09 b4       	in	r0, 0x29	; 41
    5c44:	00 fe       	sbrs	r0, 0
    5c46:	fd cf       	rjmp	.-6      	; 0x5c42 <__vector_10+0xd2>
			}

			static inline void USB_CLK_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void USB_CLK_Unfreeze(void)
			{
				USBCON &= ~(1 << FRZCLK);
    5c48:	80 91 d8 00 	lds	r24, 0x00D8
    5c4c:	8f 7d       	andi	r24, 0xDF	; 223
    5c4e:	80 93 d8 00 	sts	0x00D8, r24
						USBINT &= ~(1 << IDTI);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
    5c52:	80 91 e1 00 	lds	r24, 0x00E1
    5c56:	8f 7e       	andi	r24, 0xEF	; 239
    5c58:	80 93 e1 00 	sts	0x00E1, r24
						USBCON &= ~(1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
    5c5c:	80 91 e2 00 	lds	r24, 0x00E2
    5c60:	8f 7e       	andi	r24, 0xEF	; 239
    5c62:	80 93 e2 00 	sts	0x00E2, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  |= (1 << SUSPE);
    5c66:	80 91 e2 00 	lds	r24, 0x00E2
    5c6a:	81 60       	ori	r24, 0x01	; 1
    5c6c:	80 93 e2 00 	sts	0x00E2, r24
		USB_INT_Clear(USB_INT_WAKEUPI);

		USB_INT_Disable(USB_INT_WAKEUPI);
		USB_INT_Enable(USB_INT_SUSPI);

		if (USB_Device_ConfigurationNumber)
    5c70:	80 91 a9 0d 	lds	r24, 0x0DA9
    5c74:	88 23       	and	r24, r24
    5c76:	21 f4       	brne	.+8      	; 0x5c80 <__vector_10+0x110>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    5c78:	80 91 e3 00 	lds	r24, 0x00E3
		  USB_DeviceState = DEVICE_STATE_Configured;
		else
		  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    5c7c:	87 ff       	sbrs	r24, 7
    5c7e:	02 c0       	rjmp	.+4      	; 0x5c84 <__vector_10+0x114>
    5c80:	84 e0       	ldi	r24, 0x04	; 4
    5c82:	01 c0       	rjmp	.+2      	; 0x5c86 <__vector_10+0x116>
    5c84:	81 e0       	ldi	r24, 0x01	; 1
    5c86:	8e bb       	out	0x1e, r24	; 30

		#if defined(USB_SERIES_2_AVR) && !defined(NO_LIMITED_CONTROLLER_CONNECT)
		EVENT_USB_Device_Connect();
		#else
		EVENT_USB_Device_WakeUp();
    5c88:	11 d3       	rcall	.+1570   	; 0x62ac <USB_Event_Stub>
					case USB_INT_WAKEUPI:
						return (UDINT  & (1 << WAKEUPI));
					case USB_INT_SUSPI:
						return (UDINT  & (1 << SUSPI));
					case USB_INT_EORSTI:
						return (UDINT  & (1 << EORSTI));
    5c8a:	80 91 e1 00 	lds	r24, 0x00E1
		#endif
	}

	if (USB_INT_HasOccurred(USB_INT_EORSTI) && USB_INT_IsEnabled(USB_INT_EORSTI))
    5c8e:	83 ff       	sbrs	r24, 3
    5c90:	26 c0       	rjmp	.+76     	; 0x5cde <__vector_10+0x16e>
					case USB_INT_WAKEUPI:
						return (UDIEN  & (1 << WAKEUPE));
					case USB_INT_SUSPI:
						return (UDIEN  & (1 << SUSPE));
					case USB_INT_EORSTI:
						return (UDIEN  & (1 << EORSTE));
    5c92:	80 91 e2 00 	lds	r24, 0x00E2
    5c96:	83 ff       	sbrs	r24, 3
    5c98:	22 c0       	rjmp	.+68     	; 0x5cde <__vector_10+0x16e>
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
						break;
					case USB_INT_EORSTI:
						UDINT  &= ~(1 << EORSTI);
    5c9a:	80 91 e1 00 	lds	r24, 0x00E1
    5c9e:	87 7f       	andi	r24, 0xF7	; 247
    5ca0:	80 93 e1 00 	sts	0x00E1, r24
	{
		USB_INT_Clear(USB_INT_EORSTI);

		USB_DeviceState                = DEVICE_STATE_Default;
    5ca4:	82 e0       	ldi	r24, 0x02	; 2
    5ca6:	8e bb       	out	0x1e, r24	; 30
		USB_Device_ConfigurationNumber = 0;
    5ca8:	10 92 a9 0d 	sts	0x0DA9, r1
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDINT  &= ~(1 << WAKEUPI);
						break;
					case USB_INT_SUSPI:
						UDINT  &= ~(1 << SUSPI);
    5cac:	80 91 e1 00 	lds	r24, 0x00E1
    5cb0:	8e 7f       	andi	r24, 0xFE	; 254
    5cb2:	80 93 e1 00 	sts	0x00E1, r24
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  &= ~(1 << WAKEUPE);
						break;
					case USB_INT_SUSPI:
						UDIEN  &= ~(1 << SUSPE);
    5cb6:	80 91 e2 00 	lds	r24, 0x00E2
    5cba:	8e 7f       	andi	r24, 0xFE	; 254
    5cbc:	80 93 e2 00 	sts	0x00E2, r24
						USBCON |= (1 << IDTE);
						break;
					#endif
					#if defined(USB_CAN_BE_DEVICE)
					case USB_INT_WAKEUPI:
						UDIEN  |= (1 << WAKEUPE);
    5cc0:	80 91 e2 00 	lds	r24, 0x00E2
    5cc4:	80 61       	ori	r24, 0x10	; 16
    5cc6:	80 93 e2 00 	sts	0x00E2, r24
				uint8_t Number = (Address & ENDPOINT_EPNUM_MASK);

				if (Number >= ENDPOINT_TOTAL_ENDPOINTS)
				  return false;

				return Endpoint_ConfigureEndpoint_Prv(Number,
    5cca:	80 e0       	ldi	r24, 0x00	; 0
    5ccc:	60 e0       	ldi	r22, 0x00	; 0
    5cce:	42 e0       	ldi	r20, 0x02	; 2
    5cd0:	c5 d9       	rcall	.-3190   	; 0x505c <Endpoint_ConfigureEndpoint_Prv>
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5cd2:	80 91 f0 00 	lds	r24, 0x00F0
    5cd6:	88 60       	ori	r24, 0x08	; 8
    5cd8:	80 93 f0 00 	sts	0x00F0, r24

		#if defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_INT_Enable(USB_INT_RXSTPI);
		#endif

		EVENT_USB_Device_Reset();
    5cdc:	e7 d2       	rcall	.+1486   	; 0x62ac <USB_Event_Stub>
					case USB_INT_RXSTPI:
						return (UEINTX & (1 << RXSTPI));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
    5cde:	80 91 9f 00 	lds	r24, 0x009F
	}
	#endif

	#if defined(USB_CAN_BE_HOST)
	#if !defined(NO_SOF_EVENTS)
	if (USB_INT_HasOccurred(USB_INT_HSOFI) && USB_INT_IsEnabled(USB_INT_HSOFI))
    5ce2:	85 ff       	sbrs	r24, 5
    5ce4:	0a c0       	rjmp	.+20     	; 0x5cfa <__vector_10+0x18a>
					case USB_INT_RXSTPI:
						return (UEIENX & (1 << RXSTPE));
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
    5ce6:	80 91 a0 00 	lds	r24, 0x00A0
    5cea:	85 ff       	sbrs	r24, 5
    5cec:	06 c0       	rjmp	.+12     	; 0x5cfa <__vector_10+0x18a>
						UEINTX &= ~(1 << RXSTPI);
						break;
					#endif
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
    5cee:	80 91 9f 00 	lds	r24, 0x009F
    5cf2:	8f 7d       	andi	r24, 0xDF	; 223
    5cf4:	80 93 9f 00 	sts	0x009F, r24
	{
		USB_INT_Clear(USB_INT_HSOFI);

		EVENT_USB_Host_StartOfFrame();
    5cf8:	d9 d2       	rcall	.+1458   	; 0x62ac <USB_Event_Stub>
					case USB_INT_HSOFI:
						return (UHINT  & (1 << HSOFI));
					case USB_INT_DCONNI:
						return (UHINT  & (1 << DCONNI));
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
    5cfa:	80 91 9f 00 	lds	r24, 0x009F
	}
	#endif

	if (USB_INT_HasOccurred(USB_INT_DDISCI) && USB_INT_IsEnabled(USB_INT_DDISCI))
    5cfe:	81 ff       	sbrs	r24, 1
    5d00:	16 c0       	rjmp	.+44     	; 0x5d2e <__vector_10+0x1be>
					case USB_INT_HSOFI:
						return (UHIEN  & (1 << HSOFE));
					case USB_INT_DCONNI:
						return (UHIEN  & (1 << DCONNE));
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
    5d02:	80 91 a0 00 	lds	r24, 0x00A0
    5d06:	81 ff       	sbrs	r24, 1
    5d08:	12 c0       	rjmp	.+36     	; 0x5d2e <__vector_10+0x1be>
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
						break;
					case USB_INT_DDISCI:
						UHINT  &= ~(1 << DDISCI);
    5d0a:	80 91 9f 00 	lds	r24, 0x009F
    5d0e:	8d 7f       	andi	r24, 0xFD	; 253
    5d10:	80 93 9f 00 	sts	0x009F, r24
					#if defined(USB_CAN_BE_HOST)
					case USB_INT_HSOFI:
						UHINT  &= ~(1 << HSOFI);
						break;
					case USB_INT_DCONNI:
						UHINT  &= ~(1 << DCONNI);
    5d14:	80 91 9f 00 	lds	r24, 0x009F
    5d18:	8e 7f       	andi	r24, 0xFE	; 254
    5d1a:	80 93 9f 00 	sts	0x009F, r24
						break;
					case USB_INT_DCONNI:
						UHIEN  &= ~(1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  &= ~(1 << DDISCE);
    5d1e:	80 91 a0 00 	lds	r24, 0x00A0
    5d22:	8d 7f       	andi	r24, 0xFD	; 253
    5d24:	80 93 a0 00 	sts	0x00A0, r24
	{
		USB_INT_Clear(USB_INT_DDISCI);
		USB_INT_Clear(USB_INT_DCONNI);
		USB_INT_Disable(USB_INT_DDISCI);

		EVENT_USB_Host_DeviceUnattached();
    5d28:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5d2c:	56 de       	rcall	.-852    	; 0x59da <USB_ResetInterface>
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
    5d2e:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_VBERRI) && USB_INT_IsEnabled(USB_INT_VBERRI))
    5d32:	81 ff       	sbrs	r24, 1
    5d34:	16 c0       	rjmp	.+44     	; 0x5d62 <__vector_10+0x1f2>
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
    5d36:	80 91 de 00 	lds	r24, 0x00DE
    5d3a:	81 ff       	sbrs	r24, 1
    5d3c:	12 c0       	rjmp	.+36     	; 0x5d62 <__vector_10+0x1f2>
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
    5d3e:	80 91 df 00 	lds	r24, 0x00DF
    5d42:	8d 7f       	andi	r24, 0xFD	; 253
    5d44:	80 93 df 00 	sts	0x00DF, r24
			static inline void USB_Host_VBUS_Manual_Off(void)
			{
				#if defined(INVERTED_VBUS_ENABLE_LINE)
				PORTE  |=  (1 << 7);
				#else
				PORTE  &= ~(1 << 7);
    5d48:	77 98       	cbi	0x0e, 7	; 14
			}

			static inline void USB_Host_VBUS_Auto_Off(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_VBUS_Auto_Off(void)
			{
				OTGCON |=  (1 << VBUSRQC);
    5d4a:	80 91 dd 00 	lds	r24, 0x00DD
    5d4e:	81 60       	ori	r24, 0x01	; 1
    5d50:	80 93 dd 00 	sts	0x00DD, r24
		USB_INT_Clear(USB_INT_VBERRI);

		USB_Host_VBUS_Manual_Off();
		USB_Host_VBUS_Auto_Off();

		EVENT_USB_Host_HostError(HOST_ERROR_VBusVoltageDip);
    5d54:	80 e0       	ldi	r24, 0x00	; 0
    5d56:	0e 94 57 03 	call	0x6ae	; 0x6ae <EVENT_USB_Host_HostError>
		EVENT_USB_Host_DeviceUnattached();
    5d5a:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>

		USB_HostState = HOST_STATE_Unattached;
    5d5e:	81 e0       	ldi	r24, 0x01	; 1
    5d60:	8e bb       	out	0x1e, r24	; 30
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
					case USB_INT_VBERRI:
						return (OTGINT & (1 << VBERRI));
					case USB_INT_SRPI:
						return (OTGINT & (1 << SRPI));
    5d62:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_SRPI) && USB_INT_IsEnabled(USB_INT_SRPI))
    5d66:	80 ff       	sbrs	r24, 0
    5d68:	17 c0       	rjmp	.+46     	; 0x5d98 <__vector_10+0x228>
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
					case USB_INT_VBERRI:
						return (OTGIEN & (1 << VBERRE));
					case USB_INT_SRPI:
						return (OTGIEN & (1 << SRPE));
    5d6a:	80 91 de 00 	lds	r24, 0x00DE
    5d6e:	80 ff       	sbrs	r24, 0
    5d70:	13 c0       	rjmp	.+38     	; 0x5d98 <__vector_10+0x228>
						break;
					case USB_INT_VBERRI:
						OTGINT &= ~(1 << VBERRI);
						break;
					case USB_INT_SRPI:
						OTGINT &= ~(1 << SRPI);
    5d72:	80 91 df 00 	lds	r24, 0x00DF
    5d76:	8e 7f       	andi	r24, 0xFE	; 254
    5d78:	80 93 df 00 	sts	0x00DF, r24
						break;
					case USB_INT_VBERRI:
						OTGIEN &= ~(1 << VBERRE);
						break;
					case USB_INT_SRPI:
						OTGIEN &= ~(1 << SRPE);
    5d7c:	80 91 de 00 	lds	r24, 0x00DE
    5d80:	8e 7f       	andi	r24, 0xFE	; 254
    5d82:	80 93 de 00 	sts	0x00DE, r24
	{
		USB_INT_Clear(USB_INT_SRPI);
		USB_INT_Disable(USB_INT_SRPI);

		EVENT_USB_Host_DeviceAttached();
    5d86:	0e 94 e6 02 	call	0x5cc	; 0x5cc <EVENT_USB_Host_DeviceAttached>
						break;
					case USB_INT_DCONNI:
						UHIEN  |= (1 << DCONNE);
						break;
					case USB_INT_DDISCI:
						UHIEN  |= (1 << DDISCE);
    5d8a:	80 91 a0 00 	lds	r24, 0x00A0
    5d8e:	82 60       	ori	r24, 0x02	; 2
    5d90:	80 93 a0 00 	sts	0x00A0, r24

		USB_INT_Enable(USB_INT_DDISCI);

		USB_HostState = HOST_STATE_Powered;
    5d94:	82 e0       	ldi	r24, 0x02	; 2
    5d96:	8e bb       	out	0x1e, r24	; 30
					case USB_INT_DDISCI:
						return (UHINT  & (1 << DDISCI));
					case USB_INT_RSTI:
						return (UHINT  & (1 << RSTI));
					case USB_INT_BCERRI:
						return (OTGINT & (1 << BCERRI));
    5d98:	80 91 df 00 	lds	r24, 0x00DF
	}

	if (USB_INT_HasOccurred(USB_INT_BCERRI) && USB_INT_IsEnabled(USB_INT_BCERRI))
    5d9c:	82 ff       	sbrs	r24, 2
    5d9e:	10 c0       	rjmp	.+32     	; 0x5dc0 <__vector_10+0x250>
					case USB_INT_DDISCI:
						return (UHIEN  & (1 << DDISCE));
					case USB_INT_RSTI:
						return (UHIEN  & (1 << RSTE));
					case USB_INT_BCERRI:
						return (OTGIEN & (1 << BCERRE));
    5da0:	80 91 de 00 	lds	r24, 0x00DE
    5da4:	82 ff       	sbrs	r24, 2
    5da6:	0c c0       	rjmp	.+24     	; 0x5dc0 <__vector_10+0x250>
						break;
					case USB_INT_RSTI:
						UHINT  &= ~(1 << RSTI);
						break;
					case USB_INT_BCERRI:
						OTGINT &= ~(1 << BCERRI);
    5da8:	80 91 df 00 	lds	r24, 0x00DF
    5dac:	8b 7f       	andi	r24, 0xFB	; 251
    5dae:	80 93 df 00 	sts	0x00DF, r24
	{
		USB_INT_Clear(USB_INT_BCERRI);

		EVENT_USB_Host_DeviceEnumerationFailed(HOST_ENUMERROR_NoDeviceDetected, 0);
    5db2:	82 e0       	ldi	r24, 0x02	; 2
    5db4:	60 e0       	ldi	r22, 0x00	; 0
    5db6:	0e 94 5c 03 	call	0x6b8	; 0x6b8 <EVENT_USB_Host_DeviceEnumerationFailed>
		EVENT_USB_Host_DeviceUnattached();
    5dba:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>

		USB_ResetInterface();
    5dbe:	0d de       	rcall	.-998    	; 0x59da <USB_ResetInterface>
					case USB_INT_VBUSTI:
						return (USBINT & (1 << VBUSTI));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBINT & (1 << IDTI));
    5dc0:	80 91 da 00 	lds	r24, 0x00DA
	}
	#endif

	#if defined(USB_CAN_BE_BOTH)
	if (USB_INT_HasOccurred(USB_INT_IDTI) && USB_INT_IsEnabled(USB_INT_IDTI))
    5dc4:	81 ff       	sbrs	r24, 1
    5dc6:	1e c0       	rjmp	.+60     	; 0x5e04 <__vector_10+0x294>
					case USB_INT_VBUSTI:
						return (USBCON & (1 << VBUSTE));
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						return (USBCON & (1 << IDTE));
    5dc8:	80 91 d8 00 	lds	r24, 0x00D8
    5dcc:	81 ff       	sbrs	r24, 1
    5dce:	1a c0       	rjmp	.+52     	; 0x5e04 <__vector_10+0x294>
						USBINT &= ~(1 << VBUSTI);
						break;
					#endif
					#if defined(USB_CAN_BE_BOTH)
					case USB_INT_IDTI:
						USBINT &= ~(1 << IDTI);
    5dd0:	80 91 da 00 	lds	r24, 0x00DA
    5dd4:	8d 7f       	andi	r24, 0xFD	; 253
    5dd6:	80 93 da 00 	sts	0x00DA, r24
	{
		USB_INT_Clear(USB_INT_IDTI);

		if (USB_DeviceState != DEVICE_STATE_Unattached)
    5dda:	8e b3       	in	r24, 0x1e	; 30
    5ddc:	88 23       	and	r24, r24
    5dde:	11 f0       	breq	.+4      	; 0x5de4 <__vector_10+0x274>
		  EVENT_USB_Device_Disconnect();
    5de0:	0e 94 aa 02 	call	0x554	; 0x554 <EVENT_USB_Device_Disconnect>

		if (USB_HostState != HOST_STATE_Unattached)
    5de4:	8e b3       	in	r24, 0x1e	; 30
    5de6:	81 30       	cpi	r24, 0x01	; 1
    5de8:	11 f0       	breq	.+4      	; 0x5dee <__vector_10+0x27e>
		  EVENT_USB_Host_DeviceUnattached();
    5dea:	0e 94 e8 02 	call	0x5d0	; 0x5d0 <EVENT_USB_Host_DeviceUnattached>

			#if defined(USB_CAN_BE_BOTH)
			static inline uint8_t USB_GetUSBModeFromUID(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t USB_GetUSBModeFromUID(void)
			{
				if (USBSTA & (1 << ID))
    5dee:	80 91 d9 00 	lds	r24, 0x00D9
    5df2:	81 ff       	sbrs	r24, 1
    5df4:	02 c0       	rjmp	.+4      	; 0x5dfa <__vector_10+0x28a>
				  return USB_MODE_Device;
    5df6:	81 e0       	ldi	r24, 0x01	; 1
    5df8:	01 c0       	rjmp	.+2      	; 0x5dfc <__vector_10+0x28c>
				else
				  return USB_MODE_Host;
    5dfa:	82 e0       	ldi	r24, 0x02	; 2

		USB_CurrentMode = USB_GetUSBModeFromUID();
    5dfc:	80 93 d9 03 	sts	0x03D9, r24
		USB_ResetInterface();
    5e00:	ec dd       	rcall	.-1064   	; 0x59da <USB_ResetInterface>

		EVENT_USB_UIDChange();
    5e02:	54 d2       	rcall	.+1192   	; 0x62ac <USB_Event_Stub>
	}
	#endif
}
    5e04:	ff 91       	pop	r31
    5e06:	ef 91       	pop	r30
    5e08:	bf 91       	pop	r27
    5e0a:	af 91       	pop	r26
    5e0c:	9f 91       	pop	r25
    5e0e:	8f 91       	pop	r24
    5e10:	7f 91       	pop	r23
    5e12:	6f 91       	pop	r22
    5e14:	5f 91       	pop	r21
    5e16:	4f 91       	pop	r20
    5e18:	3f 91       	pop	r19
    5e1a:	2f 91       	pop	r18
    5e1c:	0f 90       	pop	r0
    5e1e:	0b be       	out	0x3b, r0	; 59
    5e20:	0f 90       	pop	r0
    5e22:	0f be       	out	0x3f, r0	; 63
    5e24:	0f 90       	pop	r0
    5e26:	1f 90       	pop	r1
    5e28:	18 95       	reti

00005e2a <__vector_11>:

#if defined(INTERRUPT_CONTROL_ENDPOINT) && defined(USB_CAN_BE_DEVICE)
ISR(USB_COM_vect, ISR_BLOCK)
{
    5e2a:	1f 92       	push	r1
    5e2c:	0f 92       	push	r0
    5e2e:	0f b6       	in	r0, 0x3f	; 63
    5e30:	0f 92       	push	r0
    5e32:	0b b6       	in	r0, 0x3b	; 59
    5e34:	0f 92       	push	r0
    5e36:	11 24       	eor	r1, r1
    5e38:	1f 93       	push	r17
    5e3a:	2f 93       	push	r18
    5e3c:	3f 93       	push	r19
    5e3e:	4f 93       	push	r20
    5e40:	5f 93       	push	r21
    5e42:	6f 93       	push	r22
    5e44:	7f 93       	push	r23
    5e46:	8f 93       	push	r24
    5e48:	9f 93       	push	r25
    5e4a:	af 93       	push	r26
    5e4c:	bf 93       	push	r27
    5e4e:	ef 93       	push	r30
    5e50:	ff 93       	push	r31
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    5e52:	10 91 e9 00 	lds	r17, 0x00E9
    5e56:	1f 70       	andi	r17, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    5e58:	80 91 ec 00 	lds	r24, 0x00EC
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    5e5c:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  &= ~(1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX &= ~(1 << RXSTPE);
    5e60:	80 91 f0 00 	lds	r24, 0x00F0
    5e64:	87 7f       	andi	r24, 0xF7	; 247
    5e66:	80 93 f0 00 	sts	0x00F0, r24
			static inline void GlobalInterruptEnable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				sei();
    5e6a:	78 94       	sei
	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Disable(USB_INT_RXSTPI);

	GlobalInterruptEnable();

	USB_Device_ProcessControlRequest();
    5e6c:	b7 d0       	rcall	.+366    	; 0x5fdc <USB_Device_ProcessControlRequest>
    5e6e:	10 92 e9 00 	sts	0x00E9, r1
						break;
					case USB_INT_SOFI:
						UDIEN  |= (1 << SOFE);
						break;
					case USB_INT_RXSTPI:
						UEIENX |= (1 << RXSTPE);
    5e72:	80 91 f0 00 	lds	r24, 0x00F0
    5e76:	88 60       	ori	r24, 0x08	; 8
    5e78:	80 93 f0 00 	sts	0x00F0, r24
    5e7c:	10 93 e9 00 	sts	0x00E9, r17

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);
	USB_INT_Enable(USB_INT_RXSTPI);
	Endpoint_SelectEndpoint(PrevSelectedEndpoint);
}
    5e80:	ff 91       	pop	r31
    5e82:	ef 91       	pop	r30
    5e84:	bf 91       	pop	r27
    5e86:	af 91       	pop	r26
    5e88:	9f 91       	pop	r25
    5e8a:	8f 91       	pop	r24
    5e8c:	7f 91       	pop	r23
    5e8e:	6f 91       	pop	r22
    5e90:	5f 91       	pop	r21
    5e92:	4f 91       	pop	r20
    5e94:	3f 91       	pop	r19
    5e96:	2f 91       	pop	r18
    5e98:	1f 91       	pop	r17
    5e9a:	0f 90       	pop	r0
    5e9c:	0b be       	out	0x3b, r0	; 59
    5e9e:	0f 90       	pop	r0
    5ea0:	0f be       	out	0x3f, r0	; 63
    5ea2:	0f 90       	pop	r0
    5ea4:	1f 90       	pop	r1
    5ea6:	18 95       	reti

00005ea8 <USB_Host_GetDeviceConfigDescriptor>:
#if defined(USB_CAN_BE_HOST)
uint8_t USB_Host_GetDeviceConfigDescriptor(const uint8_t ConfigNumber,
                                           uint16_t* const ConfigSizePtr,
                                           void* const BufferPtr,
                                           const uint16_t BufferSize)
{
    5ea8:	cf 92       	push	r12
    5eaa:	df 92       	push	r13
    5eac:	ef 92       	push	r14
    5eae:	ff 92       	push	r15
    5eb0:	0f 93       	push	r16
    5eb2:	1f 93       	push	r17
    5eb4:	df 93       	push	r29
    5eb6:	cf 93       	push	r28
    5eb8:	cd b7       	in	r28, 0x3d	; 61
    5eba:	de b7       	in	r29, 0x3e	; 62
    5ebc:	29 97       	sbiw	r28, 0x09	; 9
    5ebe:	0f b6       	in	r0, 0x3f	; 63
    5ec0:	f8 94       	cli
    5ec2:	de bf       	out	0x3e, r29	; 62
    5ec4:	0f be       	out	0x3f, r0	; 63
    5ec6:	cd bf       	out	0x3d, r28	; 61
    5ec8:	6b 01       	movw	r12, r22
    5eca:	8a 01       	movw	r16, r20
    5ecc:	79 01       	movw	r14, r18
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5ece:	90 e8       	ldi	r25, 0x80	; 128
    5ed0:	90 93 ae 0d 	sts	0x0DAE, r25
    5ed4:	96 e0       	ldi	r25, 0x06	; 6
    5ed6:	90 93 af 0d 	sts	0x0DAF, r25
		{
			.bmRequestType = (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE),
			.bRequest      = REQ_GetDescriptor,
			.wValue        = ((DTYPE_Configuration << 8) | (ConfigNumber - 1)),
    5eda:	90 e0       	ldi	r25, 0x00	; 0
    5edc:	01 97       	sbiw	r24, 0x01	; 1
    5ede:	92 60       	ori	r25, 0x02	; 2
                                           const uint16_t BufferSize)
{
	uint8_t ErrorCode;
	uint8_t ConfigHeader[sizeof(USB_Descriptor_Configuration_Header_t)];

	USB_ControlRequest = (USB_Request_Header_t)
    5ee0:	90 93 b1 0d 	sts	0x0DB1, r25
    5ee4:	80 93 b0 0d 	sts	0x0DB0, r24
    5ee8:	10 92 b3 0d 	sts	0x0DB3, r1
    5eec:	10 92 b2 0d 	sts	0x0DB2, r1
    5ef0:	89 e0       	ldi	r24, 0x09	; 9
    5ef2:	90 e0       	ldi	r25, 0x00	; 0
    5ef4:	90 93 b5 0d 	sts	0x0DB5, r25
    5ef8:	80 93 b4 0d 	sts	0x0DB4, r24
    5efc:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = sizeof(USB_Descriptor_Configuration_Header_t),
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(ConfigHeader)) != HOST_SENDCONTROL_Successful)
    5f00:	ce 01       	movw	r24, r28
    5f02:	01 96       	adiw	r24, 0x01	; 1
    5f04:	fe d1       	rcall	.+1020   	; 0x6302 <USB_Host_SendControlRequest>
    5f06:	88 23       	and	r24, r24
    5f08:	b9 f4       	brne	.+46     	; 0x5f38 <USB_Host_GetDeviceConfigDescriptor+0x90>
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);
    5f0a:	8b 81       	ldd	r24, Y+3	; 0x03
    5f0c:	9c 81       	ldd	r25, Y+4	; 0x04
    5f0e:	f6 01       	movw	r30, r12
    5f10:	91 83       	std	Z+1, r25	; 0x01
    5f12:	80 83       	st	Z, r24

	if (*ConfigSizePtr > BufferSize)
    5f14:	e8 16       	cp	r14, r24
    5f16:	f9 06       	cpc	r15, r25
    5f18:	70 f0       	brcs	.+28     	; 0x5f36 <USB_Host_GetDeviceConfigDescriptor+0x8e>
	  return HOST_GETCONFIG_BuffOverflow;

	USB_ControlRequest.wLength = *ConfigSizePtr;
    5f1a:	90 93 b5 0d 	sts	0x0DB5, r25
    5f1e:	80 93 b4 0d 	sts	0x0DB4, r24

	if ((ErrorCode = USB_Host_SendControlRequest(BufferPtr)) != HOST_SENDCONTROL_Successful)
    5f22:	c8 01       	movw	r24, r16
    5f24:	ee d1       	rcall	.+988    	; 0x6302 <USB_Host_SendControlRequest>
    5f26:	88 23       	and	r24, r24
    5f28:	39 f4       	brne	.+14     	; 0x5f38 <USB_Host_GetDeviceConfigDescriptor+0x90>
	  return ErrorCode;

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
    5f2a:	f8 01       	movw	r30, r16
    5f2c:	91 81       	ldd	r25, Z+1	; 0x01
    5f2e:	92 30       	cpi	r25, 0x02	; 2
    5f30:	19 f0       	breq	.+6      	; 0x5f38 <USB_Host_GetDeviceConfigDescriptor+0x90>
	  return HOST_GETCONFIG_InvalidData;
    5f32:	86 e0       	ldi	r24, 0x06	; 6
    5f34:	01 c0       	rjmp	.+2      	; 0x5f38 <USB_Host_GetDeviceConfigDescriptor+0x90>
	  return ErrorCode;

	*ConfigSizePtr = le16_to_cpu(DESCRIPTOR_PCAST(ConfigHeader, USB_Descriptor_Configuration_Header_t)->TotalConfigurationSize);

	if (*ConfigSizePtr > BufferSize)
	  return HOST_GETCONFIG_BuffOverflow;
    5f36:	85 e0       	ldi	r24, 0x05	; 5

	if (DESCRIPTOR_TYPE(BufferPtr) != DTYPE_Configuration)
	  return HOST_GETCONFIG_InvalidData;

	return HOST_GETCONFIG_Successful;
}
    5f38:	29 96       	adiw	r28, 0x09	; 9
    5f3a:	0f b6       	in	r0, 0x3f	; 63
    5f3c:	f8 94       	cli
    5f3e:	de bf       	out	0x3e, r29	; 62
    5f40:	0f be       	out	0x3f, r0	; 63
    5f42:	cd bf       	out	0x3d, r28	; 61
    5f44:	cf 91       	pop	r28
    5f46:	df 91       	pop	r29
    5f48:	1f 91       	pop	r17
    5f4a:	0f 91       	pop	r16
    5f4c:	ff 90       	pop	r15
    5f4e:	ef 90       	pop	r14
    5f50:	df 90       	pop	r13
    5f52:	cf 90       	pop	r12
    5f54:	08 95       	ret

00005f56 <USB_GetNextDescriptorComp>:
}

uint8_t USB_GetNextDescriptorComp(uint16_t* const BytesRem,
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
    5f56:	af 92       	push	r10
    5f58:	bf 92       	push	r11
    5f5a:	cf 92       	push	r12
    5f5c:	df 92       	push	r13
    5f5e:	ef 92       	push	r14
    5f60:	ff 92       	push	r15
    5f62:	0f 93       	push	r16
    5f64:	1f 93       	push	r17
    5f66:	cf 93       	push	r28
    5f68:	df 93       	push	r29
    5f6a:	8c 01       	movw	r16, r24
    5f6c:	eb 01       	movw	r28, r22
    5f6e:	6a 01       	movw	r12, r20
	uint8_t ErrorCode;

	while (*BytesRem)
    5f70:	23 c0       	rjmp	.+70     	; 0x5fb8 <USB_GetNextDescriptorComp+0x62>
	{
		uint8_t* PrevDescLoc  = *CurrConfigLoc;
    5f72:	e8 81       	ld	r30, Y
    5f74:	f9 81       	ldd	r31, Y+1	; 0x01
    5f76:	5f 01       	movw	r10, r30
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc) ATTR_NON_NULL_PTR_ARG(1) ATTR_NON_NULL_PTR_ARG(2);
			static inline void USB_GetNextDescriptor(uint16_t* const BytesRem,
			                                         void** CurrConfigLoc)
			{
				uint16_t CurrDescriptorSize = DESCRIPTOR_CAST(*CurrConfigLoc, USB_Descriptor_Header_t).Size;
    5f78:	20 81       	ld	r18, Z
    5f7a:	30 e0       	ldi	r19, 0x00	; 0
    5f7c:	c7 01       	movw	r24, r14
    5f7e:	2e 15       	cp	r18, r14
    5f80:	3f 05       	cpc	r19, r15
    5f82:	08 f4       	brcc	.+2      	; 0x5f86 <USB_GetNextDescriptorComp+0x30>
    5f84:	c9 01       	movw	r24, r18

				if (*BytesRem < CurrDescriptorSize)
				  CurrDescriptorSize = *BytesRem;

				*CurrConfigLoc  = (void*)((uintptr_t)*CurrConfigLoc + CurrDescriptorSize);
    5f86:	e8 0f       	add	r30, r24
    5f88:	f9 1f       	adc	r31, r25
    5f8a:	f9 83       	std	Y+1, r31	; 0x01
    5f8c:	e8 83       	st	Y, r30
				*BytesRem      -= CurrDescriptorSize;
    5f8e:	f8 01       	movw	r30, r16
    5f90:	20 81       	ld	r18, Z
    5f92:	31 81       	ldd	r19, Z+1	; 0x01
    5f94:	28 1b       	sub	r18, r24
    5f96:	39 0b       	sbc	r19, r25
    5f98:	31 83       	std	Z+1, r19	; 0x01
    5f9a:	20 83       	st	Z, r18
		uint16_t PrevBytesRem = *BytesRem;

		USB_GetNextDescriptor(BytesRem, CurrConfigLoc);

		if ((ErrorCode = ComparatorRoutine(*CurrConfigLoc)) != DESCRIPTOR_SEARCH_NotFound)
    5f9c:	88 81       	ld	r24, Y
    5f9e:	99 81       	ldd	r25, Y+1	; 0x01
    5fa0:	f6 01       	movw	r30, r12
    5fa2:	09 95       	icall
    5fa4:	82 30       	cpi	r24, 0x02	; 2
    5fa6:	41 f0       	breq	.+16     	; 0x5fb8 <USB_GetNextDescriptorComp+0x62>
		{
			if (ErrorCode == DESCRIPTOR_SEARCH_Fail)
    5fa8:	81 30       	cpi	r24, 0x01	; 1
    5faa:	69 f4       	brne	.+26     	; 0x5fc6 <USB_GetNextDescriptorComp+0x70>
			{
				*CurrConfigLoc = PrevDescLoc;
    5fac:	a8 82       	st	Y, r10
    5fae:	b9 82       	std	Y+1, r11	; 0x01
				*BytesRem      = PrevBytesRem;
    5fb0:	f8 01       	movw	r30, r16
    5fb2:	f1 82       	std	Z+1, r15	; 0x01
    5fb4:	e0 82       	st	Z, r14
    5fb6:	07 c0       	rjmp	.+14     	; 0x5fc6 <USB_GetNextDescriptorComp+0x70>
                                  void** const CurrConfigLoc,
                                  ConfigComparatorPtr_t const ComparatorRoutine)
{
	uint8_t ErrorCode;

	while (*BytesRem)
    5fb8:	f8 01       	movw	r30, r16
    5fba:	e0 80       	ld	r14, Z
    5fbc:	f1 80       	ldd	r15, Z+1	; 0x01
    5fbe:	e1 14       	cp	r14, r1
    5fc0:	f1 04       	cpc	r15, r1
    5fc2:	b9 f6       	brne	.-82     	; 0x5f72 <USB_GetNextDescriptorComp+0x1c>

			return ErrorCode;
		}
	}

	return DESCRIPTOR_SEARCH_COMP_EndOfDescriptor;
    5fc4:	82 e0       	ldi	r24, 0x02	; 2
}
    5fc6:	df 91       	pop	r29
    5fc8:	cf 91       	pop	r28
    5fca:	1f 91       	pop	r17
    5fcc:	0f 91       	pop	r16
    5fce:	ff 90       	pop	r15
    5fd0:	ef 90       	pop	r14
    5fd2:	df 90       	pop	r13
    5fd4:	cf 90       	pop	r12
    5fd6:	bf 90       	pop	r11
    5fd8:	af 90       	pop	r10
    5fda:	08 95       	ret

00005fdc <USB_Device_ProcessControlRequest>:
#if !defined(NO_DEVICE_REMOTE_WAKEUP)
bool    USB_Device_RemoteWakeupEnabled;
#endif

void USB_Device_ProcessControlRequest(void)
{
    5fdc:	1f 93       	push	r17
    5fde:	df 93       	push	r29
    5fe0:	cf 93       	push	r28
    5fe2:	cd b7       	in	r28, 0x3d	; 61
    5fe4:	de b7       	in	r29, 0x3e	; 62
    5fe6:	ac 97       	sbiw	r28, 0x2c	; 44
    5fe8:	0f b6       	in	r0, 0x3f	; 63
    5fea:	f8 94       	cli
    5fec:	de bf       	out	0x3e, r29	; 62
    5fee:	0f be       	out	0x3f, r0	; 63
    5ff0:	cd bf       	out	0x3d, r28	; 61
	USB_ControlRequest.bRequest      = Endpoint_Read_8();
	USB_ControlRequest.wValue        = Endpoint_Read_16_LE();
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;
    5ff2:	ee ea       	ldi	r30, 0xAE	; 174
    5ff4:	fd e0       	ldi	r31, 0x0D	; 13
			 *  \return Next byte in the currently selected endpoint's FIFO buffer.
			 */
			static inline uint8_t Endpoint_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_Read_8(void)
			{
				return UEDATX;
    5ff6:	80 91 f1 00 	lds	r24, 0x00F1

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
	  *(RequestHeader++) = Endpoint_Read_8();
    5ffa:	81 93       	st	Z+, r24
	USB_ControlRequest.wIndex        = Endpoint_Read_16_LE();
	USB_ControlRequest.wLength       = Endpoint_Read_16_LE();
	#else
	uint8_t* RequestHeader = (uint8_t*)&USB_ControlRequest;

	for (uint8_t RequestHeaderByte = 0; RequestHeaderByte < sizeof(USB_Request_Header_t); RequestHeaderByte++)
    5ffc:	2d e0       	ldi	r18, 0x0D	; 13
    5ffe:	e6 3b       	cpi	r30, 0xB6	; 182
    6000:	f2 07       	cpc	r31, r18
    6002:	c9 f7       	brne	.-14     	; 0x5ff6 <USB_Device_ProcessControlRequest+0x1a>
	  *(RequestHeader++) = Endpoint_Read_8();
	#endif

	EVENT_USB_Device_ControlRequest();
    6004:	0e 94 c3 02 	call	0x586	; 0x586 <EVENT_USB_Device_ControlRequest>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6008:	80 91 e8 00 	lds	r24, 0x00E8

	if (Endpoint_IsSETUPReceived())
    600c:	83 ff       	sbrs	r24, 3
    600e:	36 c1       	rjmp	.+620    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
	{
		uint8_t bmRequestType = USB_ControlRequest.bmRequestType;
    6010:	80 91 ae 0d 	lds	r24, 0x0DAE

		switch (USB_ControlRequest.bRequest)
    6014:	20 91 af 0d 	lds	r18, 0x0DAF
    6018:	25 30       	cpi	r18, 0x05	; 5
    601a:	09 f4       	brne	.+2      	; 0x601e <USB_Device_ProcessControlRequest+0x42>
    601c:	84 c0       	rjmp	.+264    	; 0x6126 <USB_Device_ProcessControlRequest+0x14a>
    601e:	26 30       	cpi	r18, 0x06	; 6
    6020:	40 f4       	brcc	.+16     	; 0x6032 <USB_Device_ProcessControlRequest+0x56>
    6022:	21 30       	cpi	r18, 0x01	; 1
    6024:	a1 f1       	breq	.+104    	; 0x608e <USB_Device_ProcessControlRequest+0xb2>
    6026:	21 30       	cpi	r18, 0x01	; 1
    6028:	70 f0       	brcs	.+28     	; 0x6046 <USB_Device_ProcessControlRequest+0x6a>
    602a:	23 30       	cpi	r18, 0x03	; 3
    602c:	09 f0       	breq	.+2      	; 0x6030 <USB_Device_ProcessControlRequest+0x54>
    602e:	26 c1       	rjmp	.+588    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
    6030:	2e c0       	rjmp	.+92     	; 0x608e <USB_Device_ProcessControlRequest+0xb2>
    6032:	28 30       	cpi	r18, 0x08	; 8
    6034:	09 f4       	brne	.+2      	; 0x6038 <USB_Device_ProcessControlRequest+0x5c>
    6036:	f2 c0       	rjmp	.+484    	; 0x621c <USB_Device_ProcessControlRequest+0x240>
    6038:	29 30       	cpi	r18, 0x09	; 9
    603a:	09 f4       	brne	.+2      	; 0x603e <USB_Device_ProcessControlRequest+0x62>
    603c:	02 c1       	rjmp	.+516    	; 0x6242 <USB_Device_ProcessControlRequest+0x266>
    603e:	26 30       	cpi	r18, 0x06	; 6
    6040:	09 f0       	breq	.+2      	; 0x6044 <USB_Device_ProcessControlRequest+0x68>
    6042:	1c c1       	rjmp	.+568    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
    6044:	92 c0       	rjmp	.+292    	; 0x616a <USB_Device_ProcessControlRequest+0x18e>
		{
			case REQ_GetStatus:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    6046:	80 38       	cpi	r24, 0x80	; 128
    6048:	21 f0       	breq	.+8      	; 0x6052 <USB_Device_ProcessControlRequest+0x76>
    604a:	82 38       	cpi	r24, 0x82	; 130
    604c:	09 f0       	breq	.+2      	; 0x6050 <USB_Device_ProcessControlRequest+0x74>
    604e:	16 c1       	rjmp	.+556    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
    6050:	08 c0       	rjmp	.+16     	; 0x6062 <USB_Device_ProcessControlRequest+0x86>
	Endpoint_ClearOUT();
}

static void USB_Device_GetStatus(void)
{
	uint8_t CurrentStatus = 0;
    6052:	80 91 aa 0d 	lds	r24, 0x0DAA
			if (USB_Device_CurrentlySelfPowered)
			  CurrentStatus |= FEATURE_SELFPOWERED_ENABLED;
			#endif

			#if !defined(NO_DEVICE_REMOTE_WAKEUP)
			if (USB_Device_RemoteWakeupEnabled)
    6056:	90 91 ab 0d 	lds	r25, 0x0DAB
    605a:	99 23       	and	r25, r25
    605c:	71 f0       	breq	.+28     	; 0x607a <USB_Device_ProcessControlRequest+0x9e>
			  CurrentStatus |= FEATURE_REMOTE_WAKEUP_ENABLED;
    605e:	82 60       	ori	r24, 0x02	; 2
    6060:	0c c0       	rjmp	.+24     	; 0x607a <USB_Device_ProcessControlRequest+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6062:	80 91 b2 0d 	lds	r24, 0x0DB2
    6066:	8f 70       	andi	r24, 0x0F	; 15
    6068:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    606c:	90 91 eb 00 	lds	r25, 0x00EB
			break;
		case (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_ENDPOINT):
			#if !defined(CONTROL_ONLY_DEVICE)
			Endpoint_SelectEndpoint((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);

			CurrentStatus = Endpoint_IsStalled();
    6070:	81 e0       	ldi	r24, 0x01	; 1
    6072:	95 ff       	sbrs	r25, 5
    6074:	80 e0       	ldi	r24, 0x00	; 0
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6076:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    607a:	90 91 e8 00 	lds	r25, 0x00E8
    607e:	97 7f       	andi	r25, 0xF7	; 247
    6080:	90 93 e8 00 	sts	0x00E8, r25
			 *  \param[in] Data  Data to write to the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_16_LE(const uint16_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_16_LE(const uint16_t Data)
			{
				UEDATX = (Data & 0xFF);
    6084:	80 93 f1 00 	sts	0x00F1, r24
				UEDATX = (Data >> 8);
    6088:	10 92 f1 00 	sts	0x00F1, r1
    608c:	d2 c0       	rjmp	.+420    	; 0x6232 <USB_Device_ProcessControlRequest+0x256>
				}

				break;
			case REQ_ClearFeature:
			case REQ_SetFeature:
				if ((bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    608e:	88 23       	and	r24, r24
    6090:	19 f0       	breq	.+6      	; 0x6098 <USB_Device_ProcessControlRequest+0xbc>
    6092:	82 30       	cpi	r24, 0x02	; 2
    6094:	09 f0       	breq	.+2      	; 0x6098 <USB_Device_ProcessControlRequest+0xbc>
    6096:	f2 c0       	rjmp	.+484    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
	Endpoint_ClearStatusStage();
}

static void USB_Device_ClearSetFeature(void)
{
	switch (USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_RECIPIENT)
    6098:	90 e0       	ldi	r25, 0x00	; 0
    609a:	8f 71       	andi	r24, 0x1F	; 31
    609c:	90 70       	andi	r25, 0x00	; 0
    609e:	00 97       	sbiw	r24, 0x00	; 0
    60a0:	29 f0       	breq	.+10     	; 0x60ac <USB_Device_ProcessControlRequest+0xd0>
    60a2:	82 30       	cpi	r24, 0x02	; 2
    60a4:	91 05       	cpc	r25, r1
    60a6:	09 f0       	breq	.+2      	; 0x60aa <USB_Device_ProcessControlRequest+0xce>
    60a8:	e9 c0       	rjmp	.+466    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
    60aa:	0b c0       	rjmp	.+22     	; 0x60c2 <USB_Device_ProcessControlRequest+0xe6>
	{
		#if !defined(NO_DEVICE_REMOTE_WAKEUP)
		case REQREC_DEVICE:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_DeviceRemoteWakeup)
    60ac:	80 91 b0 0d 	lds	r24, 0x0DB0
    60b0:	81 30       	cpi	r24, 0x01	; 1
    60b2:	09 f0       	breq	.+2      	; 0x60b6 <USB_Device_ProcessControlRequest+0xda>
    60b4:	e3 c0       	rjmp	.+454    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
			  USB_Device_RemoteWakeupEnabled = (USB_ControlRequest.bRequest == REQ_SetFeature);
    60b6:	23 30       	cpi	r18, 0x03	; 3
    60b8:	09 f0       	breq	.+2      	; 0x60bc <USB_Device_ProcessControlRequest+0xe0>
    60ba:	80 e0       	ldi	r24, 0x00	; 0
    60bc:	80 93 ab 0d 	sts	0x0DAB, r24
    60c0:	2c c0       	rjmp	.+88     	; 0x611a <USB_Device_ProcessControlRequest+0x13e>

			break;
		#endif
		#if !defined(CONTROL_ONLY_DEVICE)
		case REQREC_ENDPOINT:
			if ((uint8_t)USB_ControlRequest.wValue == FEATURE_SEL_EndpointHalt)
    60c2:	80 91 b0 0d 	lds	r24, 0x0DB0
    60c6:	88 23       	and	r24, r24
    60c8:	41 f5       	brne	.+80     	; 0x611a <USB_Device_ProcessControlRequest+0x13e>
			{
				uint8_t EndpointIndex = ((uint8_t)USB_ControlRequest.wIndex & ENDPOINT_EPNUM_MASK);
    60ca:	20 91 b2 0d 	lds	r18, 0x0DB2
    60ce:	2f 70       	andi	r18, 0x0F	; 15

				if (EndpointIndex == ENDPOINT_CONTROLEP)
    60d0:	09 f4       	brne	.+2      	; 0x60d4 <USB_Device_ProcessControlRequest+0xf8>
    60d2:	d4 c0       	rjmp	.+424    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    60d4:	20 93 e9 00 	sts	0x00E9, r18
			 * \return Boolean \c true if the currently selected endpoint is enabled, \c false otherwise.
			 */
			static inline bool Endpoint_IsEnabled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsEnabled(void)
			{
				return ((UECONX & (1 << EPEN)) ? true : false);
    60d8:	80 91 eb 00 	lds	r24, 0x00EB
				  return;

				Endpoint_SelectEndpoint(EndpointIndex);

				if (Endpoint_IsEnabled())
    60dc:	80 ff       	sbrs	r24, 0
    60de:	1d c0       	rjmp	.+58     	; 0x611a <USB_Device_ProcessControlRequest+0x13e>
				{
					if (USB_ControlRequest.bRequest == REQ_SetFeature)
    60e0:	80 91 af 0d 	lds	r24, 0x0DAF
    60e4:	83 30       	cpi	r24, 0x03	; 3
    60e6:	21 f4       	brne	.+8      	; 0x60f0 <USB_Device_ProcessControlRequest+0x114>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    60e8:	80 91 eb 00 	lds	r24, 0x00EB
    60ec:	80 62       	ori	r24, 0x20	; 32
    60ee:	13 c0       	rjmp	.+38     	; 0x6116 <USB_Device_ProcessControlRequest+0x13a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    60f0:	80 91 eb 00 	lds	r24, 0x00EB
    60f4:	80 61       	ori	r24, 0x10	; 16
    60f6:	80 93 eb 00 	sts	0x00EB, r24
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    60fa:	81 e0       	ldi	r24, 0x01	; 1
    60fc:	90 e0       	ldi	r25, 0x00	; 0
    60fe:	02 c0       	rjmp	.+4      	; 0x6104 <USB_Device_ProcessControlRequest+0x128>
    6100:	88 0f       	add	r24, r24
    6102:	99 1f       	adc	r25, r25
    6104:	2a 95       	dec	r18
    6106:	e2 f7       	brpl	.-8      	; 0x6100 <USB_Device_ProcessControlRequest+0x124>
    6108:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    610c:	10 92 ea 00 	sts	0x00EA, r1

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    6110:	80 91 eb 00 	lds	r24, 0x00EB
    6114:	88 60       	ori	r24, 0x08	; 8
    6116:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    611a:	10 92 e9 00 	sts	0x00E9, r1
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    611e:	80 91 e8 00 	lds	r24, 0x00E8
    6122:	87 7f       	andi	r24, 0xF7	; 247
    6124:	89 c0       	rjmp	.+274    	; 0x6238 <USB_Device_ProcessControlRequest+0x25c>
					USB_Device_ClearSetFeature();
				}

				break;
			case REQ_SetAddress:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6126:	88 23       	and	r24, r24
    6128:	09 f0       	breq	.+2      	; 0x612c <USB_Device_ProcessControlRequest+0x150>
    612a:	a8 c0       	rjmp	.+336    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
	}
}

static void USB_Device_SetAddress(void)
{
	uint8_t DeviceAddress = (USB_ControlRequest.wValue & 0x7F);
    612c:	10 91 b0 0d 	lds	r17, 0x0DB0
    6130:	1f 77       	andi	r17, 0x7F	; 127
			#endif

			static inline void USB_Device_SetDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_SetDeviceAddress(const uint8_t Address)
			{
				UDADDR = (UDADDR & (1 << ADDEN)) | (Address & 0x7F);
    6132:	80 91 e3 00 	lds	r24, 0x00E3
    6136:	80 78       	andi	r24, 0x80	; 128
    6138:	81 2b       	or	r24, r17
    613a:	80 93 e3 00 	sts	0x00E3, r24
    613e:	80 91 e8 00 	lds	r24, 0x00E8
    6142:	87 7f       	andi	r24, 0xF7	; 247
    6144:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_SetDeviceAddress(DeviceAddress);

	Endpoint_ClearSETUP();

	Endpoint_ClearStatusStage();
    6148:	04 d8       	rcall	.-4088   	; 0x5152 <Endpoint_ClearStatusStage>
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    614a:	80 91 e8 00 	lds	r24, 0x00E8

	while (!(Endpoint_IsINReady()));
    614e:	80 ff       	sbrs	r24, 0
    6150:	fc cf       	rjmp	.-8      	; 0x614a <USB_Device_ProcessControlRequest+0x16e>
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void USB_Device_EnableDeviceAddress(const uint8_t Address)
			{
				(void)Address;
				
				UDADDR |= (1 << ADDEN);
    6152:	80 91 e3 00 	lds	r24, 0x00E3
    6156:	80 68       	ori	r24, 0x80	; 128
    6158:	80 93 e3 00 	sts	0x00E3, r24

	USB_Device_EnableDeviceAddress(DeviceAddress);

	USB_DeviceState = (DeviceAddress) ? DEVICE_STATE_Addressed : DEVICE_STATE_Default;
    615c:	11 23       	and	r17, r17
    615e:	11 f0       	breq	.+4      	; 0x6164 <USB_Device_ProcessControlRequest+0x188>
    6160:	83 e0       	ldi	r24, 0x03	; 3
    6162:	01 c0       	rjmp	.+2      	; 0x6166 <USB_Device_ProcessControlRequest+0x18a>
    6164:	82 e0       	ldi	r24, 0x02	; 2
    6166:	8e bb       	out	0x1e, r24	; 30
    6168:	89 c0       	rjmp	.+274    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_SetAddress();

				break;
			case REQ_GetDescriptor:
				if ((bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE)) ||
    616a:	80 58       	subi	r24, 0x80	; 128
    616c:	82 30       	cpi	r24, 0x02	; 2
    616e:	08 f0       	brcs	.+2      	; 0x6172 <USB_Device_ProcessControlRequest+0x196>
    6170:	85 c0       	rjmp	.+266    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
	    !(defined(USE_FLASH_DESCRIPTORS) || defined(USE_EEPROM_DESCRIPTORS) || defined(USE_RAM_DESCRIPTORS))
	uint8_t DescriptorAddressSpace;
	#endif

	#if !defined(NO_INTERNAL_SERIAL) && (USE_INTERNAL_SERIAL != NO_DESCRIPTOR)
	if (USB_ControlRequest.wValue == ((DTYPE_String << 8) | USE_INTERNAL_SERIAL))
    6172:	80 91 b0 0d 	lds	r24, 0x0DB0
    6176:	90 91 b1 0d 	lds	r25, 0x0DB1
    617a:	23 e0       	ldi	r18, 0x03	; 3
    617c:	8c 3d       	cpi	r24, 0xDC	; 220
    617e:	92 07       	cpc	r25, r18
    6180:	99 f5       	brne	.+102    	; 0x61e8 <USB_Device_ProcessControlRequest+0x20c>
	{
		USB_Descriptor_Header_t Header;
		uint16_t                UnicodeString[INTERNAL_SERIAL_LENGTH_BITS / 4];
	} SignatureDescriptor;

	SignatureDescriptor.Header.Type = DTYPE_String;
    6182:	83 e0       	ldi	r24, 0x03	; 3
    6184:	8c 83       	std	Y+4, r24	; 0x04
	SignatureDescriptor.Header.Size = USB_STRING_LEN(INTERNAL_SERIAL_LENGTH_BITS / 4);
    6186:	8a e2       	ldi	r24, 0x2A	; 42
    6188:	8b 83       	std	Y+3, r24	; 0x03
			static inline uint_reg_t GetGlobalInterruptMask(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				return SREG;
    618a:	5f b7       	in	r21, 0x3f	; 63
			static inline void GlobalInterruptDisable(void)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				cli();
    618c:	f8 94       	cli
				__builtin_ssrf(AVR32_SR_GM_OFFSET);
				#elif (ARCH == ARCH_XMEGA)
				cli();
				#endif

				GCC_MEMORY_BARRIER();
    618e:	de 01       	movw	r26, r28
    6190:	15 96       	adiw	r26, 0x05	; 5
    6192:	80 e0       	ldi	r24, 0x00	; 0
    6194:	90 e0       	ldi	r25, 0x00	; 0
			static inline void USB_Device_GetSerialString(uint16_t* const UnicodeString)
			{
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;
    6196:	4e e0       	ldi	r20, 0x0E	; 14

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
				{
					uint8_t SerialByte = boot_signature_byte_get(SigReadAddress);
    6198:	61 e2       	ldi	r22, 0x21	; 33
    619a:	e4 2f       	mov	r30, r20
    619c:	f0 e0       	ldi	r31, 0x00	; 0
    619e:	60 93 57 00 	sts	0x0057, r22
    61a2:	e4 91       	lpm	r30, Z+

					if (SerialCharNum & 0x01)
    61a4:	80 ff       	sbrs	r24, 0
    61a6:	03 c0       	rjmp	.+6      	; 0x61ae <USB_Device_ProcessControlRequest+0x1d2>
					{
						SerialByte >>= 4;
    61a8:	e2 95       	swap	r30
    61aa:	ef 70       	andi	r30, 0x0F	; 15
						SigReadAddress++;
    61ac:	4f 5f       	subi	r20, 0xFF	; 255
					}

					SerialByte &= 0x0F;
    61ae:	ef 70       	andi	r30, 0x0F	; 15
    61b0:	2e 2f       	mov	r18, r30
    61b2:	30 e0       	ldi	r19, 0x00	; 0

					UnicodeString[SerialCharNum] = cpu_to_le16((SerialByte >= 10) ?
    61b4:	ea 30       	cpi	r30, 0x0A	; 10
    61b6:	18 f0       	brcs	.+6      	; 0x61be <USB_Device_ProcessControlRequest+0x1e2>
    61b8:	29 5c       	subi	r18, 0xC9	; 201
    61ba:	3f 4f       	sbci	r19, 0xFF	; 255
    61bc:	02 c0       	rjmp	.+4      	; 0x61c2 <USB_Device_ProcessControlRequest+0x1e6>
    61be:	20 5d       	subi	r18, 0xD0	; 208
    61c0:	3f 4f       	sbci	r19, 0xFF	; 255
    61c2:	2d 93       	st	X+, r18
    61c4:	3d 93       	st	X+, r19
    61c6:	01 96       	adiw	r24, 0x01	; 1
				uint_reg_t CurrentGlobalInt = GetGlobalInterruptMask();
				GlobalInterruptDisable();

				uint8_t SigReadAddress = INTERNAL_SERIAL_START_ADDRESS;

				for (uint8_t SerialCharNum = 0; SerialCharNum < (INTERNAL_SERIAL_LENGTH_BITS / 4); SerialCharNum++)
    61c8:	84 31       	cpi	r24, 0x14	; 20
    61ca:	91 05       	cpc	r25, r1
    61cc:	31 f7       	brne	.-52     	; 0x619a <USB_Device_ProcessControlRequest+0x1be>
			static inline void SetGlobalInterruptMask(const uint_reg_t GlobalIntState)
			{
				GCC_MEMORY_BARRIER();

				#if (ARCH == ARCH_AVR8)
				SREG = GlobalIntState;
    61ce:	5f bf       	out	0x3f, r21	; 63
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    61d0:	80 91 e8 00 	lds	r24, 0x00E8
    61d4:	87 7f       	andi	r24, 0xF7	; 247
    61d6:	80 93 e8 00 	sts	0x00E8, r24

	USB_Device_GetSerialString(SignatureDescriptor.UnicodeString);

	Endpoint_ClearSETUP();

	Endpoint_Write_Control_Stream_LE(&SignatureDescriptor, sizeof(SignatureDescriptor));
    61da:	ce 01       	movw	r24, r28
    61dc:	03 96       	adiw	r24, 0x03	; 3
    61de:	6a e2       	ldi	r22, 0x2A	; 42
    61e0:	70 e0       	ldi	r23, 0x00	; 0
    61e2:	0e 94 38 27 	call	0x4e70	; 0x4e70 <Endpoint_Write_Control_Stream_LE>
    61e6:	14 c0       	rjmp	.+40     	; 0x6210 <USB_Device_ProcessControlRequest+0x234>
		USB_Device_GetInternalSerialDescriptor();
		return;
	}
	#endif

	if ((DescriptorSize = CALLBACK_USB_GetDescriptor(USB_ControlRequest.wValue, USB_ControlRequest.wIndex,
    61e8:	60 91 b2 0d 	lds	r22, 0x0DB2
    61ec:	ae 01       	movw	r20, r28
    61ee:	4f 5f       	subi	r20, 0xFF	; 255
    61f0:	5f 4f       	sbci	r21, 0xFF	; 255
    61f2:	0e 94 67 02 	call	0x4ce	; 0x4ce <CALLBACK_USB_GetDescriptor>
    61f6:	bc 01       	movw	r22, r24
    61f8:	00 97       	sbiw	r24, 0x00	; 0
    61fa:	09 f4       	brne	.+2      	; 0x61fe <USB_Device_ProcessControlRequest+0x222>
    61fc:	3f c0       	rjmp	.+126    	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
    61fe:	80 91 e8 00 	lds	r24, 0x00E8
    6202:	87 7f       	andi	r24, 0xF7	; 247
    6204:	80 93 e8 00 	sts	0x00E8, r24
	#if defined(USE_RAM_DESCRIPTORS) || !defined(ARCH_HAS_MULTI_ADDRESS_SPACE)
	Endpoint_Write_Control_Stream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_EEPROM_DESCRIPTORS)
	Endpoint_Write_Control_EStream_LE(DescriptorPointer, DescriptorSize);
	#elif defined(USE_FLASH_DESCRIPTORS)
	Endpoint_Write_Control_PStream_LE(DescriptorPointer, DescriptorSize);
    6208:	89 81       	ldd	r24, Y+1	; 0x01
    620a:	9a 81       	ldd	r25, Y+2	; 0x02
    620c:	0e 94 d2 27 	call	0x4fa4	; 0x4fa4 <Endpoint_Write_Control_PStream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6210:	80 91 e8 00 	lds	r24, 0x00E8
    6214:	8b 77       	andi	r24, 0x7B	; 123
    6216:	80 93 e8 00 	sts	0x00E8, r24
    621a:	30 c0       	rjmp	.+96     	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
					USB_Device_GetDescriptor();
				}

				break;
			case REQ_GetConfiguration:
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
    621c:	80 38       	cpi	r24, 0x80	; 128
    621e:	71 f5       	brne	.+92     	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6220:	80 91 e8 00 	lds	r24, 0x00E8
    6224:	87 7f       	andi	r24, 0xF7	; 247
    6226:	80 93 e8 00 	sts	0x00E8, r24

static void USB_Device_GetConfiguration(void)
{
	Endpoint_ClearSETUP();

	Endpoint_Write_8(USB_Device_ConfigurationNumber);
    622a:	80 91 a9 0d 	lds	r24, 0x0DA9
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    622e:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6232:	80 91 e8 00 	lds	r24, 0x00E8
    6236:	8e 77       	andi	r24, 0x7E	; 126
    6238:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	Endpoint_ClearStatusStage();
    623c:	0e 94 a9 28 	call	0x5152	; 0x5152 <Endpoint_ClearStatusStage>
    6240:	1d c0       	rjmp	.+58     	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
				if (bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_STANDARD | REQREC_DEVICE))
				  USB_Device_GetConfiguration();

				break;
			case REQ_SetConfiguration:
				if (bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_STANDARD | REQREC_DEVICE))
    6242:	88 23       	and	r24, r24
    6244:	d9 f4       	brne	.+54     	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
}

static void USB_Device_SetConfiguration(void)
{
	#if defined(FIXED_NUM_CONFIGURATIONS)
	if ((uint8_t)USB_ControlRequest.wValue > FIXED_NUM_CONFIGURATIONS)
    6246:	90 91 b0 0d 	lds	r25, 0x0DB0
    624a:	92 30       	cpi	r25, 0x02	; 2
    624c:	b8 f4       	brcc	.+46     	; 0x627c <USB_Device_ProcessControlRequest+0x2a0>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    624e:	80 91 e8 00 	lds	r24, 0x00E8
    6252:	87 7f       	andi	r24, 0xF7	; 247
    6254:	80 93 e8 00 	sts	0x00E8, r24
	#endif
	#endif

	Endpoint_ClearSETUP();

	USB_Device_ConfigurationNumber = (uint8_t)USB_ControlRequest.wValue;
    6258:	90 93 a9 0d 	sts	0x0DA9, r25

	Endpoint_ClearStatusStage();
    625c:	0e 94 a9 28 	call	0x5152	; 0x5152 <Endpoint_ClearStatusStage>

	if (USB_Device_ConfigurationNumber)
    6260:	80 91 a9 0d 	lds	r24, 0x0DA9
    6264:	88 23       	and	r24, r24
    6266:	21 f4       	brne	.+8      	; 0x6270 <USB_Device_ProcessControlRequest+0x294>
			}

			static inline bool USB_Device_IsAddressSet(void) ATTR_ALWAYS_INLINE ATTR_WARN_UNUSED_RESULT;
			static inline bool USB_Device_IsAddressSet(void)
			{
				return (UDADDR & (1 << ADDEN));
    6268:	80 91 e3 00 	lds	r24, 0x00E3
	  USB_DeviceState = DEVICE_STATE_Configured;
	else
	  USB_DeviceState = (USB_Device_IsAddressSet()) ? DEVICE_STATE_Configured : DEVICE_STATE_Powered;
    626c:	87 ff       	sbrs	r24, 7
    626e:	02 c0       	rjmp	.+4      	; 0x6274 <USB_Device_ProcessControlRequest+0x298>
    6270:	84 e0       	ldi	r24, 0x04	; 4
    6272:	01 c0       	rjmp	.+2      	; 0x6276 <USB_Device_ProcessControlRequest+0x29a>
    6274:	81 e0       	ldi	r24, 0x01	; 1
    6276:	8e bb       	out	0x1e, r24	; 30

	EVENT_USB_Device_ConfigurationChanged();
    6278:	0e 94 ac 02 	call	0x558	; 0x558 <EVENT_USB_Device_ConfigurationChanged>
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    627c:	80 91 e8 00 	lds	r24, 0x00E8
			default:
				break;
		}
	}

	if (Endpoint_IsSETUPReceived())
    6280:	83 ff       	sbrs	r24, 3
    6282:	0a c0       	rjmp	.+20     	; 0x6298 <USB_Device_ProcessControlRequest+0x2bc>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6284:	80 91 e8 00 	lds	r24, 0x00E8
    6288:	87 7f       	andi	r24, 0xF7	; 247
    628a:	80 93 e8 00 	sts	0x00E8, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    628e:	80 91 eb 00 	lds	r24, 0x00EB
    6292:	80 62       	ori	r24, 0x20	; 32
    6294:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_ClearSETUP();
		Endpoint_StallTransaction();
	}
}
    6298:	ac 96       	adiw	r28, 0x2c	; 44
    629a:	0f b6       	in	r0, 0x3f	; 63
    629c:	f8 94       	cli
    629e:	de bf       	out	0x3e, r29	; 62
    62a0:	0f be       	out	0x3f, r0	; 63
    62a2:	cd bf       	out	0x3d, r28	; 61
    62a4:	cf 91       	pop	r28
    62a6:	df 91       	pop	r29
    62a8:	1f 91       	pop	r17
    62aa:	08 95       	ret

000062ac <USB_Event_Stub>:
#include "Events.h"

void USB_Event_Stub(void)
{

}
    62ac:	08 95       	ret

000062ae <USB_Host_WaitForIOS>:
	
	return ReturnStatus;
}

static uint8_t USB_Host_WaitForIOS(const uint8_t WaitType)
{
    62ae:	1f 93       	push	r17
    62b0:	cf 93       	push	r28
    62b2:	df 93       	push	r29
    62b4:	18 2f       	mov	r17, r24
	#if (USB_HOST_TIMEOUT_MS < 0xFF)
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
    62b6:	c8 ee       	ldi	r28, 0xE8	; 232
    62b8:	d3 e0       	ldi	r29, 0x03	; 3
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    62ba:	08 c0       	rjmp	.+16     	; 0x62cc <USB_Host_WaitForIOS+0x1e>
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
	{
		uint8_t ErrorCode;

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    62bc:	81 e0       	ldi	r24, 0x01	; 1
    62be:	0e 94 51 29 	call	0x52a2	; 0x52a2 <USB_Host_WaitMS>
    62c2:	88 23       	and	r24, r24
    62c4:	d1 f4       	brne	.+52     	; 0x62fa <USB_Host_WaitForIOS+0x4c>
		  return ErrorCode;

		if (!(TimeoutCounter--))
    62c6:	20 97       	sbiw	r28, 0x00	; 0
    62c8:	b9 f0       	breq	.+46     	; 0x62f8 <USB_Host_WaitForIOS+0x4a>
    62ca:	21 97       	sbiw	r28, 0x01	; 1
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    62cc:	11 23       	and	r17, r17
    62ce:	29 f4       	brne	.+10     	; 0x62da <USB_Host_WaitForIOS+0x2c>
			 *  \return Boolean \c true if the current pipe is ready for a SETUP packet, \c false otherwise.
			 */
			static inline bool Pipe_IsSETUPSent(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsSETUPSent(void)
			{
				return ((UPINTX & (1 << TXSTPI)) ? true : false);
    62d0:	80 91 a6 00 	lds	r24, 0x00A6
    62d4:	83 ff       	sbrs	r24, 3
    62d6:	f2 cf       	rjmp	.-28     	; 0x62bc <USB_Host_WaitForIOS+0xe>
    62d8:	0d c0       	rjmp	.+26     	; 0x62f4 <USB_Host_WaitForIOS+0x46>
    62da:	11 30       	cpi	r17, 0x01	; 1
    62dc:	29 f4       	brne	.+10     	; 0x62e8 <USB_Host_WaitForIOS+0x3a>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    62de:	80 91 a6 00 	lds	r24, 0x00A6
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
    62e2:	80 ff       	sbrs	r24, 0
    62e4:	eb cf       	rjmp	.-42     	; 0x62bc <USB_Host_WaitForIOS+0xe>
    62e6:	06 c0       	rjmp	.+12     	; 0x62f4 <USB_Host_WaitForIOS+0x46>
	uint8_t  TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#else
	uint16_t TimeoutCounter = USB_HOST_TIMEOUT_MS;
	#endif

	while (!(((WaitType == USB_HOST_WAITFOR_SetupSent)  && Pipe_IsSETUPSent())  ||
    62e8:	12 30       	cpi	r17, 0x02	; 2
    62ea:	41 f7       	brne	.-48     	; 0x62bc <USB_Host_WaitForIOS+0xe>
			 *  \return Boolean \c true if the current pipe is ready for an OUT packet, \c false otherwise.
			 */
			static inline bool Pipe_IsOUTReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsOUTReady(void)
			{
				return ((UPINTX & (1 << TXOUTI)) ? true : false);
    62ec:	80 91 a6 00 	lds	r24, 0x00A6
	         ((WaitType == USB_HOST_WAITFOR_InReceived) && Pipe_IsINReceived()) ||
	         ((WaitType == USB_HOST_WAITFOR_OutReady)   && Pipe_IsOUTReady())))
    62f0:	82 ff       	sbrs	r24, 2
    62f2:	e4 cf       	rjmp	.-56     	; 0x62bc <USB_Host_WaitForIOS+0xe>

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
	}

	return HOST_SENDCONTROL_Successful;
    62f4:	80 e0       	ldi	r24, 0x00	; 0
    62f6:	01 c0       	rjmp	.+2      	; 0x62fa <USB_Host_WaitForIOS+0x4c>

		if ((ErrorCode = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
		  return ErrorCode;

		if (!(TimeoutCounter--))
		  return HOST_SENDCONTROL_SoftwareTimeOut;
    62f8:	84 e0       	ldi	r24, 0x04	; 4
	}

	return HOST_SENDCONTROL_Successful;
}
    62fa:	df 91       	pop	r29
    62fc:	cf 91       	pop	r28
    62fe:	1f 91       	pop	r17
    6300:	08 95       	ret

00006302 <USB_Host_SendControlRequest>:

uint8_t USB_Host_SendControlRequest(void* const BufferPtr)
{
    6302:	ef 92       	push	r14
    6304:	ff 92       	push	r15
    6306:	0f 93       	push	r16
    6308:	1f 93       	push	r17
    630a:	cf 93       	push	r28
    630c:	df 93       	push	r29
    630e:	8c 01       	movw	r16, r24
			 *  \return Boolean \c true if the bus is currently suspended, \c false otherwise.
			 */
			static inline bool USB_Host_IsBusSuspended(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool USB_Host_IsBusSuspended(void)
			{
				return ((UHCON & (1 << SOFEN)) ? false : true);
    6310:	e0 90 9e 00 	lds	r14, 0x009E
    6314:	ff 24       	eor	r15, r15
    6316:	81 e0       	ldi	r24, 0x01	; 1
    6318:	e8 22       	and	r14, r24
    631a:	ff 24       	eor	r15, r15

static uint8_t USB_Host_SendControlRequest_PRV(void* const BufferPtr)
{
	uint8_t* DataStream   = (uint8_t*)BufferPtr;
	uint8_t  ReturnStatus = HOST_SENDCONTROL_Successful;
	uint16_t DataLen      = USB_ControlRequest.wLength;
    631c:	c0 91 b4 0d 	lds	r28, 0x0DB4
    6320:	d0 91 b5 0d 	lds	r29, 0x0DB5
			 *  host and attached device may occur.
			 */
			static inline void USB_Host_ResumeBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_ResumeBus(void)
			{
				UHCON |=  (1 << SOFEN);
    6324:	80 91 9e 00 	lds	r24, 0x009E
    6328:	81 60       	ori	r24, 0x01	; 1
    632a:	80 93 9e 00 	sts	0x009E, r24

	USB_Host_ResumeBus();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    632e:	81 e0       	ldi	r24, 0x01	; 1
    6330:	0e 94 51 29 	call	0x52a2	; 0x52a2 <USB_Host_WaitMS>
    6334:	88 23       	and	r24, r24
    6336:	09 f0       	breq	.+2      	; 0x633a <USB_Host_SendControlRequest+0x38>
    6338:	cc c0       	rjmp	.+408    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    633a:	80 91 aa 00 	lds	r24, 0x00AA
    633e:	8f 7c       	andi	r24, 0xCF	; 207
    6340:	80 93 aa 00 	sts	0x00AA, r24

			/** Clears the error flags for the currently selected pipe. */
			static inline void Pipe_ClearError(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearError(void)
			{
				UPERRX = 0;
    6344:	10 92 f5 00 	sts	0x00F5, r1
				UPINTX &= ~(1 << PERRI);
    6348:	80 91 a6 00 	lds	r24, 0x00A6
    634c:	8f 7e       	andi	r24, 0xEF	; 239
    634e:	80 93 a6 00 	sts	0x00A6, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6352:	80 91 a9 00 	lds	r24, 0x00A9
    6356:	8f 7b       	andi	r24, 0xBF	; 191
    6358:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_Write_8(USB_ControlRequest.bRequest);
	Pipe_Write_16_LE(USB_ControlRequest.wValue);
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;
    635c:	ee ea       	ldi	r30, 0xAE	; 174
    635e:	fd e0       	ldi	r31, 0x0D	; 13

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
	  Pipe_Write_8(*(HeaderStream++));
    6360:	81 91       	ld	r24, Z+
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    6362:	80 93 af 00 	sts	0x00AF, r24
	Pipe_Write_16_LE(USB_ControlRequest.wIndex);
	Pipe_Write_16_LE(USB_ControlRequest.wLength);
	#else
	uint8_t* HeaderStream = (uint8_t*)&USB_ControlRequest;

	for (uint8_t HeaderByte = 0; HeaderByte < sizeof(USB_Request_Header_t); HeaderByte++)
    6366:	8d e0       	ldi	r24, 0x0D	; 13
    6368:	e6 3b       	cpi	r30, 0xB6	; 182
    636a:	f8 07       	cpc	r31, r24
    636c:	c9 f7       	brne	.-14     	; 0x6360 <USB_Host_SendControlRequest+0x5e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearSETUP(void)
			{
				UPINTX &= ~((1 << TXSTPI) | (1 << FIFOCON));
    636e:	80 91 a6 00 	lds	r24, 0x00A6
    6372:	87 77       	andi	r24, 0x77	; 119
    6374:	80 93 a6 00 	sts	0x00A6, r24
	  Pipe_Write_8(*(HeaderStream++));
	#endif

	Pipe_ClearSETUP();

	if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_SetupSent)) != HOST_SENDCONTROL_Successful)
    6378:	80 e0       	ldi	r24, 0x00	; 0
    637a:	99 df       	rcall	.-206    	; 0x62ae <USB_Host_WaitForIOS>
    637c:	88 23       	and	r24, r24
    637e:	09 f0       	breq	.+2      	; 0x6382 <USB_Host_SendControlRequest+0x80>
    6380:	a8 c0       	rjmp	.+336    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    6382:	80 91 a9 00 	lds	r24, 0x00A9
    6386:	80 64       	ori	r24, 0x40	; 64
    6388:	80 93 a9 00 	sts	0x00A9, r24
	  return ReturnStatus;

	Pipe_Freeze();

	if ((ReturnStatus = USB_Host_WaitMS(1)) != HOST_WAITERROR_Successful)
    638c:	81 e0       	ldi	r24, 0x01	; 1
    638e:	0e 94 51 29 	call	0x52a2	; 0x52a2 <USB_Host_WaitMS>
    6392:	88 23       	and	r24, r24
    6394:	09 f0       	breq	.+2      	; 0x6398 <USB_Host_SendControlRequest+0x96>
    6396:	9d c0       	rjmp	.+314    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
	  return ReturnStatus;

	if ((USB_ControlRequest.bmRequestType & CONTROL_REQTYPE_DIRECTION) == REQDIR_DEVICETOHOST)
    6398:	80 91 ae 0d 	lds	r24, 0x0DAE
    639c:	87 ff       	sbrs	r24, 7
    639e:	4f c0       	rjmp	.+158    	; 0x643e <USB_Host_SendControlRequest+0x13c>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    63a0:	80 91 aa 00 	lds	r24, 0x00AA
    63a4:	8f 7c       	andi	r24, 0xCF	; 207
    63a6:	80 61       	ori	r24, 0x10	; 16
    63a8:	80 93 aa 00 	sts	0x00AA, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
    63ac:	01 15       	cp	r16, r1
    63ae:	11 05       	cpc	r17, r1
    63b0:	61 f5       	brne	.+88     	; 0x640a <USB_Host_SendControlRequest+0x108>
    63b2:	2d c0       	rjmp	.+90     	; 0x640e <USB_Host_SendControlRequest+0x10c>

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    63b4:	80 91 a9 00 	lds	r24, 0x00A9
    63b8:	8f 7b       	andi	r24, 0xBF	; 191
    63ba:	80 93 a9 00 	sts	0x00A9, r24
		{
			while (DataLen)
			{
				Pipe_Unfreeze();

				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    63be:	81 e0       	ldi	r24, 0x01	; 1
    63c0:	76 df       	rcall	.-276    	; 0x62ae <USB_Host_WaitForIOS>
    63c2:	88 23       	and	r24, r24
    63c4:	09 f0       	breq	.+2      	; 0x63c8 <USB_Host_SendControlRequest+0xc6>
    63c6:	85 c0       	rjmp	.+266    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    63c8:	80 91 f6 00 	lds	r24, 0x00F6
    63cc:	90 91 f7 00 	lds	r25, 0x00F7
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
    63d0:	00 97       	sbiw	r24, 0x00	; 0
    63d2:	49 f4       	brne	.+18     	; 0x63e6 <USB_Host_SendControlRequest+0xe4>
				  DataLen = 0;
    63d4:	c0 e0       	ldi	r28, 0x00	; 0
    63d6:	d0 e0       	ldi	r29, 0x00	; 0
    63d8:	06 c0       	rjmp	.+12     	; 0x63e6 <USB_Host_SendControlRequest+0xe4>
			 *  \return Next byte in the currently selected pipe's FIFO buffer.
			 */
			static inline uint8_t Pipe_Read_8(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_Read_8(void)
			{
				return UPDATX;
    63da:	80 91 af 00 	lds	r24, 0x00AF

				while (Pipe_BytesInPipe() && DataLen)
				{
					*(DataStream++) = Pipe_Read_8();
    63de:	f8 01       	movw	r30, r16
    63e0:	81 93       	st	Z+, r24
    63e2:	8f 01       	movw	r16, r30
					DataLen--;
    63e4:	21 97       	sbiw	r28, 0x01	; 1
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    63e6:	80 91 f6 00 	lds	r24, 0x00F6
    63ea:	90 91 f7 00 	lds	r25, 0x00F7
				  return ReturnStatus;

				if (!(Pipe_BytesInPipe()))
				  DataLen = 0;

				while (Pipe_BytesInPipe() && DataLen)
    63ee:	00 97       	sbiw	r24, 0x00	; 0
    63f0:	11 f0       	breq	.+4      	; 0x63f6 <USB_Host_SendControlRequest+0xf4>
    63f2:	20 97       	sbiw	r28, 0x00	; 0
    63f4:	91 f7       	brne	.-28     	; 0x63da <USB_Host_SendControlRequest+0xd8>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    63f6:	80 91 a9 00 	lds	r24, 0x00A9
    63fa:	80 64       	ori	r24, 0x40	; 64
    63fc:	80 93 a9 00 	sts	0x00A9, r24
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    6400:	80 91 a6 00 	lds	r24, 0x00A6
    6404:	8e 77       	andi	r24, 0x7E	; 126
    6406:	80 93 a6 00 	sts	0x00A6, r24
	{
		Pipe_SetPipeToken(PIPE_TOKEN_IN);

		if (DataStream != NULL)
		{
			while (DataLen)
    640a:	20 97       	sbiw	r28, 0x00	; 0
    640c:	99 f6       	brne	.-90     	; 0x63b4 <USB_Host_SendControlRequest+0xb2>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    640e:	80 91 aa 00 	lds	r24, 0x00AA
    6412:	8f 7c       	andi	r24, 0xCF	; 207
    6414:	80 62       	ori	r24, 0x20	; 32
    6416:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    641a:	80 91 a9 00 	lds	r24, 0x00A9
    641e:	8f 7b       	andi	r24, 0xBF	; 191
    6420:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_OUT);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6424:	82 e0       	ldi	r24, 0x02	; 2
    6426:	43 df       	rcall	.-378    	; 0x62ae <USB_Host_WaitForIOS>
    6428:	88 23       	and	r24, r24
    642a:	09 f0       	breq	.+2      	; 0x642e <USB_Host_SendControlRequest+0x12c>
    642c:	52 c0       	rjmp	.+164    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    642e:	80 91 a6 00 	lds	r24, 0x00A6
    6432:	8b 77       	andi	r24, 0x7B	; 123
    6434:	80 93 a6 00 	sts	0x00A6, r24
		  return ReturnStatus;

		Pipe_ClearOUT();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6438:	82 e0       	ldi	r24, 0x02	; 2
    643a:	39 df       	rcall	.-398    	; 0x62ae <USB_Host_WaitForIOS>
    643c:	4a c0       	rjmp	.+148    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
		  return ReturnStatus;
	}
	else
	{
		if (DataStream != NULL)
    643e:	01 15       	cp	r16, r1
    6440:	11 05       	cpc	r17, r1
    6442:	99 f1       	breq	.+102    	; 0x64aa <USB_Host_SendControlRequest+0x1a8>
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    6444:	80 91 aa 00 	lds	r24, 0x00AA
    6448:	8f 7c       	andi	r24, 0xCF	; 207
    644a:	80 62       	ori	r24, 0x20	; 32
    644c:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    6450:	80 91 a9 00 	lds	r24, 0x00A9
    6454:	8f 7b       	andi	r24, 0xBF	; 191
    6456:	80 93 a9 00 	sts	0x00A9, r24
    645a:	1c c0       	rjmp	.+56     	; 0x6494 <USB_Host_SendControlRequest+0x192>
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    645c:	82 e0       	ldi	r24, 0x02	; 2
    645e:	27 df       	rcall	.-434    	; 0x62ae <USB_Host_WaitForIOS>
    6460:	88 23       	and	r24, r24
    6462:	b9 f5       	brne	.+110    	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
    6464:	f8 01       	movw	r30, r16
    6466:	06 c0       	rjmp	.+12     	; 0x6474 <USB_Host_SendControlRequest+0x172>
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
				{
					Pipe_Write_8(*(DataStream++));
    6468:	81 91       	ld	r24, Z+
    646a:	8f 01       	movw	r16, r30
			 *  \param[in] Data  Data to write into the the currently selected pipe's FIFO buffer.
			 */
			static inline void Pipe_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Write_8(const uint8_t Data)
			{
				UPDATX = Data;
    646c:	80 93 af 00 	sts	0x00AF, r24
					DataLen--;
    6470:	21 97       	sbiw	r28, 0x01	; 1
			while (DataLen)
			{
				if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
				  return ReturnStatus;

				while (DataLen && (Pipe_BytesInPipe() < USB_Host_ControlPipeSize))
    6472:	59 f0       	breq	.+22     	; 0x648a <USB_Host_SendControlRequest+0x188>
    6474:	8f 01       	movw	r16, r30
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    6476:	20 91 f6 00 	lds	r18, 0x00F6
    647a:	30 91 f7 00 	lds	r19, 0x00F7
    647e:	80 91 4d 03 	lds	r24, 0x034D
    6482:	90 e0       	ldi	r25, 0x00	; 0
    6484:	28 17       	cp	r18, r24
    6486:	39 07       	cpc	r19, r25
    6488:	78 f3       	brcs	.-34     	; 0x6468 <USB_Host_SendControlRequest+0x166>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    648a:	80 91 a6 00 	lds	r24, 0x00A6
    648e:	8b 77       	andi	r24, 0x7B	; 123
    6490:	80 93 a6 00 	sts	0x00A6, r24
		if (DataStream != NULL)
		{
			Pipe_SetPipeToken(PIPE_TOKEN_OUT);
			Pipe_Unfreeze();

			while (DataLen)
    6494:	20 97       	sbiw	r28, 0x00	; 0
    6496:	11 f7       	brne	.-60     	; 0x645c <USB_Host_SendControlRequest+0x15a>
				}

				Pipe_ClearOUT();
			}

			if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_OutReady)) != HOST_SENDCONTROL_Successful)
    6498:	82 e0       	ldi	r24, 0x02	; 2
    649a:	09 df       	rcall	.-494    	; 0x62ae <USB_Host_WaitForIOS>
    649c:	88 23       	and	r24, r24
    649e:	c9 f4       	brne	.+50     	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    64a0:	80 91 a9 00 	lds	r24, 0x00A9
    64a4:	80 64       	ori	r24, 0x40	; 64
    64a6:	80 93 a9 00 	sts	0x00A9, r24
			 *  \param[in] Token  New pipe token to set the selected pipe to, as a \c PIPE_TOKEN_* mask.
			 */
			static inline void Pipe_SetPipeToken(const uint8_t Token) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SetPipeToken(const uint8_t Token)
			{
				UPCFG0X = ((UPCFG0X & ~(0x03 << PTOKEN0)) | Token);
    64aa:	80 91 aa 00 	lds	r24, 0x00AA
    64ae:	8f 7c       	andi	r24, 0xCF	; 207
    64b0:	80 61       	ori	r24, 0x10	; 16
    64b2:	80 93 aa 00 	sts	0x00AA, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    64b6:	80 91 a9 00 	lds	r24, 0x00A9
    64ba:	8f 7b       	andi	r24, 0xBF	; 191
    64bc:	80 93 a9 00 	sts	0x00A9, r24
		}

		Pipe_SetPipeToken(PIPE_TOKEN_IN);
		Pipe_Unfreeze();

		if ((ReturnStatus = USB_Host_WaitForIOS(USB_HOST_WAITFOR_InReceived)) != HOST_SENDCONTROL_Successful)
    64c0:	81 e0       	ldi	r24, 0x01	; 1
    64c2:	f5 de       	rcall	.-534    	; 0x62ae <USB_Host_WaitForIOS>
    64c4:	88 23       	and	r24, r24
    64c6:	29 f4       	brne	.+10     	; 0x64d2 <USB_Host_SendControlRequest+0x1d0>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    64c8:	90 91 a6 00 	lds	r25, 0x00A6
    64cc:	9e 77       	andi	r25, 0x7E	; 126
    64ce:	90 93 a6 00 	sts	0x00A6, r25

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    64d2:	90 91 a9 00 	lds	r25, 0x00A9
    64d6:	90 64       	ori	r25, 0x40	; 64
    64d8:	90 93 a9 00 	sts	0x00A9, r25
	bool BusSuspended    = USB_Host_IsBusSuspended();
	uint8_t ReturnStatus = USB_Host_SendControlRequest_PRV(BufferPtr);

	Pipe_Freeze();

	if (BusSuspended)
    64dc:	e1 14       	cp	r14, r1
    64de:	f1 04       	cpc	r15, r1
    64e0:	29 f4       	brne	.+10     	; 0x64ec <USB_Host_SendControlRequest+0x1ea>
			 *             some events (such as device disconnections) will not fire until the bus is resumed.
			 */
			static inline void USB_Host_SuspendBus(void) ATTR_ALWAYS_INLINE;
			static inline void USB_Host_SuspendBus(void)
			{
				UHCON &= ~(1 << SOFEN);
    64e2:	90 91 9e 00 	lds	r25, 0x009E
    64e6:	9e 7f       	andi	r25, 0xFE	; 254
    64e8:	90 93 9e 00 	sts	0x009E, r25
			 *  \param[in] Address  Address of the pipe to reset.
			 */
			static inline void Pipe_ResetPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ResetPipe(const uint8_t Address)
			{
				UPRST = (1 << (Address & PIPE_PIPENUM_MASK));
    64ec:	91 e0       	ldi	r25, 0x01	; 1
    64ee:	90 93 a8 00 	sts	0x00A8, r25
				UPRST = 0;
    64f2:	10 92 a8 00 	sts	0x00A8, r1
	  USB_Host_SuspendBus();

	Pipe_ResetPipe(PIPE_CONTROLPIPE);

	return ReturnStatus;
}
    64f6:	df 91       	pop	r29
    64f8:	cf 91       	pop	r28
    64fa:	1f 91       	pop	r17
    64fc:	0f 91       	pop	r16
    64fe:	ff 90       	pop	r15
    6500:	ef 90       	pop	r14
    6502:	08 95       	ret

00006504 <USB_Host_SetDeviceConfiguration>:

uint8_t USB_Host_SetDeviceConfiguration(const uint8_t ConfigNumber)
{
    6504:	1f 93       	push	r17
    6506:	18 2f       	mov	r17, r24
	uint8_t ErrorCode;

	USB_ControlRequest = (USB_Request_Header_t)
    6508:	10 92 ae 0d 	sts	0x0DAE, r1
    650c:	89 e0       	ldi	r24, 0x09	; 9
    650e:	80 93 af 0d 	sts	0x0DAF, r24
    6512:	10 93 b0 0d 	sts	0x0DB0, r17
    6516:	10 92 b1 0d 	sts	0x0DB1, r1
    651a:	10 92 b3 0d 	sts	0x0DB3, r1
    651e:	10 92 b2 0d 	sts	0x0DB2, r1
    6522:	10 92 b5 0d 	sts	0x0DB5, r1
    6526:	10 92 b4 0d 	sts	0x0DB4, r1
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    652a:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = 0,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	if ((ErrorCode = USB_Host_SendControlRequest(NULL)) == HOST_SENDCONTROL_Successful)
    652e:	80 e0       	ldi	r24, 0x00	; 0
    6530:	90 e0       	ldi	r25, 0x00	; 0
    6532:	e7 de       	rcall	.-562    	; 0x6302 <USB_Host_SendControlRequest>
    6534:	88 23       	and	r24, r24
    6536:	41 f4       	brne	.+16     	; 0x6548 <USB_Host_SetDeviceConfiguration+0x44>
	{
		USB_Host_ConfigurationNumber = ConfigNumber;
    6538:	10 93 ac 0d 	sts	0x0DAC, r17
		USB_HostState                = (ConfigNumber) ? HOST_STATE_Configured : HOST_STATE_Addressed;
    653c:	11 23       	and	r17, r17
    653e:	11 f0       	breq	.+4      	; 0x6544 <USB_Host_SetDeviceConfiguration+0x40>
    6540:	9b e0       	ldi	r25, 0x0B	; 11
    6542:	01 c0       	rjmp	.+2      	; 0x6546 <USB_Host_SetDeviceConfiguration+0x42>
    6544:	9a e0       	ldi	r25, 0x0A	; 10
    6546:	9e bb       	out	0x1e, r25	; 30
	}

	return ErrorCode;
}
    6548:	1f 91       	pop	r17
    654a:	08 95       	ret

0000654c <USB_USBTask>:
#if defined(USB_CAN_BE_DEVICE) && !defined(DEVICE_STATE_AS_GPIOR)
volatile uint8_t     USB_DeviceState;
#endif

void USB_USBTask(void)
{
    654c:	1f 93       	push	r17
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
    654e:	80 91 d9 03 	lds	r24, 0x03D9
    6552:	81 30       	cpi	r24, 0x01	; 1
    6554:	c9 f4       	brne	.+50     	; 0x6588 <USB_USBTask+0x3c>
}

#if defined(USB_CAN_BE_DEVICE)
static void USB_DeviceTask(void)
{
	if (USB_DeviceState == DEVICE_STATE_Unattached)
    6556:	8e b3       	in	r24, 0x1e	; 30
    6558:	88 23       	and	r24, r24
    655a:	29 f1       	breq	.+74     	; 0x65a6 <USB_USBTask+0x5a>
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    655c:	80 91 e9 00 	lds	r24, 0x00E9
    6560:	8f 70       	andi	r24, 0x0F	; 15
			 *  \return The currently selected endpoint's direction, as a \c ENDPOINT_DIR_* mask.
			 */
			static inline uint8_t Endpoint_GetEndpointDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetEndpointDirection(void)
			{
				return (UECFG0X & (1 << EPDIR)) ? ENDPOINT_DIR_IN : ENDPOINT_DIR_OUT;
    6562:	90 91 ec 00 	lds	r25, 0x00EC
    6566:	90 ff       	sbrs	r25, 0
    6568:	02 c0       	rjmp	.+4      	; 0x656e <USB_USBTask+0x22>
    656a:	10 e8       	ldi	r17, 0x80	; 128
    656c:	01 c0       	rjmp	.+2      	; 0x6570 <USB_USBTask+0x24>
    656e:	10 e0       	ldi	r17, 0x00	; 0
			 */
			static inline uint8_t Endpoint_GetCurrentEndpoint(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Endpoint_GetCurrentEndpoint(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					return ((UENUM & ENDPOINT_EPNUM_MASK) | Endpoint_GetEndpointDirection());
    6570:	18 2b       	or	r17, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6572:	10 92 e9 00 	sts	0x00E9, r1
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    6576:	80 91 e8 00 	lds	r24, 0x00E8

	uint8_t PrevEndpoint = Endpoint_GetCurrentEndpoint();

	Endpoint_SelectEndpoint(ENDPOINT_CONTROLEP);

	if (Endpoint_IsSETUPReceived())
    657a:	83 ff       	sbrs	r24, 3
    657c:	01 c0       	rjmp	.+2      	; 0x6580 <USB_USBTask+0x34>
	  USB_Device_ProcessControlRequest();
    657e:	2e dd       	rcall	.-1444   	; 0x5fdc <USB_Device_ProcessControlRequest>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6580:	1f 70       	andi	r17, 0x0F	; 15
    6582:	10 93 e9 00 	sts	0x00E9, r17
    6586:	0f c0       	rjmp	.+30     	; 0x65a6 <USB_USBTask+0x5a>
void USB_USBTask(void)
{
	#if defined(USB_CAN_BE_BOTH)
		if (USB_CurrentMode == USB_MODE_Device)
		  USB_DeviceTask();
		else if (USB_CurrentMode == USB_MODE_Host)
    6588:	80 91 d9 03 	lds	r24, 0x03D9
    658c:	82 30       	cpi	r24, 0x02	; 2
    658e:	59 f4       	brne	.+22     	; 0x65a6 <USB_USBTask+0x5a>
			 *  \return Index of the currently selected pipe.
			 */
			static inline uint8_t Pipe_GetCurrentPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetCurrentPipe(void)
			{
				return ((UPNUM & PIPE_PIPENUM_MASK) | Pipe_GetPipeDirection());
    6590:	10 91 a7 00 	lds	r17, 0x00A7
    6594:	1f 70       	andi	r17, 0x0F	; 15
			 *  \return The currently selected pipe's direction, as a \c PIPE_DIR_* mask.
			 */
			static inline uint8_t Pipe_GetPipeDirection(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint8_t Pipe_GetPipeDirection(void)
			{
				return (UPCFG0X & (1 << EPDIR)) ? PIPE_DIR_IN : PIPE_DIR_OUT;
    6596:	80 91 aa 00 	lds	r24, 0x00AA
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    659a:	10 92 a7 00 	sts	0x00A7, r1
{
	uint8_t PrevPipe = Pipe_GetCurrentPipe();

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	USB_Host_ProcessNextHostState();
    659e:	0e 94 a9 29 	call	0x5352	; 0x5352 <USB_Host_ProcessNextHostState>
    65a2:	10 93 a7 00 	sts	0x00A7, r17
	#elif defined(USB_CAN_BE_HOST)
		USB_HostTask();
	#elif defined(USB_CAN_BE_DEVICE)
		USB_DeviceTask();
	#endif
}
    65a6:	1f 91       	pop	r17
    65a8:	08 95       	ret

000065aa <MS_Device_ProcessControlRequest>:
#define  __INCLUDE_FROM_MS_DRIVER
#define  __INCLUDE_FROM_MASSSTORAGE_DEVICE_C
#include "MassStorageClassDevice.h"

void MS_Device_ProcessControlRequest(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    65aa:	cf 93       	push	r28
    65ac:	df 93       	push	r29
    65ae:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    65b0:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    65b4:	83 ff       	sbrs	r24, 3
    65b6:	35 c0       	rjmp	.+106    	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
	  return;

	if (USB_ControlRequest.wIndex != MSInterfaceInfo->Config.InterfaceNumber)
    65b8:	88 81       	ld	r24, Y
    65ba:	90 e0       	ldi	r25, 0x00	; 0
    65bc:	20 91 b2 0d 	lds	r18, 0x0DB2
    65c0:	30 91 b3 0d 	lds	r19, 0x0DB3
    65c4:	28 17       	cp	r18, r24
    65c6:	39 07       	cpc	r19, r25
    65c8:	61 f5       	brne	.+88     	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
	  return;

	switch (USB_ControlRequest.bRequest)
    65ca:	80 91 af 0d 	lds	r24, 0x0DAF
    65ce:	8e 3f       	cpi	r24, 0xFE	; 254
    65d0:	81 f0       	breq	.+32     	; 0x65f2 <MS_Device_ProcessControlRequest+0x48>
    65d2:	8f 3f       	cpi	r24, 0xFF	; 255
    65d4:	31 f5       	brne	.+76     	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
	{
		case MS_REQ_MassStorageReset:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    65d6:	80 91 ae 0d 	lds	r24, 0x0DAE
    65da:	81 32       	cpi	r24, 0x21	; 33
    65dc:	11 f5       	brne	.+68     	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    65de:	80 91 e8 00 	lds	r24, 0x00E8
    65e2:	87 7f       	andi	r24, 0xF7	; 247
    65e4:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_ClearStatusStage();
    65e8:	0e 94 a9 28 	call	0x5152	; 0x5152 <Endpoint_ClearStatusStage>

				MSInterfaceInfo->State.IsMassStoreReset = true;
    65ec:	81 e0       	ldi	r24, 0x01	; 1
    65ee:	88 af       	std	Y+56, r24	; 0x38
    65f0:	18 c0       	rjmp	.+48     	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
			}

			break;
		case MS_REQ_GetMaxLUN:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    65f2:	80 91 ae 0d 	lds	r24, 0x0DAE
    65f6:	81 3a       	cpi	r24, 0xA1	; 161
    65f8:	a1 f4       	brne	.+40     	; 0x6622 <MS_Device_ProcessControlRequest+0x78>
    65fa:	80 91 e8 00 	lds	r24, 0x00E8
    65fe:	87 7f       	andi	r24, 0xF7	; 247
    6600:	80 93 e8 00 	sts	0x00E8, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6604:	80 91 e8 00 	lds	r24, 0x00E8
			{
				Endpoint_ClearSETUP();
				while (!(Endpoint_IsINReady()));
    6608:	80 ff       	sbrs	r24, 0
    660a:	fc cf       	rjmp	.-8      	; 0x6604 <MS_Device_ProcessControlRequest+0x5a>
				Endpoint_Write_8(MSInterfaceInfo->Config.TotalLUNs - 1);
    660c:	8b 85       	ldd	r24, Y+11	; 0x0b
    660e:	81 50       	subi	r24, 0x01	; 1
			 *  \param[in] Data  Data to write into the the currently selected endpoint's FIFO buffer.
			 */
			static inline void Endpoint_Write_8(const uint8_t Data) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_Write_8(const uint8_t Data)
			{
				UEDATX = Data;
    6610:	80 93 f1 00 	sts	0x00F1, r24
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6614:	80 91 e8 00 	lds	r24, 0x00E8
    6618:	8e 77       	andi	r24, 0x7E	; 126
    661a:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearIN();
				Endpoint_ClearStatusStage();
    661e:	0e 94 a9 28 	call	0x5152	; 0x5152 <Endpoint_ClearStatusStage>
			}

			break;
	}
}
    6622:	df 91       	pop	r29
    6624:	cf 91       	pop	r28
    6626:	08 95       	ret

00006628 <MS_Device_ConfigureEndpoints>:

bool MS_Device_ConfigureEndpoints(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6628:	cf 93       	push	r28
    662a:	df 93       	push	r29
    662c:	ec 01       	movw	r28, r24
	memset(&MSInterfaceInfo->State, 0x00, sizeof(MSInterfaceInfo->State));
    662e:	0c 96       	adiw	r24, 0x0c	; 12
    6630:	fc 01       	movw	r30, r24
    6632:	8d e2       	ldi	r24, 0x2D	; 45
    6634:	df 01       	movw	r26, r30
    6636:	1d 92       	st	X+, r1
    6638:	8a 95       	dec	r24
    663a:	e9 f7       	brne	.-6      	; 0x6636 <MS_Device_ConfigureEndpoints+0xe>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
    663c:	82 e0       	ldi	r24, 0x02	; 2
    663e:	8c 83       	std	Y+4, r24	; 0x04
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;
    6640:	89 87       	std	Y+9, r24	; 0x09

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
    6642:	ce 01       	movw	r24, r28
    6644:	01 96       	adiw	r24, 0x01	; 1
    6646:	61 e0       	ldi	r22, 0x01	; 1
    6648:	0e 94 65 28 	call	0x50ca	; 0x50ca <Endpoint_ConfigureEndpointTable>
    664c:	88 23       	and	r24, r24
    664e:	31 f0       	breq	.+12     	; 0x665c <MS_Device_ConfigureEndpoints+0x34>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6650:	ce 01       	movw	r24, r28
    6652:	06 96       	adiw	r24, 0x06	; 6
    6654:	61 e0       	ldi	r22, 0x01	; 1
    6656:	0e 94 65 28 	call	0x50ca	; 0x50ca <Endpoint_ConfigureEndpointTable>
    665a:	01 c0       	rjmp	.+2      	; 0x665e <MS_Device_ConfigureEndpoints+0x36>

	MSInterfaceInfo->Config.DataINEndpoint.Type  = EP_TYPE_BULK;
	MSInterfaceInfo->Config.DataOUTEndpoint.Type = EP_TYPE_BULK;

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;
    665c:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&MSInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;

	return true;
}
    665e:	df 91       	pop	r29
    6660:	cf 91       	pop	r28
    6662:	08 95       	ret

00006664 <MS_Device_USBTask>:

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
    6664:	cf 92       	push	r12
    6666:	df 92       	push	r13
    6668:	ef 92       	push	r14
    666a:	ff 92       	push	r15
    666c:	0f 93       	push	r16
    666e:	1f 93       	push	r17
    6670:	df 93       	push	r29
    6672:	cf 93       	push	r28
    6674:	00 d0       	rcall	.+0      	; 0x6676 <MS_Device_USBTask+0x12>
    6676:	cd b7       	in	r28, 0x3d	; 61
    6678:	de b7       	in	r29, 0x3e	; 62
    667a:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    667c:	8e b3       	in	r24, 0x1e	; 30
    667e:	84 30       	cpi	r24, 0x04	; 4
    6680:	09 f0       	breq	.+2      	; 0x6684 <MS_Device_USBTask+0x20>
    6682:	18 c1       	rjmp	.+560    	; 0x68b4 <MS_Device_USBTask+0x250>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6684:	f8 01       	movw	r30, r16
    6686:	86 81       	ldd	r24, Z+6	; 0x06
    6688:	8f 70       	andi	r24, 0x0F	; 15
    668a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    668e:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	if (Endpoint_IsOUTReceived())
    6692:	82 ff       	sbrs	r24, 2
    6694:	d5 c0       	rjmp	.+426    	; 0x6840 <MS_Device_USBTask+0x1dc>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6696:	86 81       	ldd	r24, Z+6	; 0x06
    6698:	8f 70       	andi	r24, 0x0F	; 15
    669a:	80 93 e9 00 	sts	0x00E9, r24
{
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);
	
	BytesProcessed = 0;
    669e:	1a 82       	std	Y+2, r1	; 0x02
    66a0:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    66a2:	2c e0       	ldi	r18, 0x0C	; 12
    66a4:	c2 2e       	mov	r12, r18
    66a6:	d1 2c       	mov	r13, r1
    66a8:	c0 0e       	add	r12, r16
    66aa:	d1 1e       	adc	r13, r17
    66ac:	7e 01       	movw	r14, r28
    66ae:	08 94       	sec
    66b0:	e1 1c       	adc	r14, r1
    66b2:	f1 1c       	adc	r15, r1
    66b4:	05 c0       	rjmp	.+10     	; 0x66c0 <MS_Device_USBTask+0x5c>
	                               (sizeof(MS_CommandBlockWrapper_t) - 16), &BytesProcessed) ==
	                               ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    66b6:	f8 01       	movw	r30, r16
    66b8:	80 ad       	ldd	r24, Z+56	; 0x38
    66ba:	88 23       	and	r24, r24
    66bc:	09 f0       	breq	.+2      	; 0x66c0 <MS_Device_USBTask+0x5c>
    66be:	c0 c0       	rjmp	.+384    	; 0x6840 <MS_Device_USBTask+0x1dc>
	uint16_t BytesProcessed;

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);
	
	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock,
    66c0:	c6 01       	movw	r24, r12
    66c2:	6f e0       	ldi	r22, 0x0F	; 15
    66c4:	70 e0       	ldi	r23, 0x00	; 0
    66c6:	a7 01       	movw	r20, r14
    66c8:	0e 94 db 26 	call	0x4db6	; 0x4db6 <Endpoint_Read_Stream_LE>
    66cc:	85 30       	cpi	r24, 0x05	; 5
    66ce:	99 f3       	breq	.-26     	; 0x66b6 <MS_Device_USBTask+0x52>
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
    66d0:	f8 01       	movw	r30, r16
    66d2:	84 85       	ldd	r24, Z+12	; 0x0c
    66d4:	95 85       	ldd	r25, Z+13	; 0x0d
    66d6:	a6 85       	ldd	r26, Z+14	; 0x0e
    66d8:	b7 85       	ldd	r27, Z+15	; 0x0f
    66da:	85 35       	cpi	r24, 0x55	; 85
    66dc:	f3 e5       	ldi	r31, 0x53	; 83
    66de:	9f 07       	cpc	r25, r31
    66e0:	f2 e4       	ldi	r31, 0x42	; 66
    66e2:	af 07       	cpc	r26, r31
    66e4:	f3 e4       	ldi	r31, 0x43	; 67
    66e6:	bf 07       	cpc	r27, r31
    66e8:	81 f4       	brne	.+32     	; 0x670a <MS_Device_USBTask+0xa6>
    66ea:	f8 01       	movw	r30, r16
    66ec:	91 8d       	ldd	r25, Z+25	; 0x19
    66ee:	83 85       	ldd	r24, Z+11	; 0x0b
    66f0:	98 17       	cp	r25, r24
    66f2:	58 f4       	brcc	.+22     	; 0x670a <MS_Device_USBTask+0xa6>
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    66f4:	80 8d       	ldd	r24, Z+24	; 0x18
    66f6:	90 e0       	ldi	r25, 0x00	; 0
    66f8:	8f 71       	andi	r24, 0x1F	; 31
    66fa:	90 70       	andi	r25, 0x00	; 0
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
    66fc:	00 97       	sbiw	r24, 0x00	; 0
    66fe:	29 f4       	brne	.+10     	; 0x670a <MS_Device_USBTask+0xa6>
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
    6700:	82 8d       	ldd	r24, Z+26	; 0x1a
		  return false;
	}

	if ((MSInterfaceInfo->State.CommandBlock.Signature         != CPU_TO_LE32(MS_CBW_SIGNATURE))     ||
	    (MSInterfaceInfo->State.CommandBlock.LUN               >= MSInterfaceInfo->Config.TotalLUNs) ||
		(MSInterfaceInfo->State.CommandBlock.Flags              & 0x1F)                              ||
    6702:	88 23       	and	r24, r24
    6704:	11 f0       	breq	.+4      	; 0x670a <MS_Device_USBTask+0xa6>
		(MSInterfaceInfo->State.CommandBlock.SCSICommandLength == 0)                                 ||
    6706:	81 31       	cpi	r24, 0x11	; 17
    6708:	80 f0       	brcs	.+32     	; 0x672a <MS_Device_USBTask+0xc6>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    670a:	80 91 eb 00 	lds	r24, 0x00EB
    670e:	80 62       	ori	r24, 0x20	; 32
    6710:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6714:	f8 01       	movw	r30, r16
    6716:	81 81       	ldd	r24, Z+1	; 0x01
    6718:	8f 70       	andi	r24, 0x0F	; 15
    671a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    671e:	80 91 eb 00 	lds	r24, 0x00EB
    6722:	80 62       	ori	r24, 0x20	; 32
    6724:	80 93 eb 00 	sts	0x00EB, r24
    6728:	8b c0       	rjmp	.+278    	; 0x6840 <MS_Device_USBTask+0x1dc>
		Endpoint_StallTransaction();

		return false;
	}

	BytesProcessed = 0;
    672a:	1a 82       	std	Y+2, r1	; 0x02
    672c:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    672e:	9b e1       	ldi	r25, 0x1B	; 27
    6730:	c9 2e       	mov	r12, r25
    6732:	d1 2c       	mov	r13, r1
    6734:	c0 0e       	add	r12, r16
    6736:	d1 1e       	adc	r13, r17
    6738:	7e 01       	movw	r14, r28
    673a:	08 94       	sec
    673c:	e1 1c       	adc	r14, r1
    673e:	f1 1c       	adc	r15, r1
    6740:	05 c0       	rjmp	.+10     	; 0x674c <MS_Device_USBTask+0xe8>
	                                MSInterfaceInfo->State.CommandBlock.SCSICommandLength, &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    6742:	f8 01       	movw	r30, r16
    6744:	80 ad       	ldd	r24, Z+56	; 0x38
    6746:	88 23       	and	r24, r24
    6748:	09 f0       	breq	.+2      	; 0x674c <MS_Device_USBTask+0xe8>
    674a:	7a c0       	rjmp	.+244    	; 0x6840 <MS_Device_USBTask+0x1dc>

		return false;
	}

	BytesProcessed = 0;
	while (Endpoint_Read_Stream_LE(&MSInterfaceInfo->State.CommandBlock.SCSICommandData,
    674c:	f8 01       	movw	r30, r16
    674e:	62 8d       	ldd	r22, Z+26	; 0x1a
    6750:	c6 01       	movw	r24, r12
    6752:	70 e0       	ldi	r23, 0x00	; 0
    6754:	a7 01       	movw	r20, r14
    6756:	0e 94 db 26 	call	0x4db6	; 0x4db6 <Endpoint_Read_Stream_LE>
    675a:	85 30       	cpi	r24, 0x05	; 5
    675c:	91 f3       	breq	.-28     	; 0x6742 <MS_Device_USBTask+0xde>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    675e:	80 91 e8 00 	lds	r24, 0x00E8
    6762:	8b 77       	andi	r24, 0x7B	; 123
    6764:	80 93 e8 00 	sts	0x00E8, r24

	if (Endpoint_IsOUTReceived())
	{
		if (MS_Device_ReadInCommandBlock(MSInterfaceInfo))
		{
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
    6768:	f8 01       	movw	r30, r16
    676a:	80 8d       	ldd	r24, Z+24	; 0x18
    676c:	87 ff       	sbrs	r24, 7
    676e:	04 c0       	rjmp	.+8      	; 0x6778 <MS_Device_USBTask+0x114>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6770:	81 81       	ldd	r24, Z+1	; 0x01
    6772:	8f 70       	andi	r24, 0x0F	; 15
    6774:	80 93 e9 00 	sts	0x00E9, r24
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);
    6778:	c8 01       	movw	r24, r16
    677a:	0e 94 cb 02 	call	0x596	; 0x596 <CALLBACK_MS_Device_SCSICommandReceived>
	  return false;

	return true;
}

void MS_Device_USBTask(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
    677e:	91 e0       	ldi	r25, 0x01	; 1
    6780:	98 27       	eor	r25, r24
			if (MSInterfaceInfo->State.CommandBlock.Flags & MS_COMMAND_DIR_DATA_IN)
			  Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

			bool SCSICommandResult = CALLBACK_MS_Device_SCSICommandReceived(MSInterfaceInfo);

			MSInterfaceInfo->State.CommandStatus.Status              = (SCSICommandResult) ? MS_SCSI_COMMAND_Pass : MS_SCSI_COMMAND_Fail;
    6782:	f8 01       	movw	r30, r16
    6784:	97 ab       	std	Z+55, r25	; 0x37
			MSInterfaceInfo->State.CommandStatus.Signature           = CPU_TO_LE32(MS_CSW_SIGNATURE);
    6786:	25 e5       	ldi	r18, 0x55	; 85
    6788:	33 e5       	ldi	r19, 0x53	; 83
    678a:	42 e4       	ldi	r20, 0x42	; 66
    678c:	53 e5       	ldi	r21, 0x53	; 83
    678e:	23 a7       	std	Z+43, r18	; 0x2b
    6790:	34 a7       	std	Z+44, r19	; 0x2c
    6792:	45 a7       	std	Z+45, r20	; 0x2d
    6794:	56 a7       	std	Z+46, r21	; 0x2e
			MSInterfaceInfo->State.CommandStatus.Tag                 = MSInterfaceInfo->State.CommandBlock.Tag;
    6796:	20 89       	ldd	r18, Z+16	; 0x10
    6798:	31 89       	ldd	r19, Z+17	; 0x11
    679a:	42 89       	ldd	r20, Z+18	; 0x12
    679c:	53 89       	ldd	r21, Z+19	; 0x13
    679e:	27 a7       	std	Z+47, r18	; 0x2f
    67a0:	30 ab       	std	Z+48, r19	; 0x30
    67a2:	41 ab       	std	Z+49, r20	; 0x31
    67a4:	52 ab       	std	Z+50, r21	; 0x32
			MSInterfaceInfo->State.CommandStatus.DataTransferResidue = MSInterfaceInfo->State.CommandBlock.DataTransferLength;
    67a6:	24 89       	ldd	r18, Z+20	; 0x14
    67a8:	35 89       	ldd	r19, Z+21	; 0x15
    67aa:	46 89       	ldd	r20, Z+22	; 0x16
    67ac:	57 89       	ldd	r21, Z+23	; 0x17
    67ae:	23 ab       	std	Z+51, r18	; 0x33
    67b0:	34 ab       	std	Z+52, r19	; 0x34
    67b2:	45 ab       	std	Z+53, r20	; 0x35
    67b4:	56 ab       	std	Z+54, r21	; 0x36

			if (!(SCSICommandResult) && (le32_to_cpu(MSInterfaceInfo->State.CommandStatus.DataTransferResidue)))
    67b6:	88 23       	and	r24, r24
    67b8:	51 f4       	brne	.+20     	; 0x67ce <MS_Device_USBTask+0x16a>
    67ba:	21 15       	cp	r18, r1
    67bc:	31 05       	cpc	r19, r1
    67be:	41 05       	cpc	r20, r1
    67c0:	51 05       	cpc	r21, r1
    67c2:	29 f0       	breq	.+10     	; 0x67ce <MS_Device_USBTask+0x16a>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    67c4:	80 91 eb 00 	lds	r24, 0x00EB
    67c8:	80 62       	ori	r24, 0x20	; 32
    67ca:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    67ce:	f8 01       	movw	r30, r16
    67d0:	86 81       	ldd	r24, Z+6	; 0x06
    67d2:	8f 70       	andi	r24, 0x0F	; 15
    67d4:	80 93 e9 00 	sts	0x00E9, r24
    67d8:	04 c0       	rjmp	.+8      	; 0x67e2 <MS_Device_USBTask+0x17e>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    67da:	f8 01       	movw	r30, r16
    67dc:	80 ad       	ldd	r24, Z+56	; 0x38
    67de:	88 23       	and	r24, r24
    67e0:	79 f5       	brne	.+94     	; 0x6840 <MS_Device_USBTask+0x1dc>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    67e2:	80 91 eb 00 	lds	r24, 0x00EB

static void MS_Device_ReturnCommandStatus(USB_ClassInfo_MS_Device_t* const MSInterfaceInfo)
{
	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataOUTEndpoint.Address);

	while (Endpoint_IsStalled())
    67e6:	85 fd       	sbrc	r24, 5
    67e8:	f8 cf       	rjmp	.-16     	; 0x67da <MS_Device_USBTask+0x176>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    67ea:	f8 01       	movw	r30, r16
    67ec:	81 81       	ldd	r24, Z+1	; 0x01
    67ee:	8f 70       	andi	r24, 0x0F	; 15
    67f0:	80 93 e9 00 	sts	0x00E9, r24
    67f4:	04 c0       	rjmp	.+8      	; 0x67fe <MS_Device_USBTask+0x19a>
	{
		#if !defined(INTERRUPT_CONTROL_ENDPOINT)
		USB_USBTask();
		#endif

		if (MSInterfaceInfo->State.IsMassStoreReset)
    67f6:	f8 01       	movw	r30, r16
    67f8:	80 ad       	ldd	r24, Z+56	; 0x38
    67fa:	88 23       	and	r24, r24
    67fc:	09 f5       	brne	.+66     	; 0x6840 <MS_Device_USBTask+0x1dc>
			 *  \return Boolean \c true if the currently selected endpoint is stalled, \c false otherwise.
			 */
			static inline bool Endpoint_IsStalled(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsStalled(void)
			{
				return ((UECONX & (1 << STALLRQ)) ? true : false);
    67fe:	80 91 eb 00 	lds	r24, 0x00EB
		  return;
	}

	Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);

	while (Endpoint_IsStalled())
    6802:	85 fd       	sbrc	r24, 5
    6804:	f8 cf       	rjmp	.-16     	; 0x67f6 <MS_Device_USBTask+0x192>

		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
    6806:	1a 82       	std	Y+2, r1	; 0x02
    6808:	19 82       	std	Y+1, r1	; 0x01
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    680a:	8b e2       	ldi	r24, 0x2B	; 43
    680c:	c8 2e       	mov	r12, r24
    680e:	d1 2c       	mov	r13, r1
    6810:	c0 0e       	add	r12, r16
    6812:	d1 1e       	adc	r13, r17
    6814:	7e 01       	movw	r14, r28
    6816:	08 94       	sec
    6818:	e1 1c       	adc	r14, r1
    681a:	f1 1c       	adc	r15, r1
    681c:	04 c0       	rjmp	.+8      	; 0x6826 <MS_Device_USBTask+0x1c2>
	                                sizeof(MS_CommandStatusWrapper_t), &BytesProcessed) ==
	                                ENDPOINT_RWSTREAM_IncompleteTransfer)
	{
		if (MSInterfaceInfo->State.IsMassStoreReset)
    681e:	f8 01       	movw	r30, r16
    6820:	80 ad       	ldd	r24, Z+56	; 0x38
    6822:	88 23       	and	r24, r24
    6824:	69 f4       	brne	.+26     	; 0x6840 <MS_Device_USBTask+0x1dc>
		if (MSInterfaceInfo->State.IsMassStoreReset)
		  return;
	}

	uint16_t BytesProcessed = 0;
	while (Endpoint_Write_Stream_LE(&MSInterfaceInfo->State.CommandStatus,
    6826:	c6 01       	movw	r24, r12
    6828:	6d e0       	ldi	r22, 0x0D	; 13
    682a:	70 e0       	ldi	r23, 0x00	; 0
    682c:	a7 01       	movw	r20, r14
    682e:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>
    6832:	85 30       	cpi	r24, 0x05	; 5
    6834:	a1 f3       	breq	.-24     	; 0x681e <MS_Device_USBTask+0x1ba>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6836:	80 91 e8 00 	lds	r24, 0x00E8
    683a:	8e 77       	andi	r24, 0x7E	; 126
    683c:	80 93 e8 00 	sts	0x00E8, r24

			MS_Device_ReturnCommandStatus(MSInterfaceInfo);
		}
	}

	if (MSInterfaceInfo->State.IsMassStoreReset)
    6840:	f8 01       	movw	r30, r16
    6842:	80 ad       	ldd	r24, Z+56	; 0x38
    6844:	88 23       	and	r24, r24
    6846:	b1 f1       	breq	.+108    	; 0x68b4 <MS_Device_USBTask+0x250>
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6848:	26 81       	ldd	r18, Z+6	; 0x06
    684a:	2f 70       	andi	r18, 0x0F	; 15
    684c:	81 e0       	ldi	r24, 0x01	; 1
    684e:	90 e0       	ldi	r25, 0x00	; 0
    6850:	ac 01       	movw	r20, r24
    6852:	02 c0       	rjmp	.+4      	; 0x6858 <MS_Device_USBTask+0x1f4>
    6854:	44 0f       	add	r20, r20
    6856:	55 1f       	adc	r21, r21
    6858:	2a 95       	dec	r18
    685a:	e2 f7       	brpl	.-8      	; 0x6854 <MS_Device_USBTask+0x1f0>
    685c:	40 93 ea 00 	sts	0x00EA, r20
				UERST = 0;
    6860:	10 92 ea 00 	sts	0x00EA, r1
			 *  \param[in] Address  Endpoint address whose FIFO buffers are to be reset.
			 */
			static inline void Endpoint_ResetEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetEndpoint(const uint8_t Address)
			{
				UERST = (1 << (Address & ENDPOINT_EPNUM_MASK));
    6864:	21 81       	ldd	r18, Z+1	; 0x01
    6866:	2f 70       	andi	r18, 0x0F	; 15
    6868:	02 c0       	rjmp	.+4      	; 0x686e <MS_Device_USBTask+0x20a>
    686a:	88 0f       	add	r24, r24
    686c:	99 1f       	adc	r25, r25
    686e:	2a 95       	dec	r18
    6870:	e2 f7       	brpl	.-8      	; 0x686a <MS_Device_USBTask+0x206>
    6872:	80 93 ea 00 	sts	0x00EA, r24
				UERST = 0;
    6876:	10 92 ea 00 	sts	0x00EA, r1
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    687a:	86 81       	ldd	r24, Z+6	; 0x06
    687c:	8f 70       	andi	r24, 0x0F	; 15
    687e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    6882:	80 91 eb 00 	lds	r24, 0x00EB
    6886:	80 61       	ori	r24, 0x10	; 16
    6888:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    688c:	80 91 eb 00 	lds	r24, 0x00EB
    6890:	88 60       	ori	r24, 0x08	; 8
    6892:	80 93 eb 00 	sts	0x00EB, r24
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6896:	81 81       	ldd	r24, Z+1	; 0x01
    6898:	8f 70       	andi	r24, 0x0F	; 15
    689a:	80 93 e9 00 	sts	0x00E9, r24
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_ClearStall(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearStall(void)
			{
				UECONX |= (1 << STALLRQC);
    689e:	80 91 eb 00 	lds	r24, 0x00EB
    68a2:	80 61       	ori	r24, 0x10	; 16
    68a4:	80 93 eb 00 	sts	0x00EB, r24

			/** Resets the data toggle of the currently selected endpoint. */
			static inline void Endpoint_ResetDataToggle(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ResetDataToggle(void)
			{
				UECONX |= (1 << RSTDT);
    68a8:	80 91 eb 00 	lds	r24, 0x00EB
    68ac:	88 60       	ori	r24, 0x08	; 8
    68ae:	80 93 eb 00 	sts	0x00EB, r24
		Endpoint_ResetDataToggle();
		Endpoint_SelectEndpoint(MSInterfaceInfo->Config.DataINEndpoint.Address);
		Endpoint_ClearStall();
		Endpoint_ResetDataToggle();

		MSInterfaceInfo->State.IsMassStoreReset = false;
    68b2:	10 ae       	std	Z+56, r1	; 0x38
	}
}
    68b4:	0f 90       	pop	r0
    68b6:	0f 90       	pop	r0
    68b8:	cf 91       	pop	r28
    68ba:	df 91       	pop	r29
    68bc:	1f 91       	pop	r17
    68be:	0f 91       	pop	r16
    68c0:	ff 90       	pop	r15
    68c2:	ef 90       	pop	r14
    68c4:	df 90       	pop	r13
    68c6:	cf 90       	pop	r12
    68c8:	08 95       	ret

000068ca <RNDIS_Device_ProcessControlRequest>:
		CPU_TO_LE32(OID_802_3_XMIT_ONE_COLLISION),
		CPU_TO_LE32(OID_802_3_XMIT_MORE_COLLISIONS),
	};

void RNDIS_Device_ProcessControlRequest(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    68ca:	ef 92       	push	r14
    68cc:	ff 92       	push	r15
    68ce:	0f 93       	push	r16
    68d0:	1f 93       	push	r17
    68d2:	cf 93       	push	r28
    68d4:	df 93       	push	r29
    68d6:	ec 01       	movw	r28, r24
			 *  \return Boolean \c true if the selected endpoint has received a SETUP packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsSETUPReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsSETUPReceived(void)
			{
				return ((UEINTX & (1 << RXSTPI)) ? true : false);
    68d8:	80 91 e8 00 	lds	r24, 0x00E8
	if (!(Endpoint_IsSETUPReceived()))
    68dc:	83 ff       	sbrs	r24, 3
    68de:	ca c2       	rjmp	.+1428   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
	  return;

	if (USB_ControlRequest.wIndex != RNDISInterfaceInfo->Config.ControlInterfaceNumber)
    68e0:	88 81       	ld	r24, Y
    68e2:	90 e0       	ldi	r25, 0x00	; 0
    68e4:	20 91 b2 0d 	lds	r18, 0x0DB2
    68e8:	30 91 b3 0d 	lds	r19, 0x0DB3
    68ec:	28 17       	cp	r18, r24
    68ee:	39 07       	cpc	r19, r25
    68f0:	09 f0       	breq	.+2      	; 0x68f4 <RNDIS_Device_ProcessControlRequest+0x2a>
    68f2:	c0 c2       	rjmp	.+1408   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
	  return;

	switch (USB_ControlRequest.bRequest)
    68f4:	80 91 af 0d 	lds	r24, 0x0DAF
    68f8:	88 23       	and	r24, r24
    68fa:	21 f0       	breq	.+8      	; 0x6904 <RNDIS_Device_ProcessControlRequest+0x3a>
    68fc:	81 30       	cpi	r24, 0x01	; 1
    68fe:	09 f0       	breq	.+2      	; 0x6902 <RNDIS_Device_ProcessControlRequest+0x38>
    6900:	b9 c2       	rjmp	.+1394   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
    6902:	6c c2       	rjmp	.+1240   	; 0x6ddc <RNDIS_Device_ProcessControlRequest+0x512>
	{
		case RNDIS_REQ_SendEncapsulatedCommand:
			if (USB_ControlRequest.bmRequestType == (REQDIR_HOSTTODEVICE | REQTYPE_CLASS | REQREC_INTERFACE))
    6904:	80 91 ae 0d 	lds	r24, 0x0DAE
    6908:	81 32       	cpi	r24, 0x21	; 33
    690a:	09 f0       	breq	.+2      	; 0x690e <RNDIS_Device_ProcessControlRequest+0x44>
    690c:	b3 c2       	rjmp	.+1382   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    690e:	80 91 e8 00 	lds	r24, 0x00E8
    6912:	87 7f       	andi	r24, 0xF7	; 247
    6914:	80 93 e8 00 	sts	0x00E8, r24
			{
				Endpoint_ClearSETUP();
				Endpoint_Read_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, USB_ControlRequest.wLength);
    6918:	8e 01       	movw	r16, r28
    691a:	08 5e       	subi	r16, 0xE8	; 232
    691c:	1f 4f       	sbci	r17, 0xFF	; 255
    691e:	60 91 b4 0d 	lds	r22, 0x0DB4
    6922:	70 91 b5 0d 	lds	r23, 0x0DB5
    6926:	c8 01       	movw	r24, r16
    6928:	0e 94 93 27 	call	0x4f26	; 0x4f26 <Endpoint_Read_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    692c:	80 91 e8 00 	lds	r24, 0x00E8
    6930:	8e 77       	andi	r24, 0x7E	; 126
    6932:	80 93 e8 00 	sts	0x00E8, r24
	/* Note: Only a single buffer is used for both the received message and its response to save SRAM. Because of
	         this, response bytes should be filled in order so that they do not clobber unread data in the buffer. */

	RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

	switch (le32_to_cpu(MessageHeader->MessageType))
    6936:	88 8d       	ldd	r24, Y+24	; 0x18
    6938:	99 8d       	ldd	r25, Y+25	; 0x19
    693a:	aa 8d       	ldd	r26, Y+26	; 0x1a
    693c:	bb 8d       	ldd	r27, Y+27	; 0x1b
    693e:	84 30       	cpi	r24, 0x04	; 4
    6940:	91 05       	cpc	r25, r1
    6942:	a1 05       	cpc	r26, r1
    6944:	b1 05       	cpc	r27, r1
    6946:	09 f4       	brne	.+2      	; 0x694a <RNDIS_Device_ProcessControlRequest+0x80>
    6948:	7b c0       	rjmp	.+246    	; 0x6a40 <RNDIS_Device_ProcessControlRequest+0x176>
    694a:	85 30       	cpi	r24, 0x05	; 5
    694c:	91 05       	cpc	r25, r1
    694e:	a1 05       	cpc	r26, r1
    6950:	b1 05       	cpc	r27, r1
    6952:	60 f4       	brcc	.+24     	; 0x696c <RNDIS_Device_ProcessControlRequest+0xa2>
    6954:	82 30       	cpi	r24, 0x02	; 2
    6956:	91 05       	cpc	r25, r1
    6958:	a1 05       	cpc	r26, r1
    695a:	b1 05       	cpc	r27, r1
    695c:	d1 f0       	breq	.+52     	; 0x6992 <RNDIS_Device_ProcessControlRequest+0xc8>
    695e:	83 30       	cpi	r24, 0x03	; 3
    6960:	91 05       	cpc	r25, r1
    6962:	a1 05       	cpc	r26, r1
    6964:	b1 05       	cpc	r27, r1
    6966:	09 f0       	breq	.+2      	; 0x696a <RNDIS_Device_ProcessControlRequest+0xa0>
    6968:	85 c2       	rjmp	.+1290   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
    696a:	5d c0       	rjmp	.+186    	; 0x6a26 <RNDIS_Device_ProcessControlRequest+0x15c>
    696c:	86 30       	cpi	r24, 0x06	; 6
    696e:	91 05       	cpc	r25, r1
    6970:	a1 05       	cpc	r26, r1
    6972:	b1 05       	cpc	r27, r1
    6974:	09 f4       	brne	.+2      	; 0x6978 <RNDIS_Device_ProcessControlRequest+0xae>
    6976:	fc c1       	rjmp	.+1016   	; 0x6d70 <RNDIS_Device_ProcessControlRequest+0x4a6>
    6978:	86 30       	cpi	r24, 0x06	; 6
    697a:	91 05       	cpc	r25, r1
    697c:	a1 05       	cpc	r26, r1
    697e:	b1 05       	cpc	r27, r1
    6980:	08 f4       	brcc	.+2      	; 0x6984 <RNDIS_Device_ProcessControlRequest+0xba>
    6982:	a1 c1       	rjmp	.+834    	; 0x6cc6 <RNDIS_Device_ProcessControlRequest+0x3fc>
    6984:	88 30       	cpi	r24, 0x08	; 8
    6986:	91 05       	cpc	r25, r1
    6988:	a1 05       	cpc	r26, r1
    698a:	b1 05       	cpc	r27, r1
    698c:	09 f0       	breq	.+2      	; 0x6990 <RNDIS_Device_ProcessControlRequest+0xc6>
    698e:	72 c2       	rjmp	.+1252   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
    6990:	0a c2       	rjmp	.+1044   	; 0x6da6 <RNDIS_Device_ProcessControlRequest+0x4dc>
	{
		case REMOTE_NDIS_INITIALIZE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6992:	fe 01       	movw	r30, r28
    6994:	e8 56       	subi	r30, 0x68	; 104
    6996:	ff 4f       	sbci	r31, 0xFF	; 255
    6998:	21 e0       	ldi	r18, 0x01	; 1
    699a:	20 83       	st	Z, r18
			RNDIS_Initialize_Message_t*  INITIALIZE_Message  =
			               (RNDIS_Initialize_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Initialize_Complete_t* INITIALIZE_Response =
			               (RNDIS_Initialize_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			INITIALIZE_Response->MessageType            = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_CMPLT);
    699c:	82 e0       	ldi	r24, 0x02	; 2
    699e:	90 e0       	ldi	r25, 0x00	; 0
    69a0:	a0 e0       	ldi	r26, 0x00	; 0
    69a2:	b0 e8       	ldi	r27, 0x80	; 128
    69a4:	88 8f       	std	Y+24, r24	; 0x18
    69a6:	99 8f       	std	Y+25, r25	; 0x19
    69a8:	aa 8f       	std	Y+26, r26	; 0x1a
    69aa:	bb 8f       	std	Y+27, r27	; 0x1b
			INITIALIZE_Response->MessageLength          = CPU_TO_LE32(sizeof(RNDIS_Initialize_Complete_t));
    69ac:	84 e3       	ldi	r24, 0x34	; 52
    69ae:	90 e0       	ldi	r25, 0x00	; 0
    69b0:	a0 e0       	ldi	r26, 0x00	; 0
    69b2:	b0 e0       	ldi	r27, 0x00	; 0
    69b4:	f8 01       	movw	r30, r16
    69b6:	84 83       	std	Z+4, r24	; 0x04
    69b8:	95 83       	std	Z+5, r25	; 0x05
    69ba:	a6 83       	std	Z+6, r26	; 0x06
    69bc:	b7 83       	std	Z+7, r27	; 0x07
			INITIALIZE_Response->RequestId              = INITIALIZE_Message->RequestId;
			INITIALIZE_Response->Status                 = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    69be:	14 86       	std	Z+12, r1	; 0x0c
    69c0:	15 86       	std	Z+13, r1	; 0x0d
    69c2:	16 86       	std	Z+14, r1	; 0x0e
    69c4:	17 86       	std	Z+15, r1	; 0x0f

			INITIALIZE_Response->MajorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    69c6:	81 e0       	ldi	r24, 0x01	; 1
    69c8:	90 e0       	ldi	r25, 0x00	; 0
    69ca:	a0 e0       	ldi	r26, 0x00	; 0
    69cc:	b0 e0       	ldi	r27, 0x00	; 0
    69ce:	80 8b       	std	Z+16, r24	; 0x10
    69d0:	91 8b       	std	Z+17, r25	; 0x11
    69d2:	a2 8b       	std	Z+18, r26	; 0x12
    69d4:	b3 8b       	std	Z+19, r27	; 0x13
			INITIALIZE_Response->MinorVersion           = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    69d6:	14 8a       	std	Z+20, r1	; 0x14
    69d8:	15 8a       	std	Z+21, r1	; 0x15
    69da:	16 8a       	std	Z+22, r1	; 0x16
    69dc:	17 8a       	std	Z+23, r1	; 0x17
			INITIALIZE_Response->DeviceFlags            = CPU_TO_LE32(REMOTE_NDIS_DF_CONNECTIONLESS);
    69de:	80 8f       	std	Z+24, r24	; 0x18
    69e0:	91 8f       	std	Z+25, r25	; 0x19
    69e2:	a2 8f       	std	Z+26, r26	; 0x1a
    69e4:	b3 8f       	std	Z+27, r27	; 0x1b
			INITIALIZE_Response->Medium                 = CPU_TO_LE32(REMOTE_NDIS_MEDIUM_802_3);
    69e6:	14 8e       	std	Z+28, r1	; 0x1c
    69e8:	15 8e       	std	Z+29, r1	; 0x1d
    69ea:	16 8e       	std	Z+30, r1	; 0x1e
    69ec:	17 8e       	std	Z+31, r1	; 0x1f
			INITIALIZE_Response->MaxPacketsPerTransfer  = CPU_TO_LE32(1);
    69ee:	80 a3       	std	Z+32, r24	; 0x20
    69f0:	91 a3       	std	Z+33, r25	; 0x21
    69f2:	a2 a3       	std	Z+34, r26	; 0x22
    69f4:	b3 a3       	std	Z+35, r27	; 0x23
			INITIALIZE_Response->MaxTransferSize        = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + ETHERNET_FRAME_SIZE_MAX);
    69f6:	88 e0       	ldi	r24, 0x08	; 8
    69f8:	96 e0       	ldi	r25, 0x06	; 6
    69fa:	a0 e0       	ldi	r26, 0x00	; 0
    69fc:	b0 e0       	ldi	r27, 0x00	; 0
    69fe:	84 a3       	std	Z+36, r24	; 0x24
    6a00:	95 a3       	std	Z+37, r25	; 0x25
    6a02:	a6 a3       	std	Z+38, r26	; 0x26
    6a04:	b7 a3       	std	Z+39, r27	; 0x27
			INITIALIZE_Response->PacketAlignmentFactor  = CPU_TO_LE32(0);
    6a06:	10 a6       	std	Z+40, r1	; 0x28
    6a08:	11 a6       	std	Z+41, r1	; 0x29
    6a0a:	12 a6       	std	Z+42, r1	; 0x2a
    6a0c:	13 a6       	std	Z+43, r1	; 0x2b
			INITIALIZE_Response->AFListOffset           = CPU_TO_LE32(0);
    6a0e:	14 a6       	std	Z+44, r1	; 0x2c
    6a10:	15 a6       	std	Z+45, r1	; 0x2d
    6a12:	16 a6       	std	Z+46, r1	; 0x2e
    6a14:	17 a6       	std	Z+47, r1	; 0x2f
			INITIALIZE_Response->AFListSize             = CPU_TO_LE32(0);
    6a16:	10 aa       	std	Z+48, r1	; 0x30
    6a18:	11 aa       	std	Z+49, r1	; 0x31
    6a1a:	12 aa       	std	Z+50, r1	; 0x32
    6a1c:	13 aa       	std	Z+51, r1	; 0x33

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Initialized;
    6a1e:	c7 56       	subi	r28, 0x67	; 103
    6a20:	df 4f       	sbci	r29, 0xFF	; 255
    6a22:	28 83       	st	Y, r18
    6a24:	27 c2       	rjmp	.+1102   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			break;
		case REMOTE_NDIS_HALT_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = false;
    6a26:	fe 01       	movw	r30, r28
    6a28:	e8 56       	subi	r30, 0x68	; 104
    6a2a:	ff 4f       	sbci	r31, 0xFF	; 255
    6a2c:	10 82       	st	Z, r1

			MessageHeader->MessageLength                = CPU_TO_LE32(0);
    6a2e:	f8 01       	movw	r30, r16
    6a30:	14 82       	std	Z+4, r1	; 0x04
    6a32:	15 82       	std	Z+5, r1	; 0x05
    6a34:	16 82       	std	Z+6, r1	; 0x06
    6a36:	17 82       	std	Z+7, r1	; 0x07

			RNDISInterfaceInfo->State.CurrRNDISState    = RNDIS_Uninitialized;
    6a38:	c7 56       	subi	r28, 0x67	; 103
    6a3a:	df 4f       	sbci	r29, 0xFF	; 255
    6a3c:	18 82       	st	Y, r1
    6a3e:	1a c2       	rjmp	.+1076   	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			break;
		case REMOTE_NDIS_QUERY_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6a40:	fe 01       	movw	r30, r28
    6a42:	e8 56       	subi	r30, 0x68	; 104
    6a44:	ff 4f       	sbci	r31, 0xFF	; 255
    6a46:	81 e0       	ldi	r24, 0x01	; 1
    6a48:	80 83       	st	Z, r24

			RNDIS_Query_Message_t*  QUERY_Message       = (RNDIS_Query_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Query_Complete_t* QUERY_Response      = (RNDIS_Query_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t                Query_Oid           = CPU_TO_LE32(QUERY_Message->Oid);
    6a4a:	f8 01       	movw	r30, r16
    6a4c:	24 85       	ldd	r18, Z+12	; 0x0c
    6a4e:	35 85       	ldd	r19, Z+13	; 0x0d
    6a50:	46 85       	ldd	r20, Z+14	; 0x0e
    6a52:	57 85       	ldd	r21, Z+15	; 0x0f

			void*    QueryData    = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                                      le32_to_cpu(QUERY_Message->InformationBufferOffset)];
			void*    ResponseData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Query_Complete_t)];
    6a54:	fe 01       	movw	r30, r28
    6a56:	f0 96       	adiw	r30, 0x30	; 48
			uint16_t ResponseSize;

			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);
    6a58:	84 e0       	ldi	r24, 0x04	; 4
    6a5a:	90 e0       	ldi	r25, 0x00	; 0
    6a5c:	a0 e0       	ldi	r26, 0x00	; 0
    6a5e:	b0 e8       	ldi	r27, 0x80	; 128
    6a60:	88 8f       	std	Y+24, r24	; 0x18
    6a62:	99 8f       	std	Y+25, r25	; 0x19
    6a64:	aa 8f       	std	Y+26, r26	; 0x1a
    6a66:	bb 8f       	std	Y+27, r27	; 0x1b
                                          uint16_t* const ResponseSize)
{
	(void)QueryData;
	(void)QuerySize;

	switch (OId)
    6a68:	2e 30       	cpi	r18, 0x0E	; 14
    6a6a:	61 e0       	ldi	r22, 0x01	; 1
    6a6c:	36 07       	cpc	r19, r22
    6a6e:	61 e0       	ldi	r22, 0x01	; 1
    6a70:	46 07       	cpc	r20, r22
    6a72:	60 e0       	ldi	r22, 0x00	; 0
    6a74:	56 07       	cpc	r21, r22
    6a76:	09 f4       	brne	.+2      	; 0x6a7a <RNDIS_Device_ProcessControlRequest+0x1b0>
    6a78:	f4 c0       	rjmp	.+488    	; 0x6c62 <RNDIS_Device_ProcessControlRequest+0x398>
    6a7a:	2f 30       	cpi	r18, 0x0F	; 15
    6a7c:	81 e0       	ldi	r24, 0x01	; 1
    6a7e:	38 07       	cpc	r19, r24
    6a80:	81 e0       	ldi	r24, 0x01	; 1
    6a82:	48 07       	cpc	r20, r24
    6a84:	80 e0       	ldi	r24, 0x00	; 0
    6a86:	58 07       	cpc	r21, r24
    6a88:	08 f0       	brcs	.+2      	; 0x6a8c <RNDIS_Device_ProcessControlRequest+0x1c2>
    6a8a:	64 c0       	rjmp	.+200    	; 0x6b54 <RNDIS_Device_ProcessControlRequest+0x28a>
    6a8c:	26 30       	cpi	r18, 0x06	; 6
    6a8e:	61 e0       	ldi	r22, 0x01	; 1
    6a90:	36 07       	cpc	r19, r22
    6a92:	61 e0       	ldi	r22, 0x01	; 1
    6a94:	46 07       	cpc	r20, r22
    6a96:	60 e0       	ldi	r22, 0x00	; 0
    6a98:	56 07       	cpc	r21, r22
    6a9a:	09 f4       	brne	.+2      	; 0x6a9e <RNDIS_Device_ProcessControlRequest+0x1d4>
    6a9c:	bd c0       	rjmp	.+378    	; 0x6c18 <RNDIS_Device_ProcessControlRequest+0x34e>
    6a9e:	27 30       	cpi	r18, 0x07	; 7
    6aa0:	81 e0       	ldi	r24, 0x01	; 1
    6aa2:	38 07       	cpc	r19, r24
    6aa4:	81 e0       	ldi	r24, 0x01	; 1
    6aa6:	48 07       	cpc	r20, r24
    6aa8:	80 e0       	ldi	r24, 0x00	; 0
    6aaa:	58 07       	cpc	r21, r24
    6aac:	28 f5       	brcc	.+74     	; 0x6af8 <RNDIS_Device_ProcessControlRequest+0x22e>
    6aae:	22 30       	cpi	r18, 0x02	; 2
    6ab0:	61 e0       	ldi	r22, 0x01	; 1
    6ab2:	36 07       	cpc	r19, r22
    6ab4:	61 e0       	ldi	r22, 0x01	; 1
    6ab6:	46 07       	cpc	r20, r22
    6ab8:	60 e0       	ldi	r22, 0x00	; 0
    6aba:	56 07       	cpc	r21, r22
    6abc:	09 f4       	brne	.+2      	; 0x6ac0 <RNDIS_Device_ProcessControlRequest+0x1f6>
    6abe:	d9 c0       	rjmp	.+434    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6ac0:	23 30       	cpi	r18, 0x03	; 3
    6ac2:	81 e0       	ldi	r24, 0x01	; 1
    6ac4:	38 07       	cpc	r19, r24
    6ac6:	81 e0       	ldi	r24, 0x01	; 1
    6ac8:	48 07       	cpc	r20, r24
    6aca:	80 e0       	ldi	r24, 0x00	; 0
    6acc:	58 07       	cpc	r21, r24
    6ace:	50 f4       	brcc	.+20     	; 0x6ae4 <RNDIS_Device_ProcessControlRequest+0x21a>
    6ad0:	21 30       	cpi	r18, 0x01	; 1
    6ad2:	61 e0       	ldi	r22, 0x01	; 1
    6ad4:	36 07       	cpc	r19, r22
    6ad6:	61 e0       	ldi	r22, 0x01	; 1
    6ad8:	46 07       	cpc	r20, r22
    6ada:	60 e0       	ldi	r22, 0x00	; 0
    6adc:	56 07       	cpc	r21, r22
    6ade:	09 f0       	breq	.+2      	; 0x6ae2 <RNDIS_Device_ProcessControlRequest+0x218>
    6ae0:	d8 c0       	rjmp	.+432    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6ae2:	8c c0       	rjmp	.+280    	; 0x6bfc <RNDIS_Device_ProcessControlRequest+0x332>
    6ae4:	25 30       	cpi	r18, 0x05	; 5
    6ae6:	81 e0       	ldi	r24, 0x01	; 1
    6ae8:	38 07       	cpc	r19, r24
    6aea:	81 e0       	ldi	r24, 0x01	; 1
    6aec:	48 07       	cpc	r20, r24
    6aee:	80 e0       	ldi	r24, 0x00	; 0
    6af0:	58 07       	cpc	r21, r24
    6af2:	08 f0       	brcs	.+2      	; 0x6af6 <RNDIS_Device_ProcessControlRequest+0x22c>
    6af4:	ce c0       	rjmp	.+412    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6af6:	bd c0       	rjmp	.+378    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6af8:	2c 30       	cpi	r18, 0x0C	; 12
    6afa:	61 e0       	ldi	r22, 0x01	; 1
    6afc:	36 07       	cpc	r19, r22
    6afe:	61 e0       	ldi	r22, 0x01	; 1
    6b00:	46 07       	cpc	r20, r22
    6b02:	60 e0       	ldi	r22, 0x00	; 0
    6b04:	56 07       	cpc	r21, r22
    6b06:	98 f4       	brcc	.+38     	; 0x6b2e <RNDIS_Device_ProcessControlRequest+0x264>
    6b08:	2a 30       	cpi	r18, 0x0A	; 10
    6b0a:	81 e0       	ldi	r24, 0x01	; 1
    6b0c:	38 07       	cpc	r19, r24
    6b0e:	81 e0       	ldi	r24, 0x01	; 1
    6b10:	48 07       	cpc	r20, r24
    6b12:	80 e0       	ldi	r24, 0x00	; 0
    6b14:	58 07       	cpc	r21, r24
    6b16:	08 f0       	brcs	.+2      	; 0x6b1a <RNDIS_Device_ProcessControlRequest+0x250>
    6b18:	7f c0       	rjmp	.+254    	; 0x6c18 <RNDIS_Device_ProcessControlRequest+0x34e>
    6b1a:	27 30       	cpi	r18, 0x07	; 7
    6b1c:	e1 e0       	ldi	r30, 0x01	; 1
    6b1e:	3e 07       	cpc	r19, r30
    6b20:	e1 e0       	ldi	r30, 0x01	; 1
    6b22:	4e 07       	cpc	r20, r30
    6b24:	e0 e0       	ldi	r30, 0x00	; 0
    6b26:	5e 07       	cpc	r21, r30
    6b28:	09 f0       	breq	.+2      	; 0x6b2c <RNDIS_Device_ProcessControlRequest+0x262>
    6b2a:	b3 c0       	rjmp	.+358    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6b2c:	87 c0       	rjmp	.+270    	; 0x6c3c <RNDIS_Device_ProcessControlRequest+0x372>
    6b2e:	2c 30       	cpi	r18, 0x0C	; 12
    6b30:	61 e0       	ldi	r22, 0x01	; 1
    6b32:	36 07       	cpc	r19, r22
    6b34:	61 e0       	ldi	r22, 0x01	; 1
    6b36:	46 07       	cpc	r20, r22
    6b38:	60 e0       	ldi	r22, 0x00	; 0
    6b3a:	56 07       	cpc	r21, r22
    6b3c:	09 f4       	brne	.+2      	; 0x6b40 <RNDIS_Device_ProcessControlRequest+0x276>
    6b3e:	67 c0       	rjmp	.+206    	; 0x6c0e <RNDIS_Device_ProcessControlRequest+0x344>
    6b40:	2d 30       	cpi	r18, 0x0D	; 13
    6b42:	81 e0       	ldi	r24, 0x01	; 1
    6b44:	38 07       	cpc	r19, r24
    6b46:	81 e0       	ldi	r24, 0x01	; 1
    6b48:	48 07       	cpc	r20, r24
    6b4a:	80 e0       	ldi	r24, 0x00	; 0
    6b4c:	58 07       	cpc	r21, r24
    6b4e:	09 f0       	breq	.+2      	; 0x6b52 <RNDIS_Device_ProcessControlRequest+0x288>
    6b50:	a0 c0       	rjmp	.+320    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6b52:	67 c0       	rjmp	.+206    	; 0x6c22 <RNDIS_Device_ProcessControlRequest+0x358>
    6b54:	26 30       	cpi	r18, 0x06	; 6
    6b56:	61 e0       	ldi	r22, 0x01	; 1
    6b58:	36 07       	cpc	r19, r22
    6b5a:	62 e0       	ldi	r22, 0x02	; 2
    6b5c:	46 07       	cpc	r20, r22
    6b5e:	60 e0       	ldi	r22, 0x00	; 0
    6b60:	56 07       	cpc	r21, r22
    6b62:	28 f5       	brcc	.+74     	; 0x6bae <RNDIS_Device_ProcessControlRequest+0x2e4>
    6b64:	21 30       	cpi	r18, 0x01	; 1
    6b66:	81 e0       	ldi	r24, 0x01	; 1
    6b68:	38 07       	cpc	r19, r24
    6b6a:	82 e0       	ldi	r24, 0x02	; 2
    6b6c:	48 07       	cpc	r20, r24
    6b6e:	80 e0       	ldi	r24, 0x00	; 0
    6b70:	58 07       	cpc	r21, r24
    6b72:	08 f0       	brcs	.+2      	; 0x6b76 <RNDIS_Device_ProcessControlRequest+0x2ac>
    6b74:	7e c0       	rjmp	.+252    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6b76:	24 31       	cpi	r18, 0x14	; 20
    6b78:	e1 e0       	ldi	r30, 0x01	; 1
    6b7a:	3e 07       	cpc	r19, r30
    6b7c:	e1 e0       	ldi	r30, 0x01	; 1
    6b7e:	4e 07       	cpc	r20, r30
    6b80:	e0 e0       	ldi	r30, 0x00	; 0
    6b82:	5e 07       	cpc	r21, r30
    6b84:	09 f4       	brne	.+2      	; 0x6b88 <RNDIS_Device_ProcessControlRequest+0x2be>
    6b86:	75 c0       	rjmp	.+234    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6b88:	22 30       	cpi	r18, 0x02	; 2
    6b8a:	f2 e0       	ldi	r31, 0x02	; 2
    6b8c:	3f 07       	cpc	r19, r31
    6b8e:	f1 e0       	ldi	r31, 0x01	; 1
    6b90:	4f 07       	cpc	r20, r31
    6b92:	f0 e0       	ldi	r31, 0x00	; 0
    6b94:	5f 07       	cpc	r21, r31
    6b96:	09 f4       	brne	.+2      	; 0x6b9a <RNDIS_Device_ProcessControlRequest+0x2d0>
    6b98:	6c c0       	rjmp	.+216    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
    6b9a:	21 31       	cpi	r18, 0x11	; 17
    6b9c:	61 e0       	ldi	r22, 0x01	; 1
    6b9e:	36 07       	cpc	r19, r22
    6ba0:	61 e0       	ldi	r22, 0x01	; 1
    6ba2:	46 07       	cpc	r20, r22
    6ba4:	60 e0       	ldi	r22, 0x00	; 0
    6ba6:	56 07       	cpc	r21, r22
    6ba8:	09 f0       	breq	.+2      	; 0x6bac <RNDIS_Device_ProcessControlRequest+0x2e2>
    6baa:	73 c0       	rjmp	.+230    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6bac:	67 c0       	rjmp	.+206    	; 0x6c7c <RNDIS_Device_ProcessControlRequest+0x3b2>
    6bae:	24 30       	cpi	r18, 0x04	; 4
    6bb0:	81 e0       	ldi	r24, 0x01	; 1
    6bb2:	38 07       	cpc	r19, r24
    6bb4:	81 e0       	ldi	r24, 0x01	; 1
    6bb6:	48 07       	cpc	r20, r24
    6bb8:	81 e0       	ldi	r24, 0x01	; 1
    6bba:	58 07       	cpc	r21, r24
    6bbc:	09 f4       	brne	.+2      	; 0x6bc0 <RNDIS_Device_ProcessControlRequest+0x2f6>
    6bbe:	4c c0       	rjmp	.+152    	; 0x6c58 <RNDIS_Device_ProcessControlRequest+0x38e>
    6bc0:	25 30       	cpi	r18, 0x05	; 5
    6bc2:	61 e0       	ldi	r22, 0x01	; 1
    6bc4:	36 07       	cpc	r19, r22
    6bc6:	61 e0       	ldi	r22, 0x01	; 1
    6bc8:	46 07       	cpc	r20, r22
    6bca:	61 e0       	ldi	r22, 0x01	; 1
    6bcc:	56 07       	cpc	r21, r22
    6bce:	58 f4       	brcc	.+22     	; 0x6be6 <RNDIS_Device_ProcessControlRequest+0x31c>
    6bd0:	21 50       	subi	r18, 0x01	; 1
    6bd2:	31 40       	sbci	r19, 0x01	; 1
    6bd4:	41 40       	sbci	r20, 0x01	; 1
    6bd6:	51 40       	sbci	r21, 0x01	; 1
    6bd8:	22 30       	cpi	r18, 0x02	; 2
    6bda:	31 05       	cpc	r19, r1
    6bdc:	41 05       	cpc	r20, r1
    6bde:	51 05       	cpc	r21, r1
    6be0:	08 f0       	brcs	.+2      	; 0x6be4 <RNDIS_Device_ProcessControlRequest+0x31a>
    6be2:	57 c0       	rjmp	.+174    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6be4:	30 c0       	rjmp	.+96     	; 0x6c46 <RNDIS_Device_ProcessControlRequest+0x37c>
    6be6:	21 50       	subi	r18, 0x01	; 1
    6be8:	31 40       	sbci	r19, 0x01	; 1
    6bea:	42 40       	sbci	r20, 0x02	; 2
    6bec:	51 40       	sbci	r21, 0x01	; 1
    6bee:	23 30       	cpi	r18, 0x03	; 3
    6bf0:	31 05       	cpc	r19, r1
    6bf2:	41 05       	cpc	r20, r1
    6bf4:	51 05       	cpc	r21, r1
    6bf6:	08 f0       	brcs	.+2      	; 0x6bfa <RNDIS_Device_ProcessControlRequest+0x330>
    6bf8:	4c c0       	rjmp	.+152    	; 0x6c92 <RNDIS_Device_ProcessControlRequest+0x3c8>
    6bfa:	3b c0       	rjmp	.+118    	; 0x6c72 <RNDIS_Device_ProcessControlRequest+0x3a8>
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);

			memcpy_P(ResponseData, AdapterSupportedOIDList, sizeof(AdapterSupportedOIDList));
    6bfc:	cf 01       	movw	r24, r30
    6bfe:	63 ea       	ldi	r22, 0xA3	; 163
    6c00:	73 e0       	ldi	r23, 0x03	; 3
    6c02:	4c e6       	ldi	r20, 0x6C	; 108
    6c04:	50 e0       	ldi	r21, 0x00	; 0
    6c06:	cb d6       	rcall	.+3478   	; 0x799e <memcpy_P>
	(void)QuerySize;

	switch (OId)
	{
		case OID_GEN_SUPPORTED_LIST:
			*ResponseSize = sizeof(AdapterSupportedOIDList);
    6c08:	cc e6       	ldi	r28, 0x6C	; 108
    6c0a:	d0 e0       	ldi	r29, 0x00	; 0
    6c0c:	17 c1       	rjmp	.+558    	; 0x6e3c <RNDIS_Device_ProcessControlRequest+0x572>
			return true;
		case OID_GEN_VENDOR_ID:
			*ResponseSize = sizeof(uint32_t);

			/* Vendor ID 0x0xFFFFFF is reserved for vendors who have not purchased a NDIS VID */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0x00FFFFFF);
    6c0e:	8f ef       	ldi	r24, 0xFF	; 255
    6c10:	9f ef       	ldi	r25, 0xFF	; 255
    6c12:	af ef       	ldi	r26, 0xFF	; 255
    6c14:	b0 e0       	ldi	r27, 0x00	; 0
    6c16:	36 c0       	rjmp	.+108    	; 0x6c84 <RNDIS_Device_ProcessControlRequest+0x3ba>
		case OID_GEN_MAXIMUM_FRAME_SIZE:
		case OID_GEN_TRANSMIT_BLOCK_SIZE:
		case OID_GEN_RECEIVE_BLOCK_SIZE:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = CPU_TO_LE32(ETHERNET_FRAME_SIZE_MAX);
    6c18:	8c ed       	ldi	r24, 0xDC	; 220
    6c1a:	95 e0       	ldi	r25, 0x05	; 5
    6c1c:	a0 e0       	ldi	r26, 0x00	; 0
    6c1e:	b0 e0       	ldi	r27, 0x00	; 0
    6c20:	31 c0       	rjmp	.+98     	; 0x6c84 <RNDIS_Device_ProcessControlRequest+0x3ba>

			return true;
		case OID_GEN_VENDOR_DESCRIPTION:
			*ResponseSize = (strlen(RNDISInterfaceInfo->Config.AdapterVendorDescription) + 1);
    6c22:	68 89       	ldd	r22, Y+16	; 0x10
    6c24:	79 89       	ldd	r23, Y+17	; 0x11
    6c26:	db 01       	movw	r26, r22
    6c28:	ed 01       	movw	r28, r26
    6c2a:	09 90       	ld	r0, Y+
    6c2c:	00 20       	and	r0, r0
    6c2e:	e9 f7       	brne	.-6      	; 0x6c2a <RNDIS_Device_ProcessControlRequest+0x360>
    6c30:	ca 1b       	sub	r28, r26
    6c32:	db 0b       	sbc	r29, r27

			memcpy(ResponseData, RNDISInterfaceInfo->Config.AdapterVendorDescription, *ResponseSize);
    6c34:	cf 01       	movw	r24, r30
    6c36:	ae 01       	movw	r20, r28
    6c38:	ed d6       	rcall	.+3546   	; 0x7a14 <memcpy>
    6c3a:	00 c1       	rjmp	.+512    	; 0x6e3c <RNDIS_Device_ProcessControlRequest+0x572>
			return true;
		case OID_GEN_LINK_SPEED:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate 10Mb/s link speed */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);
    6c3c:	80 ea       	ldi	r24, 0xA0	; 160
    6c3e:	96 e8       	ldi	r25, 0x86	; 134
    6c40:	a1 e0       	ldi	r26, 0x01	; 1
    6c42:	b0 e0       	ldi	r27, 0x00	; 0
    6c44:	1f c0       	rjmp	.+62     	; 0x6c84 <RNDIS_Device_ProcessControlRequest+0x3ba>
			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);

			memcpy(ResponseData, &RNDISInterfaceInfo->Config.AdapterMACAddress, sizeof(MAC_Address_t));
    6c46:	62 96       	adiw	r28, 0x12	; 18
    6c48:	86 e0       	ldi	r24, 0x06	; 6
    6c4a:	09 90       	ld	r0, Y+
    6c4c:	01 92       	st	Z+, r0
    6c4e:	81 50       	subi	r24, 0x01	; 1
    6c50:	e1 f7       	brne	.-8      	; 0x6c4a <RNDIS_Device_ProcessControlRequest+0x380>
			*((uint32_t*)ResponseData) = CPU_TO_LE32(100000);

			return true;
		case OID_802_3_PERMANENT_ADDRESS:
		case OID_802_3_CURRENT_ADDRESS:
			*ResponseSize = sizeof(MAC_Address_t);
    6c52:	c6 e0       	ldi	r28, 0x06	; 6
    6c54:	d0 e0       	ldi	r29, 0x00	; 0
    6c56:	f2 c0       	rjmp	.+484    	; 0x6e3c <RNDIS_Device_ProcessControlRequest+0x572>
			return true;
		case OID_802_3_MAXIMUM_LIST_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate only one multicast address supported */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(1);
    6c58:	81 e0       	ldi	r24, 0x01	; 1
    6c5a:	90 e0       	ldi	r25, 0x00	; 0
    6c5c:	a0 e0       	ldi	r26, 0x00	; 0
    6c5e:	b0 e0       	ldi	r27, 0x00	; 0
    6c60:	11 c0       	rjmp	.+34     	; 0x6c84 <RNDIS_Device_ProcessControlRequest+0x3ba>

			return true;
		case OID_GEN_CURRENT_PACKET_FILTER:
			*ResponseSize = sizeof(uint32_t);

			*((uint32_t*)ResponseData) = cpu_to_le32(RNDISInterfaceInfo->State.CurrPacketFilter);
    6c62:	fe 01       	movw	r30, r28
    6c64:	e6 56       	subi	r30, 0x66	; 102
    6c66:	ff 4f       	sbci	r31, 0xFF	; 255
    6c68:	80 81       	ld	r24, Z
    6c6a:	91 81       	ldd	r25, Z+1	; 0x01
    6c6c:	a2 81       	ldd	r26, Z+2	; 0x02
    6c6e:	b3 81       	ldd	r27, Z+3	; 0x03
    6c70:	09 c0       	rjmp	.+18     	; 0x6c84 <RNDIS_Device_ProcessControlRequest+0x3ba>
		case OID_802_3_XMIT_ONE_COLLISION:
		case OID_802_3_XMIT_MORE_COLLISIONS:
			*ResponseSize = sizeof(uint32_t);

			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);
    6c72:	18 aa       	std	Y+48, r1	; 0x30
    6c74:	19 aa       	std	Y+49, r1	; 0x31
    6c76:	1a aa       	std	Y+50, r1	; 0x32
    6c78:	1b aa       	std	Y+51, r1	; 0x33
    6c7a:	08 c0       	rjmp	.+16     	; 0x6c8c <RNDIS_Device_ProcessControlRequest+0x3c2>
			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);

			/* Indicate maximum overall buffer (Ethernet frame and RNDIS header) the adapter can handle */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(RNDIS_MESSAGE_BUFFER_SIZE + ETHERNET_FRAME_SIZE_MAX);
    6c7c:	8c e5       	ldi	r24, 0x5C	; 92
    6c7e:	96 e0       	ldi	r25, 0x06	; 6
    6c80:	a0 e0       	ldi	r26, 0x00	; 0
    6c82:	b0 e0       	ldi	r27, 0x00	; 0
    6c84:	88 ab       	std	Y+48, r24	; 0x30
    6c86:	99 ab       	std	Y+49, r25	; 0x31
    6c88:	aa ab       	std	Y+50, r26	; 0x32
    6c8a:	bb ab       	std	Y+51, r27	; 0x33
			/* Unused statistic OIDs - always return 0 for each */
			*((uint32_t*)ResponseData) = CPU_TO_LE32(0);

			return true;
		case OID_GEN_MAXIMUM_TOTAL_SIZE:
			*ResponseSize = sizeof(uint32_t);
    6c8c:	c4 e0       	ldi	r28, 0x04	; 4
    6c8e:	d0 e0       	ldi	r29, 0x00	; 0
    6c90:	d5 c0       	rjmp	.+426    	; 0x6e3c <RNDIS_Device_ProcessControlRequest+0x572>
				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
			}
			else
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_NOT_SUPPORTED);
    6c92:	8b eb       	ldi	r24, 0xBB	; 187
    6c94:	90 e0       	ldi	r25, 0x00	; 0
    6c96:	a0 e0       	ldi	r26, 0x00	; 0
    6c98:	b0 ec       	ldi	r27, 0xC0	; 192
    6c9a:	f8 01       	movw	r30, r16
    6c9c:	84 87       	std	Z+12, r24	; 0x0c
    6c9e:	95 87       	std	Z+13, r25	; 0x0d
    6ca0:	a6 87       	std	Z+14, r26	; 0x0e
    6ca2:	b7 87       	std	Z+15, r27	; 0x0f
				QUERY_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t));
    6ca4:	88 e1       	ldi	r24, 0x18	; 24
    6ca6:	90 e0       	ldi	r25, 0x00	; 0
    6ca8:	a0 e0       	ldi	r26, 0x00	; 0
    6caa:	b0 e0       	ldi	r27, 0x00	; 0
    6cac:	84 83       	std	Z+4, r24	; 0x04
    6cae:	95 83       	std	Z+5, r25	; 0x05
    6cb0:	a6 83       	std	Z+6, r26	; 0x06
    6cb2:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(0);
    6cb4:	10 8a       	std	Z+16, r1	; 0x10
    6cb6:	11 8a       	std	Z+17, r1	; 0x11
    6cb8:	12 8a       	std	Z+18, r1	; 0x12
    6cba:	13 8a       	std	Z+19, r1	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(0);
    6cbc:	14 8a       	std	Z+20, r1	; 0x14
    6cbe:	15 8a       	std	Z+21, r1	; 0x15
    6cc0:	16 8a       	std	Z+22, r1	; 0x16
    6cc2:	17 8a       	std	Z+23, r1	; 0x17
    6cc4:	d7 c0       	rjmp	.+430    	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			}

			break;
		case REMOTE_NDIS_SET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6cc6:	fe 01       	movw	r30, r28
    6cc8:	e8 56       	subi	r30, 0x68	; 104
    6cca:	ff 4f       	sbci	r31, 0xFF	; 255
    6ccc:	81 e0       	ldi	r24, 0x01	; 1
    6cce:	80 83       	st	Z, r24

			RNDIS_Set_Message_t*  SET_Message           = (RNDIS_Set_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_Set_Complete_t* SET_Response          = (RNDIS_Set_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			uint32_t              SET_Oid               = le32_to_cpu(SET_Message->Oid);
    6cd0:	f8 01       	movw	r30, r16
    6cd2:	84 85       	ldd	r24, Z+12	; 0x0c
    6cd4:	95 85       	ldd	r25, Z+13	; 0x0d
    6cd6:	a6 85       	ldd	r26, Z+14	; 0x0e
    6cd8:	b7 85       	ldd	r27, Z+15	; 0x0f

			SET_Response->MessageType                   = CPU_TO_LE32(REMOTE_NDIS_SET_CMPLT);
    6cda:	25 e0       	ldi	r18, 0x05	; 5
    6cdc:	30 e0       	ldi	r19, 0x00	; 0
    6cde:	40 e0       	ldi	r20, 0x00	; 0
    6ce0:	50 e8       	ldi	r21, 0x80	; 128
    6ce2:	28 8f       	std	Y+24, r18	; 0x18
    6ce4:	39 8f       	std	Y+25, r19	; 0x19
    6ce6:	4a 8f       	std	Y+26, r20	; 0x1a
    6ce8:	5b 8f       	std	Y+27, r21	; 0x1b
			SET_Response->MessageLength                 = CPU_TO_LE32(sizeof(RNDIS_Set_Complete_t));
    6cea:	20 e1       	ldi	r18, 0x10	; 16
    6cec:	30 e0       	ldi	r19, 0x00	; 0
    6cee:	40 e0       	ldi	r20, 0x00	; 0
    6cf0:	50 e0       	ldi	r21, 0x00	; 0
    6cf2:	24 83       	std	Z+4, r18	; 0x04
    6cf4:	35 83       	std	Z+5, r19	; 0x05
    6cf6:	46 83       	std	Z+6, r20	; 0x06
    6cf8:	57 83       	std	Z+7, r21	; 0x07
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];
    6cfa:	24 89       	ldd	r18, Z+20	; 0x14
    6cfc:	35 89       	ldd	r19, Z+21	; 0x15
    6cfe:	46 89       	ldd	r20, Z+22	; 0x16
    6d00:	57 89       	ldd	r21, Z+23	; 0x17
                                        const void* SetData,
                                        const uint16_t SetSize)
{
	(void)SetSize;

	switch (OId)
    6d02:	8e 30       	cpi	r24, 0x0E	; 14
    6d04:	f1 e0       	ldi	r31, 0x01	; 1
    6d06:	9f 07       	cpc	r25, r31
    6d08:	f1 e0       	ldi	r31, 0x01	; 1
    6d0a:	af 07       	cpc	r26, r31
    6d0c:	f0 e0       	ldi	r31, 0x00	; 0
    6d0e:	bf 07       	cpc	r27, r31
    6d10:	49 f0       	breq	.+18     	; 0x6d24 <RNDIS_Device_ProcessControlRequest+0x45a>
    6d12:	83 30       	cpi	r24, 0x03	; 3
    6d14:	21 e0       	ldi	r18, 0x01	; 1
    6d16:	92 07       	cpc	r25, r18
    6d18:	21 e0       	ldi	r18, 0x01	; 1
    6d1a:	a2 07       	cpc	r26, r18
    6d1c:	21 e0       	ldi	r18, 0x01	; 1
    6d1e:	b2 07       	cpc	r27, r18
    6d20:	e9 f4       	brne	.+58     	; 0x6d5c <RNDIS_Device_ProcessControlRequest+0x492>
    6d22:	18 c0       	rjmp	.+48     	; 0x6d54 <RNDIS_Device_ProcessControlRequest+0x48a>
	{
		case OID_GEN_CURRENT_PACKET_FILTER:
			RNDISInterfaceInfo->State.CurrPacketFilter = le32_to_cpu(*((uint32_t*)SetData));
    6d24:	20 0f       	add	r18, r16
    6d26:	31 1f       	adc	r19, r17
    6d28:	f9 01       	movw	r30, r18
    6d2a:	80 85       	ldd	r24, Z+8	; 0x08
    6d2c:	91 85       	ldd	r25, Z+9	; 0x09
    6d2e:	a2 85       	ldd	r26, Z+10	; 0x0a
    6d30:	b3 85       	ldd	r27, Z+11	; 0x0b
    6d32:	fe 01       	movw	r30, r28
    6d34:	e6 56       	subi	r30, 0x66	; 102
    6d36:	ff 4f       	sbci	r31, 0xFF	; 255
    6d38:	80 83       	st	Z, r24
    6d3a:	91 83       	std	Z+1, r25	; 0x01
    6d3c:	a2 83       	std	Z+2, r26	; 0x02
    6d3e:	b3 83       	std	Z+3, r27	; 0x03
			RNDISInterfaceInfo->State.CurrRNDISState   = (RNDISInterfaceInfo->State.CurrPacketFilter) ? RNDIS_Data_Initialized : RNDIS_Initialized;
    6d40:	00 97       	sbiw	r24, 0x00	; 0
    6d42:	a1 05       	cpc	r26, r1
    6d44:	b1 05       	cpc	r27, r1
    6d46:	11 f0       	breq	.+4      	; 0x6d4c <RNDIS_Device_ProcessControlRequest+0x482>
    6d48:	82 e0       	ldi	r24, 0x02	; 2
    6d4a:	01 c0       	rjmp	.+2      	; 0x6d4e <RNDIS_Device_ProcessControlRequest+0x484>
    6d4c:	81 e0       	ldi	r24, 0x01	; 1
    6d4e:	c7 56       	subi	r28, 0x67	; 103
    6d50:	df 4f       	sbci	r29, 0xFF	; 255
    6d52:	88 83       	st	Y, r24
			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
    6d54:	80 e0       	ldi	r24, 0x00	; 0
    6d56:	90 e0       	ldi	r25, 0x00	; 0
    6d58:	dc 01       	movw	r26, r24
    6d5a:	04 c0       	rjmp	.+8      	; 0x6d64 <RNDIS_Device_ProcessControlRequest+0x49a>
    6d5c:	8b eb       	ldi	r24, 0xBB	; 187
    6d5e:	90 e0       	ldi	r25, 0x00	; 0
    6d60:	a0 e0       	ldi	r26, 0x00	; 0
    6d62:	b0 ec       	ldi	r27, 0xC0	; 192
			SET_Response->RequestId                     = SET_Message->RequestId;

			void* SetData = &RNDISInterfaceInfo->State.RNDISMessageBuffer[sizeof(RNDIS_Message_Header_t) +
			                                                              le32_to_cpu(SET_Message->InformationBufferOffset)];

			SET_Response->Status = RNDIS_Device_ProcessNDISSet(RNDISInterfaceInfo, SET_Oid, SetData,
    6d64:	f8 01       	movw	r30, r16
    6d66:	84 87       	std	Z+12, r24	; 0x0c
    6d68:	95 87       	std	Z+13, r25	; 0x0d
    6d6a:	a6 87       	std	Z+14, r26	; 0x0e
    6d6c:	b7 87       	std	Z+15, r27	; 0x0f
    6d6e:	82 c0       	rjmp	.+260    	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			                                                   le32_to_cpu(SET_Message->InformationBufferLength)) ?
			                                                   REMOTE_NDIS_STATUS_SUCCESS : REMOTE_NDIS_STATUS_NOT_SUPPORTED;
			break;
		case REMOTE_NDIS_RESET_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6d70:	fe 01       	movw	r30, r28
    6d72:	e8 56       	subi	r30, 0x68	; 104
    6d74:	ff 4f       	sbci	r31, 0xFF	; 255
    6d76:	81 e0       	ldi	r24, 0x01	; 1
    6d78:	80 83       	st	Z, r24

			RNDIS_Reset_Complete_t* RESET_Response      = (RNDIS_Reset_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			RESET_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_RESET_CMPLT);
    6d7a:	86 e0       	ldi	r24, 0x06	; 6
    6d7c:	90 e0       	ldi	r25, 0x00	; 0
    6d7e:	a0 e0       	ldi	r26, 0x00	; 0
    6d80:	b0 e8       	ldi	r27, 0x80	; 128
    6d82:	88 8f       	std	Y+24, r24	; 0x18
    6d84:	99 8f       	std	Y+25, r25	; 0x19
    6d86:	aa 8f       	std	Y+26, r26	; 0x1a
    6d88:	bb 8f       	std	Y+27, r27	; 0x1b
			RESET_Response->MessageLength               = CPU_TO_LE32(sizeof(RNDIS_Reset_Complete_t));
    6d8a:	80 e1       	ldi	r24, 0x10	; 16
    6d8c:	90 e0       	ldi	r25, 0x00	; 0
    6d8e:	a0 e0       	ldi	r26, 0x00	; 0
    6d90:	b0 e0       	ldi	r27, 0x00	; 0
    6d92:	f8 01       	movw	r30, r16
    6d94:	84 83       	std	Z+4, r24	; 0x04
    6d96:	95 83       	std	Z+5, r25	; 0x05
    6d98:	a6 83       	std	Z+6, r26	; 0x06
    6d9a:	b7 83       	std	Z+7, r27	; 0x07
			RESET_Response->Status                      = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6d9c:	10 86       	std	Z+8, r1	; 0x08
    6d9e:	11 86       	std	Z+9, r1	; 0x09
    6da0:	12 86       	std	Z+10, r1	; 0x0a
    6da2:	13 86       	std	Z+11, r1	; 0x0b
    6da4:	16 c0       	rjmp	.+44     	; 0x6dd2 <RNDIS_Device_ProcessControlRequest+0x508>
			RESET_Response->AddressingReset             = CPU_TO_LE32(0);

			break;
		case REMOTE_NDIS_KEEPALIVE_MSG:
			RNDISInterfaceInfo->State.ResponseReady     = true;
    6da6:	fe 01       	movw	r30, r28
    6da8:	e8 56       	subi	r30, 0x68	; 104
    6daa:	ff 4f       	sbci	r31, 0xFF	; 255
    6dac:	81 e0       	ldi	r24, 0x01	; 1
    6dae:	80 83       	st	Z, r24
			RNDIS_KeepAlive_Message_t*  KEEPALIVE_Message  =
			                (RNDIS_KeepAlive_Message_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
			RNDIS_KeepAlive_Complete_t* KEEPALIVE_Response =
			                (RNDIS_KeepAlive_Complete_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;

			KEEPALIVE_Response->MessageType             = CPU_TO_LE32(REMOTE_NDIS_KEEPALIVE_CMPLT);
    6db0:	88 e0       	ldi	r24, 0x08	; 8
    6db2:	90 e0       	ldi	r25, 0x00	; 0
    6db4:	a0 e0       	ldi	r26, 0x00	; 0
    6db6:	b0 e8       	ldi	r27, 0x80	; 128
    6db8:	88 8f       	std	Y+24, r24	; 0x18
    6dba:	99 8f       	std	Y+25, r25	; 0x19
    6dbc:	aa 8f       	std	Y+26, r26	; 0x1a
    6dbe:	bb 8f       	std	Y+27, r27	; 0x1b
			KEEPALIVE_Response->MessageLength           = CPU_TO_LE32(sizeof(RNDIS_KeepAlive_Complete_t));
    6dc0:	80 e1       	ldi	r24, 0x10	; 16
    6dc2:	90 e0       	ldi	r25, 0x00	; 0
    6dc4:	a0 e0       	ldi	r26, 0x00	; 0
    6dc6:	b0 e0       	ldi	r27, 0x00	; 0
    6dc8:	f8 01       	movw	r30, r16
    6dca:	84 83       	std	Z+4, r24	; 0x04
    6dcc:	95 83       	std	Z+5, r25	; 0x05
    6dce:	a6 83       	std	Z+6, r26	; 0x06
    6dd0:	b7 83       	std	Z+7, r27	; 0x07
			KEEPALIVE_Response->RequestId               = KEEPALIVE_Message->RequestId;
			KEEPALIVE_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6dd2:	14 86       	std	Z+12, r1	; 0x0c
    6dd4:	15 86       	std	Z+13, r1	; 0x0d
    6dd6:	16 86       	std	Z+14, r1	; 0x0e
    6dd8:	17 86       	std	Z+15, r1	; 0x0f
    6dda:	4c c0       	rjmp	.+152    	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
				RNDIS_Device_ProcessRNDISControlMessage(RNDISInterfaceInfo);
			}

			break;
		case RNDIS_REQ_GetEncapsulatedResponse:
			if (USB_ControlRequest.bmRequestType == (REQDIR_DEVICETOHOST | REQTYPE_CLASS | REQREC_INTERFACE))
    6ddc:	80 91 ae 0d 	lds	r24, 0x0DAE
    6de0:	81 3a       	cpi	r24, 0xA1	; 161
    6de2:	09 f0       	breq	.+2      	; 0x6de6 <RNDIS_Device_ProcessControlRequest+0x51c>
    6de4:	47 c0       	rjmp	.+142    	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			{
				RNDIS_Message_Header_t* MessageHeader = (RNDIS_Message_Header_t*)&RNDISInterfaceInfo->State.RNDISMessageBuffer;
    6de6:	8e 01       	movw	r16, r28
    6de8:	08 5e       	subi	r16, 0xE8	; 232
    6dea:	1f 4f       	sbci	r17, 0xFF	; 255

				if (!(MessageHeader->MessageLength))
    6dec:	f8 01       	movw	r30, r16
    6dee:	84 81       	ldd	r24, Z+4	; 0x04
    6df0:	95 81       	ldd	r25, Z+5	; 0x05
    6df2:	a6 81       	ldd	r26, Z+6	; 0x06
    6df4:	b7 81       	ldd	r27, Z+7	; 0x07
    6df6:	00 97       	sbiw	r24, 0x00	; 0
    6df8:	a1 05       	cpc	r26, r1
    6dfa:	b1 05       	cpc	r27, r1
    6dfc:	49 f4       	brne	.+18     	; 0x6e10 <RNDIS_Device_ProcessControlRequest+0x546>
				{
					RNDISInterfaceInfo->State.RNDISMessageBuffer[0] = 0;
    6dfe:	18 8e       	std	Y+24, r1	; 0x18
					MessageHeader->MessageLength                    = CPU_TO_LE32(1);
    6e00:	81 e0       	ldi	r24, 0x01	; 1
    6e02:	90 e0       	ldi	r25, 0x00	; 0
    6e04:	a0 e0       	ldi	r26, 0x00	; 0
    6e06:	b0 e0       	ldi	r27, 0x00	; 0
    6e08:	84 83       	std	Z+4, r24	; 0x04
    6e0a:	95 83       	std	Z+5, r25	; 0x05
    6e0c:	a6 83       	std	Z+6, r26	; 0x06
    6e0e:	b7 83       	std	Z+7, r27	; 0x07
			 *  \note This is not applicable for non CONTROL type endpoints.
			 */
			static inline void Endpoint_ClearSETUP(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearSETUP(void)
			{
				UEINTX &= ~(1 << RXSTPI);
    6e10:	80 91 e8 00 	lds	r24, 0x00E8
    6e14:	87 7f       	andi	r24, 0xF7	; 247
    6e16:	80 93 e8 00 	sts	0x00E8, r24
				}

				Endpoint_ClearSETUP();
				Endpoint_Write_Control_Stream_LE(RNDISInterfaceInfo->State.RNDISMessageBuffer, le32_to_cpu(MessageHeader->MessageLength));
    6e1a:	f8 01       	movw	r30, r16
    6e1c:	64 81       	ldd	r22, Z+4	; 0x04
    6e1e:	75 81       	ldd	r23, Z+5	; 0x05
    6e20:	c8 01       	movw	r24, r16
    6e22:	0e 94 38 27 	call	0x4e70	; 0x4e70 <Endpoint_Write_Control_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    6e26:	80 91 e8 00 	lds	r24, 0x00E8
    6e2a:	8b 77       	andi	r24, 0x7B	; 123
    6e2c:	80 93 e8 00 	sts	0x00E8, r24
				Endpoint_ClearOUT();

				MessageHeader->MessageLength = CPU_TO_LE32(0);
    6e30:	f8 01       	movw	r30, r16
    6e32:	14 82       	std	Z+4, r1	; 0x04
    6e34:	15 82       	std	Z+5, r1	; 0x05
    6e36:	16 82       	std	Z+6, r1	; 0x06
    6e38:	17 82       	std	Z+7, r1	; 0x07
    6e3a:	1c c0       	rjmp	.+56     	; 0x6e74 <RNDIS_Device_ProcessControlRequest+0x5aa>
			QUERY_Response->MessageType                 = CPU_TO_LE32(REMOTE_NDIS_QUERY_CMPLT);

			if (RNDIS_Device_ProcessNDISQuery(RNDISInterfaceInfo, Query_Oid, QueryData, le32_to_cpu(QUERY_Message->InformationBufferLength),
			                                  ResponseData, &ResponseSize))
			{
				QUERY_Response->Status                  = CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS);
    6e3c:	f8 01       	movw	r30, r16
    6e3e:	14 86       	std	Z+12, r1	; 0x0c
    6e40:	15 86       	std	Z+13, r1	; 0x0d
    6e42:	16 86       	std	Z+14, r1	; 0x0e
    6e44:	17 86       	std	Z+15, r1	; 0x0f
				QUERY_Response->MessageLength           = cpu_to_le32(sizeof(RNDIS_Query_Complete_t) + ResponseSize);
    6e46:	ce 01       	movw	r24, r28
    6e48:	48 96       	adiw	r24, 0x18	; 24
    6e4a:	a0 e0       	ldi	r26, 0x00	; 0
    6e4c:	b0 e0       	ldi	r27, 0x00	; 0
    6e4e:	84 83       	std	Z+4, r24	; 0x04
    6e50:	95 83       	std	Z+5, r25	; 0x05
    6e52:	a6 83       	std	Z+6, r26	; 0x06
    6e54:	b7 83       	std	Z+7, r27	; 0x07

				QUERY_Response->InformationBufferLength = CPU_TO_LE32(ResponseSize);
    6e56:	ce 01       	movw	r24, r28
    6e58:	a0 e0       	ldi	r26, 0x00	; 0
    6e5a:	b0 e0       	ldi	r27, 0x00	; 0
    6e5c:	80 8b       	std	Z+16, r24	; 0x10
    6e5e:	91 8b       	std	Z+17, r25	; 0x11
    6e60:	a2 8b       	std	Z+18, r26	; 0x12
    6e62:	b3 8b       	std	Z+19, r27	; 0x13
				QUERY_Response->InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Query_Complete_t) - sizeof(RNDIS_Message_Header_t));
    6e64:	80 e1       	ldi	r24, 0x10	; 16
    6e66:	90 e0       	ldi	r25, 0x00	; 0
    6e68:	a0 e0       	ldi	r26, 0x00	; 0
    6e6a:	b0 e0       	ldi	r27, 0x00	; 0
    6e6c:	84 8b       	std	Z+20, r24	; 0x14
    6e6e:	95 8b       	std	Z+21, r25	; 0x15
    6e70:	a6 8b       	std	Z+22, r26	; 0x16
    6e72:	b7 8b       	std	Z+23, r27	; 0x17
				MessageHeader->MessageLength = CPU_TO_LE32(0);
			}

			break;
	}
}
    6e74:	df 91       	pop	r29
    6e76:	cf 91       	pop	r28
    6e78:	1f 91       	pop	r17
    6e7a:	0f 91       	pop	r16
    6e7c:	ff 90       	pop	r15
    6e7e:	ef 90       	pop	r14
    6e80:	08 95       	ret

00006e82 <RNDIS_Device_ConfigureEndpoints>:

bool RNDIS_Device_ConfigureEndpoints(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6e82:	cf 93       	push	r28
    6e84:	df 93       	push	r29
    6e86:	ec 01       	movw	r28, r24
	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    6e88:	48 96       	adiw	r24, 0x18	; 24
    6e8a:	fc 01       	movw	r30, r24
    6e8c:	86 e8       	ldi	r24, 0x86	; 134
    6e8e:	df 01       	movw	r26, r30
    6e90:	1d 92       	st	X+, r1
    6e92:	8a 95       	dec	r24
    6e94:	e9 f7       	brne	.-6      	; 0x6e90 <RNDIS_Device_ConfigureEndpoints+0xe>

	RNDISInterfaceInfo->Config.DataINEndpoint.Type       = EP_TYPE_BULK;
    6e96:	82 e0       	ldi	r24, 0x02	; 2
    6e98:	8c 83       	std	Y+4, r24	; 0x04
	RNDISInterfaceInfo->Config.DataOUTEndpoint.Type      = EP_TYPE_BULK;
    6e9a:	89 87       	std	Y+9, r24	; 0x09
	RNDISInterfaceInfo->Config.NotificationEndpoint.Type = EP_TYPE_INTERRUPT;
    6e9c:	83 e0       	ldi	r24, 0x03	; 3
    6e9e:	8e 87       	std	Y+14, r24	; 0x0e

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
    6ea0:	ce 01       	movw	r24, r28
    6ea2:	01 96       	adiw	r24, 0x01	; 1
    6ea4:	61 e0       	ldi	r22, 0x01	; 1
    6ea6:	0e 94 65 28 	call	0x50ca	; 0x50ca <Endpoint_ConfigureEndpointTable>
    6eaa:	88 23       	and	r24, r24
    6eac:	69 f0       	breq	.+26     	; 0x6ec8 <RNDIS_Device_ConfigureEndpoints+0x46>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
    6eae:	ce 01       	movw	r24, r28
    6eb0:	06 96       	adiw	r24, 0x06	; 6
    6eb2:	61 e0       	ldi	r22, 0x01	; 1
    6eb4:	0e 94 65 28 	call	0x50ca	; 0x50ca <Endpoint_ConfigureEndpointTable>
    6eb8:	88 23       	and	r24, r24
    6eba:	31 f0       	breq	.+12     	; 0x6ec8 <RNDIS_Device_ConfigureEndpoints+0x46>
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
    6ebc:	ce 01       	movw	r24, r28
    6ebe:	0b 96       	adiw	r24, 0x0b	; 11
    6ec0:	61 e0       	ldi	r22, 0x01	; 1
    6ec2:	0e 94 65 28 	call	0x50ca	; 0x50ca <Endpoint_ConfigureEndpointTable>
    6ec6:	01 c0       	rjmp	.+2      	; 0x6eca <RNDIS_Device_ConfigureEndpoints+0x48>

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataINEndpoint, 1)))
	  return false;

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.DataOUTEndpoint, 1)))
	  return false;
    6ec8:	80 e0       	ldi	r24, 0x00	; 0

	if (!(Endpoint_ConfigureEndpointTable(&RNDISInterfaceInfo->Config.NotificationEndpoint, 1)))
	  return false;

	return true;
}
    6eca:	df 91       	pop	r29
    6ecc:	cf 91       	pop	r28
    6ece:	08 95       	ret

00006ed0 <RNDIS_Device_USBTask>:

void RNDIS_Device_USBTask(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
    6ed0:	0f 93       	push	r16
    6ed2:	1f 93       	push	r17
    6ed4:	df 93       	push	r29
    6ed6:	cf 93       	push	r28
    6ed8:	cd b7       	in	r28, 0x3d	; 61
    6eda:	de b7       	in	r29, 0x3e	; 62
    6edc:	28 97       	sbiw	r28, 0x08	; 8
    6ede:	0f b6       	in	r0, 0x3f	; 63
    6ee0:	f8 94       	cli
    6ee2:	de bf       	out	0x3e, r29	; 62
    6ee4:	0f be       	out	0x3f, r0	; 63
    6ee6:	cd bf       	out	0x3d, r28	; 61
    6ee8:	8c 01       	movw	r16, r24
	if (USB_DeviceState != DEVICE_STATE_Configured)
    6eea:	8e b3       	in	r24, 0x1e	; 30
    6eec:	84 30       	cpi	r24, 0x04	; 4
    6eee:	41 f5       	brne	.+80     	; 0x6f40 <RNDIS_Device_USBTask+0x70>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6ef0:	f8 01       	movw	r30, r16
    6ef2:	83 85       	ldd	r24, Z+11	; 0x0b
    6ef4:	8f 70       	andi	r24, 0x0F	; 15
    6ef6:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if the current endpoint is ready for an IN packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsINReady(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsINReady(void)
			{
				return ((UEINTX & (1 << TXINI)) ? true : false);
    6efa:	80 91 e8 00 	lds	r24, 0x00E8
	  return;

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.NotificationEndpoint.Address);

	if (Endpoint_IsINReady() && RNDISInterfaceInfo->State.ResponseReady)
    6efe:	80 ff       	sbrs	r24, 0
    6f00:	1f c0       	rjmp	.+62     	; 0x6f40 <RNDIS_Device_USBTask+0x70>
    6f02:	e8 56       	subi	r30, 0x68	; 104
    6f04:	ff 4f       	sbci	r31, 0xFF	; 255
    6f06:	80 81       	ld	r24, Z
    6f08:	88 23       	and	r24, r24
    6f0a:	d1 f0       	breq	.+52     	; 0x6f40 <RNDIS_Device_USBTask+0x70>
	{
		USB_Request_Header_t Notification = (USB_Request_Header_t)
    6f0c:	de 01       	movw	r26, r28
    6f0e:	11 96       	adiw	r26, 0x01	; 1
    6f10:	ee e4       	ldi	r30, 0x4E	; 78
    6f12:	f3 e0       	ldi	r31, 0x03	; 3
    6f14:	88 e0       	ldi	r24, 0x08	; 8
    6f16:	01 90       	ld	r0, Z+
    6f18:	0d 92       	st	X+, r0
    6f1a:	81 50       	subi	r24, 0x01	; 1
    6f1c:	e1 f7       	brne	.-8      	; 0x6f16 <RNDIS_Device_USBTask+0x46>
				.wValue        = CPU_TO_LE16(0),
				.wIndex        = CPU_TO_LE16(0),
				.wLength       = CPU_TO_LE16(0),
			};

		Endpoint_Write_Stream_LE(&Notification, sizeof(USB_Request_Header_t), NULL);
    6f1e:	ce 01       	movw	r24, r28
    6f20:	01 96       	adiw	r24, 0x01	; 1
    6f22:	68 e0       	ldi	r22, 0x08	; 8
    6f24:	70 e0       	ldi	r23, 0x00	; 0
    6f26:	40 e0       	ldi	r20, 0x00	; 0
    6f28:	50 e0       	ldi	r21, 0x00	; 0
    6f2a:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    6f2e:	80 91 e8 00 	lds	r24, 0x00E8
    6f32:	8e 77       	andi	r24, 0x7E	; 126
    6f34:	80 93 e8 00 	sts	0x00E8, r24

		Endpoint_ClearIN();

		RNDISInterfaceInfo->State.ResponseReady = false;
    6f38:	f8 01       	movw	r30, r16
    6f3a:	e8 56       	subi	r30, 0x68	; 104
    6f3c:	ff 4f       	sbci	r31, 0xFF	; 255
    6f3e:	10 82       	st	Z, r1
	}
}
    6f40:	28 96       	adiw	r28, 0x08	; 8
    6f42:	0f b6       	in	r0, 0x3f	; 63
    6f44:	f8 94       	cli
    6f46:	de bf       	out	0x3e, r29	; 62
    6f48:	0f be       	out	0x3f, r0	; 63
    6f4a:	cd bf       	out	0x3d, r28	; 61
    6f4c:	cf 91       	pop	r28
    6f4e:	df 91       	pop	r29
    6f50:	1f 91       	pop	r17
    6f52:	0f 91       	pop	r16
    6f54:	08 95       	ret

00006f56 <RNDIS_Device_IsPacketReceived>:
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6f56:	2e b3       	in	r18, 0x1e	; 30
    6f58:	24 30       	cpi	r18, 0x04	; 4
    6f5a:	81 f4       	brne	.+32     	; 0x6f7c <RNDIS_Device_IsPacketReceived+0x26>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6f5c:	fc 01       	movw	r30, r24
    6f5e:	e7 56       	subi	r30, 0x67	; 103
    6f60:	ff 4f       	sbci	r31, 0xFF	; 255
	}
}

bool RNDIS_Device_IsPacketReceived(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6f62:	20 81       	ld	r18, Z
    6f64:	22 30       	cpi	r18, 0x02	; 2
    6f66:	61 f4       	brne	.+24     	; 0x6f80 <RNDIS_Device_IsPacketReceived+0x2a>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6f68:	fc 01       	movw	r30, r24
    6f6a:	86 81       	ldd	r24, Z+6	; 0x06
    6f6c:	8f 70       	andi	r24, 0x0F	; 15
    6f6e:	80 93 e9 00 	sts	0x00E9, r24
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6f72:	90 91 e8 00 	lds	r25, 0x00E8
    6f76:	81 e0       	ldi	r24, 0x01	; 1
    6f78:	92 fd       	sbrc	r25, 2
    6f7a:	03 c0       	rjmp	.+6      	; 0x6f82 <RNDIS_Device_IsPacketReceived+0x2c>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return false;
    6f7c:	80 e0       	ldi	r24, 0x00	; 0
    6f7e:	08 95       	ret
    6f80:	80 e0       	ldi	r24, 0x00	; 0
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);
	return Endpoint_IsOUTReceived();
}
    6f82:	08 95       	ret

00006f84 <RNDIS_Device_ReadPacket>:

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
    6f84:	ef 92       	push	r14
    6f86:	ff 92       	push	r15
    6f88:	0f 93       	push	r16
    6f8a:	1f 93       	push	r17
    6f8c:	df 93       	push	r29
    6f8e:	cf 93       	push	r28
    6f90:	cd b7       	in	r28, 0x3d	; 61
    6f92:	de b7       	in	r29, 0x3e	; 62
    6f94:	ac 97       	sbiw	r28, 0x2c	; 44
    6f96:	0f b6       	in	r0, 0x3f	; 63
    6f98:	f8 94       	cli
    6f9a:	de bf       	out	0x3e, r29	; 62
    6f9c:	0f be       	out	0x3f, r0	; 63
    6f9e:	cd bf       	out	0x3d, r28	; 61
    6fa0:	7b 01       	movw	r14, r22
    6fa2:	8a 01       	movw	r16, r20
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6fa4:	2e b3       	in	r18, 0x1e	; 30
    6fa6:	24 30       	cpi	r18, 0x04	; 4
    6fa8:	e1 f5       	brne	.+120    	; 0x7022 <RNDIS_Device_ReadPacket+0x9e>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    6faa:	fc 01       	movw	r30, r24
    6fac:	e7 56       	subi	r30, 0x67	; 103
    6fae:	ff 4f       	sbci	r31, 0xFF	; 255

uint8_t RNDIS_Device_ReadPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    6fb0:	20 81       	ld	r18, Z
    6fb2:	22 30       	cpi	r18, 0x02	; 2
    6fb4:	b1 f5       	brne	.+108    	; 0x7022 <RNDIS_Device_ReadPacket+0x9e>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    6fb6:	fc 01       	movw	r30, r24
    6fb8:	86 81       	ldd	r24, Z+6	; 0x06
    6fba:	8f 70       	andi	r24, 0x0F	; 15
    6fbc:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;
    6fc0:	fa 01       	movw	r30, r20
    6fc2:	11 82       	std	Z+1, r1	; 0x01
    6fc4:	10 82       	st	Z, r1
			 *  \return Boolean \c true if current endpoint is has received an OUT packet, \c false otherwise.
			 */
			static inline bool Endpoint_IsOUTReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Endpoint_IsOUTReceived(void)
			{
				return ((UEINTX & (1 << RXOUTI)) ? true : false);
    6fc6:	80 91 e8 00 	lds	r24, 0x00E8

	if (!(Endpoint_IsOUTReceived()))
    6fca:	82 ff       	sbrs	r24, 2
    6fcc:	2c c0       	rjmp	.+88     	; 0x7026 <RNDIS_Device_ReadPacket+0xa2>
		return ENDPOINT_RWSTREAM_NoError;

	RNDIS_Packet_Message_t RNDISPacketHeader;
	Endpoint_Read_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    6fce:	ce 01       	movw	r24, r28
    6fd0:	01 96       	adiw	r24, 0x01	; 1
    6fd2:	6c e2       	ldi	r22, 0x2C	; 44
    6fd4:	70 e0       	ldi	r23, 0x00	; 0
    6fd6:	40 e0       	ldi	r20, 0x00	; 0
    6fd8:	50 e0       	ldi	r21, 0x00	; 0
    6fda:	0e 94 db 26 	call	0x4db6	; 0x4db6 <Endpoint_Read_Stream_LE>

	if (le32_to_cpu(RNDISPacketHeader.DataLength) > ETHERNET_FRAME_SIZE_MAX)
    6fde:	2d 85       	ldd	r18, Y+13	; 0x0d
    6fe0:	3e 85       	ldd	r19, Y+14	; 0x0e
    6fe2:	4f 85       	ldd	r20, Y+15	; 0x0f
    6fe4:	58 89       	ldd	r21, Y+16	; 0x10
    6fe6:	2d 3d       	cpi	r18, 0xDD	; 221
    6fe8:	f5 e0       	ldi	r31, 0x05	; 5
    6fea:	3f 07       	cpc	r19, r31
    6fec:	f0 e0       	ldi	r31, 0x00	; 0
    6fee:	4f 07       	cpc	r20, r31
    6ff0:	f0 e0       	ldi	r31, 0x00	; 0
    6ff2:	5f 07       	cpc	r21, r31
    6ff4:	38 f0       	brcs	.+14     	; 0x7004 <RNDIS_Device_ReadPacket+0x80>
			 *  \ingroup Group_EndpointPacketManagement_AVR8
			 */
			static inline void Endpoint_StallTransaction(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_StallTransaction(void)
			{
				UECONX |= (1 << STALLRQ);
    6ff6:	80 91 eb 00 	lds	r24, 0x00EB
    6ffa:	80 62       	ori	r24, 0x20	; 32
    6ffc:	80 93 eb 00 	sts	0x00EB, r24
	{
		Endpoint_StallTransaction();

		return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    7000:	80 e8       	ldi	r24, 0x80	; 128
    7002:	12 c0       	rjmp	.+36     	; 0x7028 <RNDIS_Device_ReadPacket+0xa4>
	}

	*PacketLength = (uint16_t)le32_to_cpu(RNDISPacketHeader.DataLength);
    7004:	f8 01       	movw	r30, r16
    7006:	31 83       	std	Z+1, r19	; 0x01
    7008:	20 83       	st	Z, r18

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
    700a:	c7 01       	movw	r24, r14
    700c:	b9 01       	movw	r22, r18
    700e:	40 e0       	ldi	r20, 0x00	; 0
    7010:	50 e0       	ldi	r21, 0x00	; 0
    7012:	0e 94 db 26 	call	0x4db6	; 0x4db6 <Endpoint_Read_Stream_LE>
			 */
			static inline void Endpoint_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearOUT(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << RXOUTI) | (1 << FIFOCON));
    7016:	80 91 e8 00 	lds	r24, 0x00E8
    701a:	8b 77       	andi	r24, 0x7B	; 123
    701c:	80 93 e8 00 	sts	0x00E8, r24
    7020:	02 c0       	rjmp	.+4      	; 0x7026 <RNDIS_Device_ReadPacket+0xa2>
                                uint16_t* const PacketLength)
{
	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    7022:	82 e0       	ldi	r24, 0x02	; 2
    7024:	01 c0       	rjmp	.+2      	; 0x7028 <RNDIS_Device_ReadPacket+0xa4>
	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataOUTEndpoint.Address);

	*PacketLength = 0;

	if (!(Endpoint_IsOUTReceived()))
		return ENDPOINT_RWSTREAM_NoError;
    7026:	80 e0       	ldi	r24, 0x00	; 0

	Endpoint_Read_Stream_LE(Buffer, *PacketLength, NULL);
	Endpoint_ClearOUT();

	return ENDPOINT_RWSTREAM_NoError;
}
    7028:	ac 96       	adiw	r28, 0x2c	; 44
    702a:	0f b6       	in	r0, 0x3f	; 63
    702c:	f8 94       	cli
    702e:	de bf       	out	0x3e, r29	; 62
    7030:	0f be       	out	0x3f, r0	; 63
    7032:	cd bf       	out	0x3d, r28	; 61
    7034:	cf 91       	pop	r28
    7036:	df 91       	pop	r29
    7038:	1f 91       	pop	r17
    703a:	0f 91       	pop	r16
    703c:	ff 90       	pop	r15
    703e:	ef 90       	pop	r14
    7040:	08 95       	ret

00007042 <RNDIS_Device_SendPacket>:

uint8_t RNDIS_Device_SendPacket(USB_ClassInfo_RNDIS_Device_t* const RNDISInterfaceInfo,
                                void* Buffer,
                                const uint16_t PacketLength)
{
    7042:	ef 92       	push	r14
    7044:	ff 92       	push	r15
    7046:	0f 93       	push	r16
    7048:	1f 93       	push	r17
    704a:	df 93       	push	r29
    704c:	cf 93       	push	r28
    704e:	cd b7       	in	r28, 0x3d	; 61
    7050:	de b7       	in	r29, 0x3e	; 62
    7052:	ad 97       	sbiw	r28, 0x2d	; 45
    7054:	0f b6       	in	r0, 0x3f	; 63
    7056:	f8 94       	cli
    7058:	de bf       	out	0x3e, r29	; 62
    705a:	0f be       	out	0x3f, r0	; 63
    705c:	cd bf       	out	0x3d, r28	; 61
    705e:	7b 01       	movw	r14, r22
    7060:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    7062:	2e b3       	in	r18, 0x1e	; 30
    7064:	24 30       	cpi	r18, 0x04	; 4
    7066:	09 f0       	breq	.+2      	; 0x706a <RNDIS_Device_SendPacket+0x28>
    7068:	4c c0       	rjmp	.+152    	; 0x7102 <RNDIS_Device_SendPacket+0xc0>
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
    706a:	fc 01       	movw	r30, r24
    706c:	e7 56       	subi	r30, 0x67	; 103
    706e:	ff 4f       	sbci	r31, 0xFF	; 255
                                void* Buffer,
                                const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
    7070:	20 81       	ld	r18, Z
    7072:	22 30       	cpi	r18, 0x02	; 2
    7074:	09 f0       	breq	.+2      	; 0x7078 <RNDIS_Device_SendPacket+0x36>
    7076:	45 c0       	rjmp	.+138    	; 0x7102 <RNDIS_Device_SendPacket+0xc0>
			 */
			static inline void Endpoint_SelectEndpoint(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_SelectEndpoint(const uint8_t Address)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UENUM = (Address & ENDPOINT_EPNUM_MASK);
    7078:	fc 01       	movw	r30, r24
    707a:	81 81       	ldd	r24, Z+1	; 0x01
    707c:	8f 70       	andi	r24, 0x0F	; 15
    707e:	80 93 e9 00 	sts	0x00E9, r24
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
	}

	Endpoint_SelectEndpoint(RNDISInterfaceInfo->Config.DataINEndpoint.Address);

	if ((ErrorCode = Endpoint_WaitUntilReady()) != ENDPOINT_READYWAIT_NoError)
    7082:	0e 94 c8 28 	call	0x5190	; 0x5190 <Endpoint_WaitUntilReady>
    7086:	28 2f       	mov	r18, r24
    7088:	88 23       	and	r24, r24
    708a:	e1 f5       	brne	.+120    	; 0x7104 <RNDIS_Device_SendPacket+0xc2>
	  return ErrorCode;

	RNDIS_Packet_Message_t RNDISPacketHeader;

	memset(&RNDISPacketHeader, 0, sizeof(RNDIS_Packet_Message_t));
    708c:	ce 01       	movw	r24, r28
    708e:	01 96       	adiw	r24, 0x01	; 1
    7090:	3c e2       	ldi	r19, 0x2C	; 44
    7092:	fc 01       	movw	r30, r24
    7094:	11 92       	st	Z+, r1
    7096:	3a 95       	dec	r19
    7098:	e9 f7       	brne	.-6      	; 0x7094 <RNDIS_Device_SendPacket+0x52>

	RNDISPacketHeader.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    709a:	41 e0       	ldi	r20, 0x01	; 1
    709c:	50 e0       	ldi	r21, 0x00	; 0
    709e:	60 e0       	ldi	r22, 0x00	; 0
    70a0:	70 e0       	ldi	r23, 0x00	; 0
    70a2:	49 83       	std	Y+1, r20	; 0x01
    70a4:	5a 83       	std	Y+2, r21	; 0x02
    70a6:	6b 83       	std	Y+3, r22	; 0x03
    70a8:	7c 83       	std	Y+4, r23	; 0x04
	RNDISPacketHeader.MessageLength = cpu_to_le32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    70aa:	a8 01       	movw	r20, r16
    70ac:	44 5d       	subi	r20, 0xD4	; 212
    70ae:	5f 4f       	sbci	r21, 0xFF	; 255
    70b0:	60 e0       	ldi	r22, 0x00	; 0
    70b2:	70 e0       	ldi	r23, 0x00	; 0
    70b4:	4d 83       	std	Y+5, r20	; 0x05
    70b6:	5e 83       	std	Y+6, r21	; 0x06
    70b8:	6f 83       	std	Y+7, r22	; 0x07
    70ba:	78 87       	std	Y+8, r23	; 0x08
	RNDISPacketHeader.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    70bc:	44 e2       	ldi	r20, 0x24	; 36
    70be:	50 e0       	ldi	r21, 0x00	; 0
    70c0:	60 e0       	ldi	r22, 0x00	; 0
    70c2:	70 e0       	ldi	r23, 0x00	; 0
    70c4:	49 87       	std	Y+9, r20	; 0x09
    70c6:	5a 87       	std	Y+10, r21	; 0x0a
    70c8:	6b 87       	std	Y+11, r22	; 0x0b
    70ca:	7c 87       	std	Y+12, r23	; 0x0c
	RNDISPacketHeader.DataLength    = cpu_to_le32(PacketLength);
    70cc:	a8 01       	movw	r20, r16
    70ce:	60 e0       	ldi	r22, 0x00	; 0
    70d0:	70 e0       	ldi	r23, 0x00	; 0
    70d2:	4d 87       	std	Y+13, r20	; 0x0d
    70d4:	5e 87       	std	Y+14, r21	; 0x0e
    70d6:	6f 87       	std	Y+15, r22	; 0x0f
    70d8:	78 8b       	std	Y+16, r23	; 0x10

	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
    70da:	6c e2       	ldi	r22, 0x2C	; 44
    70dc:	70 e0       	ldi	r23, 0x00	; 0
    70de:	40 e0       	ldi	r20, 0x00	; 0
    70e0:	50 e0       	ldi	r21, 0x00	; 0
    70e2:	2d a7       	std	Y+45, r18	; 0x2d
    70e4:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
    70e8:	c7 01       	movw	r24, r14
    70ea:	b8 01       	movw	r22, r16
    70ec:	40 e0       	ldi	r20, 0x00	; 0
    70ee:	50 e0       	ldi	r21, 0x00	; 0
    70f0:	0e 94 29 26 	call	0x4c52	; 0x4c52 <Endpoint_Write_Stream_LE>
			 */
			static inline void Endpoint_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Endpoint_ClearIN(void)
			{
				#if !defined(CONTROL_ONLY_DEVICE)
					UEINTX &= ~((1 << TXINI) | (1 << FIFOCON));
    70f4:	80 91 e8 00 	lds	r24, 0x00E8
    70f8:	8e 77       	andi	r24, 0x7E	; 126
    70fa:	80 93 e8 00 	sts	0x00E8, r24
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
    70fe:	2d a5       	ldd	r18, Y+45	; 0x2d
    7100:	01 c0       	rjmp	.+2      	; 0x7104 <RNDIS_Device_SendPacket+0xc2>
	uint8_t ErrorCode;

	if ((USB_DeviceState != DEVICE_STATE_Configured) ||
	    (RNDISInterfaceInfo->State.CurrRNDISState != RNDIS_Data_Initialized))
	{
		return ENDPOINT_RWSTREAM_DeviceDisconnected;
    7102:	22 e0       	ldi	r18, 0x02	; 2
	Endpoint_Write_Stream_LE(&RNDISPacketHeader, sizeof(RNDIS_Packet_Message_t), NULL);
	Endpoint_Write_Stream_LE(Buffer, PacketLength, NULL);
	Endpoint_ClearIN();

	return ENDPOINT_RWSTREAM_NoError;
}
    7104:	82 2f       	mov	r24, r18
    7106:	ad 96       	adiw	r28, 0x2d	; 45
    7108:	0f b6       	in	r0, 0x3f	; 63
    710a:	f8 94       	cli
    710c:	de bf       	out	0x3e, r29	; 62
    710e:	0f be       	out	0x3f, r0	; 63
    7110:	cd bf       	out	0x3d, r28	; 61
    7112:	cf 91       	pop	r28
    7114:	df 91       	pop	r29
    7116:	1f 91       	pop	r17
    7118:	0f 91       	pop	r16
    711a:	ff 90       	pop	r15
    711c:	ef 90       	pop	r14
    711e:	08 95       	ret

00007120 <DCOMP_RNDIS_Host_NextRNDISControlInterface>:

	return RNDIS_ENUMERROR_NoError;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISControlInterface(void* const CurrentDescriptor)
{
    7120:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7122:	81 81       	ldd	r24, Z+1	; 0x01
    7124:	84 30       	cpi	r24, 0x04	; 4
    7126:	49 f4       	brne	.+18     	; 0x713a <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
    7128:	85 81       	ldd	r24, Z+5	; 0x05
    712a:	82 30       	cpi	r24, 0x02	; 2
    712c:	31 f4       	brne	.+12     	; 0x713a <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
    712e:	86 81       	ldd	r24, Z+6	; 0x06
    7130:	82 30       	cpi	r24, 0x02	; 2
    7132:	19 f4       	brne	.+6      	; 0x713a <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1a>
		    (Interface->SubClass == CDC_CSCP_ACMSubclass) &&
    7134:	87 81       	ldd	r24, Z+7	; 0x07
    7136:	8f 3f       	cpi	r24, 0xFF	; 255
    7138:	11 f0       	breq	.+4      	; 0x713e <DCOMP_RNDIS_Host_NextRNDISControlInterface+0x1e>
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    713a:	82 e0       	ldi	r24, 0x02	; 2
    713c:	08 95       	ret

		if ((Interface->Class    == CDC_CSCP_CDCClass)    &&
		    (Interface->SubClass == CDC_CSCP_ACMSubclass) &&
		    (Interface->Protocol == CDC_CSCP_VendorSpecificProtocol))
		{
			return DESCRIPTOR_SEARCH_Found;
    713e:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7140:	08 95       	ret

00007142 <DCOMP_RNDIS_Host_NextRNDISDataInterface>:

static uint8_t DCOMP_RNDIS_Host_NextRNDISDataInterface(void* const CurrentDescriptor)
{
    7142:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Interface)
    7144:	81 81       	ldd	r24, Z+1	; 0x01
    7146:	84 30       	cpi	r24, 0x04	; 4
    7148:	49 f4       	brne	.+18     	; 0x715c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
	{
		USB_Descriptor_Interface_t* Interface = DESCRIPTOR_PCAST(CurrentDescriptor,
		                                                         USB_Descriptor_Interface_t);

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
    714a:	85 81       	ldd	r24, Z+5	; 0x05
    714c:	8a 30       	cpi	r24, 0x0A	; 10
    714e:	31 f4       	brne	.+12     	; 0x715c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
    7150:	86 81       	ldd	r24, Z+6	; 0x06
    7152:	88 23       	and	r24, r24
    7154:	19 f4       	brne	.+6      	; 0x715c <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1a>
		    (Interface->SubClass == CDC_CSCP_NoDataSubclass) &&
    7156:	87 81       	ldd	r24, Z+7	; 0x07
    7158:	88 23       	and	r24, r24
    715a:	11 f0       	breq	.+4      	; 0x7160 <DCOMP_RNDIS_Host_NextRNDISDataInterface+0x1e>
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
    715c:	82 e0       	ldi	r24, 0x02	; 2
    715e:	08 95       	ret

		if ((Interface->Class    == CDC_CSCP_CDCDataClass)   &&
		    (Interface->SubClass == CDC_CSCP_NoDataSubclass) &&
		    (Interface->Protocol == CDC_CSCP_NoDataProtocol))
		{
			return DESCRIPTOR_SEARCH_Found;
    7160:	80 e0       	ldi	r24, 0x00	; 0
		}
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    7162:	08 95       	ret

00007164 <RNDIS_SendEncapsulatedCommand>:

static uint8_t RNDIS_SendEncapsulatedCommand(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    7164:	fc 01       	movw	r30, r24
    7166:	87 89       	ldd	r24, Z+23	; 0x17
    7168:	91 e2       	ldi	r25, 0x21	; 33
    716a:	90 93 ae 0d 	sts	0x0DAE, r25
    716e:	10 92 af 0d 	sts	0x0DAF, r1
    7172:	10 92 b1 0d 	sts	0x0DB1, r1
    7176:	10 92 b0 0d 	sts	0x0DB0, r1
    717a:	80 93 b2 0d 	sts	0x0DB2, r24
    717e:	10 92 b3 0d 	sts	0x0DB3, r1
    7182:	50 93 b5 0d 	sts	0x0DB5, r21
    7186:	40 93 b4 0d 	sts	0x0DB4, r20
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    718a:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    718e:	cb 01       	movw	r24, r22
}
    7190:	b8 c8       	rjmp	.-3728   	; 0x6302 <USB_Host_SendControlRequest>

00007192 <RNDIS_GetEncapsulatedResponse>:

static uint8_t RNDIS_GetEncapsulatedResponse(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                             void* Buffer,
                                             const uint16_t Length)
{
	USB_ControlRequest = (USB_Request_Header_t)
    7192:	fc 01       	movw	r30, r24
    7194:	87 89       	ldd	r24, Z+23	; 0x17
    7196:	91 ea       	ldi	r25, 0xA1	; 161
    7198:	90 93 ae 0d 	sts	0x0DAE, r25
    719c:	91 e0       	ldi	r25, 0x01	; 1
    719e:	90 93 af 0d 	sts	0x0DAF, r25
    71a2:	10 92 b1 0d 	sts	0x0DB1, r1
    71a6:	10 92 b0 0d 	sts	0x0DB0, r1
    71aa:	80 93 b2 0d 	sts	0x0DB2, r24
    71ae:	10 92 b3 0d 	sts	0x0DB3, r1
    71b2:	50 93 b5 0d 	sts	0x0DB5, r21
    71b6:	40 93 b4 0d 	sts	0x0DB4, r20
    71ba:	10 92 a7 00 	sts	0x00A7, r1
			.wLength       = Length,
		};

	Pipe_SelectPipe(PIPE_CONTROLPIPE);

	return USB_Host_SendControlRequest(Buffer);
    71be:	cb 01       	movw	r24, r22
}
    71c0:	a0 c8       	rjmp	.-3776   	; 0x6302 <USB_Host_SendControlRequest>

000071c2 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint>:

	return DESCRIPTOR_SEARCH_NotFound;
}

static uint8_t DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint(void* const CurrentDescriptor)
{
    71c2:	fc 01       	movw	r30, r24
	USB_Descriptor_Header_t* Header = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Header_t);

	if (Header->Type == DTYPE_Endpoint)
    71c4:	81 81       	ldd	r24, Z+1	; 0x01
    71c6:	85 30       	cpi	r24, 0x05	; 5
    71c8:	59 f4       	brne	.+22     	; 0x71e0 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x1e>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);
    71ca:	83 81       	ldd	r24, Z+3	; 0x03
    71cc:	83 70       	andi	r24, 0x03	; 3

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    71ce:	82 50       	subi	r24, 0x02	; 2
    71d0:	82 30       	cpi	r24, 0x02	; 2
    71d2:	40 f4       	brcc	.+16     	; 0x71e4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x22>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
    71d4:	82 81       	ldd	r24, Z+2	; 0x02
    71d6:	0e 94 81 2c 	call	0x5902	; 0x5902 <Pipe_IsEndpointBound>
	{
		USB_Descriptor_Endpoint_t* Endpoint = DESCRIPTOR_PCAST(CurrentDescriptor, USB_Descriptor_Endpoint_t);

		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
    71da:	88 23       	and	r24, r24
    71dc:	19 f4       	brne	.+6      	; 0x71e4 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x22>
    71de:	04 c0       	rjmp	.+8      	; 0x71e8 <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x26>
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
		}
	}
	else if (Header->Type == DTYPE_Interface)
    71e0:	84 30       	cpi	r24, 0x04	; 4
    71e2:	21 f0       	breq	.+8      	; 0x71ec <DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint+0x2a>
	{
		return DESCRIPTOR_SEARCH_Fail;
	}

	return DESCRIPTOR_SEARCH_NotFound;
    71e4:	82 e0       	ldi	r24, 0x02	; 2
    71e6:	08 95       	ret
		uint8_t EndpointType = (Endpoint->Attributes & EP_TYPE_MASK);

		if (((EndpointType == EP_TYPE_BULK) || (EndpointType == EP_TYPE_INTERRUPT)) &&
		    !(Pipe_IsEndpointBound(Endpoint->EndpointAddress)))
		{
			return DESCRIPTOR_SEARCH_Found;
    71e8:	80 e0       	ldi	r24, 0x00	; 0
    71ea:	08 95       	ret
		}
	}
	else if (Header->Type == DTYPE_Interface)
	{
		return DESCRIPTOR_SEARCH_Fail;
    71ec:	81 e0       	ldi	r24, 0x01	; 1
	}

	return DESCRIPTOR_SEARCH_NotFound;
}
    71ee:	08 95       	ret

000071f0 <RNDIS_Host_ConfigurePipes>:
#include "RNDISClassHost.h"

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
    71f0:	4f 92       	push	r4
    71f2:	5f 92       	push	r5
    71f4:	6f 92       	push	r6
    71f6:	7f 92       	push	r7
    71f8:	8f 92       	push	r8
    71fa:	9f 92       	push	r9
    71fc:	af 92       	push	r10
    71fe:	bf 92       	push	r11
    7200:	cf 92       	push	r12
    7202:	df 92       	push	r13
    7204:	ef 92       	push	r14
    7206:	ff 92       	push	r15
    7208:	0f 93       	push	r16
    720a:	1f 93       	push	r17
    720c:	df 93       	push	r29
    720e:	cf 93       	push	r28
    7210:	00 d0       	rcall	.+0      	; 0x7212 <RNDIS_Host_ConfigurePipes+0x22>
    7212:	00 d0       	rcall	.+0      	; 0x7214 <RNDIS_Host_ConfigurePipes+0x24>
    7214:	cd b7       	in	r28, 0x3d	; 61
    7216:	de b7       	in	r29, 0x3e	; 62
    7218:	8c 01       	movw	r16, r24
    721a:	7a 83       	std	Y+2, r23	; 0x02
    721c:	69 83       	std	Y+1, r22	; 0x01
    721e:	5c 83       	std	Y+4, r21	; 0x04
    7220:	4b 83       	std	Y+3, r20	; 0x03
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));
    7222:	46 96       	adiw	r24, 0x16	; 22
    7224:	fc 01       	movw	r30, r24
    7226:	8a e0       	ldi	r24, 0x0A	; 10
    7228:	df 01       	movw	r26, r30
    722a:	1d 92       	st	X+, r1
    722c:	8a 95       	dec	r24
    722e:	e9 f7       	brne	.-6      	; 0x722a <RNDIS_Host_ConfigurePipes+0x3a>

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
    7230:	eb 81       	ldd	r30, Y+3	; 0x03
    7232:	fc 81       	ldd	r31, Y+4	; 0x04
    7234:	81 81       	ldd	r24, Z+1	; 0x01
    7236:	82 30       	cpi	r24, 0x02	; 2
    7238:	09 f0       	breq	.+2      	; 0x723c <RNDIS_Host_ConfigurePipes+0x4c>
    723a:	96 c0       	rjmp	.+300    	; 0x7368 <RNDIS_Host_ConfigurePipes+0x178>
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    723c:	2f 01       	movw	r4, r30
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
	USB_Descriptor_Endpoint_t*  NotificationEndpoint  = NULL;
    723e:	aa 24       	eor	r10, r10
    7240:	bb 24       	eor	r11, r11
uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
	USB_Descriptor_Endpoint_t*  DataOUTEndpoint       = NULL;
    7242:	cc 24       	eor	r12, r12
    7244:	dd 24       	eor	r13, r13

uint8_t RNDIS_Host_ConfigurePipes(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                  uint16_t ConfigDescriptorSize,
                                  void* ConfigDescriptorData)
{
	USB_Descriptor_Endpoint_t*  DataINEndpoint        = NULL;
    7246:	ee 24       	eor	r14, r14
    7248:	ff 24       	eor	r15, r15
	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    724a:	83 e0       	ldi	r24, 0x03	; 3
    724c:	68 2e       	mov	r6, r24
    724e:	71 2c       	mov	r7, r1
    7250:	6c 0e       	add	r6, r28
    7252:	7d 1e       	adc	r7, r29
    7254:	4e 01       	movw	r8, r28
    7256:	08 94       	sec
    7258:	81 1c       	adc	r8, r1
    725a:	91 1c       	adc	r9, r1

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    725c:	41 14       	cp	r4, r1
    725e:	51 04       	cpc	r5, r1
    7260:	41 f0       	breq	.+16     	; 0x7272 <RNDIS_Host_ConfigurePipes+0x82>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7262:	c4 01       	movw	r24, r8
    7264:	b3 01       	movw	r22, r6
    7266:	41 ee       	ldi	r20, 0xE1	; 225
    7268:	58 e3       	ldi	r21, 0x38	; 56
    726a:	0e 94 ab 2f 	call	0x5f56	; 0x5f56 <USB_GetNextDescriptorComp>

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
	{
		if (!(RNDISControlInterface) ||
    726e:	88 23       	and	r24, r24
    7270:	e9 f0       	breq	.+58     	; 0x72ac <RNDIS_Host_ConfigurePipes+0xbc>
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
    7272:	a1 14       	cp	r10, r1
    7274:	b1 04       	cpc	r11, r1
    7276:	71 f0       	breq	.+28     	; 0x7294 <RNDIS_Host_ConfigurePipes+0xa4>
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7278:	c4 01       	movw	r24, r8
    727a:	b3 01       	movw	r22, r6
    727c:	41 ea       	ldi	r20, 0xA1	; 161
    727e:	58 e3       	ldi	r21, 0x38	; 56
    7280:	0e 94 ab 2f 	call	0x5f56	; 0x5f56 <USB_GetNextDescriptorComp>
    7284:	88 23       	and	r24, r24
    7286:	09 f0       	breq	.+2      	; 0x728a <RNDIS_Host_ConfigurePipes+0x9a>
    7288:	71 c0       	rjmp	.+226    	; 0x736c <RNDIS_Host_ConfigurePipes+0x17c>
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
    728a:	cc 24       	eor	r12, r12
    728c:	dd 24       	eor	r13, r13
		    USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
		                              DCOMP_RNDIS_Host_NextRNDISInterfaceEndpoint) != DESCRIPTOR_SEARCH_COMP_Found)
		{
			if (NotificationEndpoint)
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    728e:	ee 24       	eor	r14, r14
    7290:	ff 24       	eor	r15, r15
    7292:	e4 cf       	rjmp	.-56     	; 0x725c <RNDIS_Host_ConfigurePipes+0x6c>
				DataINEndpoint  = NULL;
				DataOUTEndpoint = NULL;
			}
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
    7294:	c4 01       	movw	r24, r8
    7296:	b3 01       	movw	r22, r6
    7298:	40 e9       	ldi	r20, 0x90	; 144
    729a:	58 e3       	ldi	r21, 0x38	; 56
    729c:	0e 94 ab 2f 	call	0x5f56	; 0x5f56 <USB_GetNextDescriptorComp>
    72a0:	88 23       	and	r24, r24
    72a2:	09 f0       	breq	.+2      	; 0x72a6 <RNDIS_Host_ConfigurePipes+0xb6>
    72a4:	63 c0       	rjmp	.+198    	; 0x736c <RNDIS_Host_ConfigurePipes+0x17c>
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
				}

				RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);
    72a6:	4b 80       	ldd	r4, Y+3	; 0x03
    72a8:	5c 80       	ldd	r5, Y+4	; 0x04
    72aa:	0e c0       	rjmp	.+28     	; 0x72c8 <RNDIS_Host_ConfigurePipes+0xd8>
			}

			continue;
		}

		USB_Descriptor_Endpoint_t* EndpointData = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Endpoint_t);
    72ac:	eb 81       	ldd	r30, Y+3	; 0x03
    72ae:	fc 81       	ldd	r31, Y+4	; 0x04

		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
    72b0:	82 81       	ldd	r24, Z+2	; 0x02
    72b2:	87 ff       	sbrs	r24, 7
    72b4:	06 c0       	rjmp	.+12     	; 0x72c2 <RNDIS_Host_ConfigurePipes+0xd2>
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
    72b6:	83 81       	ldd	r24, Z+3	; 0x03
    72b8:	83 70       	andi	r24, 0x03	; 3
    72ba:	83 30       	cpi	r24, 0x03	; 3
    72bc:	21 f4       	brne	.+8      	; 0x72c6 <RNDIS_Host_ConfigurePipes+0xd6>
			  NotificationEndpoint = EndpointData;
    72be:	5f 01       	movw	r10, r30
    72c0:	03 c0       	rjmp	.+6      	; 0x72c8 <RNDIS_Host_ConfigurePipes+0xd8>
			else
			  DataINEndpoint = EndpointData;
		}
		else
		{
			DataOUTEndpoint = EndpointData;
    72c2:	6f 01       	movw	r12, r30
    72c4:	01 c0       	rjmp	.+2      	; 0x72c8 <RNDIS_Host_ConfigurePipes+0xd8>
		if ((EndpointData->EndpointAddress & ENDPOINT_DIR_MASK) == ENDPOINT_DIR_IN)
		{
			if ((EndpointData->Attributes & EP_TYPE_MASK) == EP_TYPE_INTERRUPT)
			  NotificationEndpoint = EndpointData;
			else
			  DataINEndpoint = EndpointData;
    72c6:	7f 01       	movw	r14, r30
	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;

	RNDISControlInterface = DESCRIPTOR_PCAST(ConfigDescriptorData, USB_Descriptor_Interface_t);

	while (!(DataINEndpoint) || !(DataOUTEndpoint) || !(NotificationEndpoint))
    72c8:	e1 14       	cp	r14, r1
    72ca:	f1 04       	cpc	r15, r1
    72cc:	39 f2       	breq	.-114    	; 0x725c <RNDIS_Host_ConfigurePipes+0x6c>
    72ce:	c1 14       	cp	r12, r1
    72d0:	d1 04       	cpc	r13, r1
    72d2:	21 f2       	breq	.-120    	; 0x725c <RNDIS_Host_ConfigurePipes+0x6c>
    72d4:	a1 14       	cp	r10, r1
    72d6:	b1 04       	cpc	r11, r1
    72d8:	09 f2       	breq	.-126    	; 0x725c <RNDIS_Host_ConfigurePipes+0x6c>
		{
			DataOUTEndpoint = EndpointData;
		}
	}

	RNDISInterfaceInfo->Config.DataINPipe.Size  = le16_to_cpu(DataINEndpoint->EndpointSize);
    72da:	f7 01       	movw	r30, r14
    72dc:	84 81       	ldd	r24, Z+4	; 0x04
    72de:	95 81       	ldd	r25, Z+5	; 0x05
    72e0:	d8 01       	movw	r26, r16
    72e2:	12 96       	adiw	r26, 0x02	; 2
    72e4:	9c 93       	st	X, r25
    72e6:	8e 93       	st	-X, r24
    72e8:	11 97       	sbiw	r26, 0x01	; 1
	RNDISInterfaceInfo->Config.DataINPipe.EndpointAddress = DataINEndpoint->EndpointAddress;
    72ea:	82 81       	ldd	r24, Z+2	; 0x02
    72ec:	13 96       	adiw	r26, 0x03	; 3
    72ee:	8c 93       	st	X, r24
    72f0:	13 97       	sbiw	r26, 0x03	; 3
	RNDISInterfaceInfo->Config.DataINPipe.Type  = EP_TYPE_BULK;
    72f2:	22 e0       	ldi	r18, 0x02	; 2
    72f4:	14 96       	adiw	r26, 0x04	; 4
    72f6:	2c 93       	st	X, r18
    72f8:	14 97       	sbiw	r26, 0x04	; 4
	
	RNDISInterfaceInfo->Config.DataOUTPipe.Size = le16_to_cpu(DataOUTEndpoint->EndpointSize);
    72fa:	f6 01       	movw	r30, r12
    72fc:	84 81       	ldd	r24, Z+4	; 0x04
    72fe:	95 81       	ldd	r25, Z+5	; 0x05
    7300:	18 96       	adiw	r26, 0x08	; 8
    7302:	9c 93       	st	X, r25
    7304:	8e 93       	st	-X, r24
    7306:	17 97       	sbiw	r26, 0x07	; 7
	RNDISInterfaceInfo->Config.DataOUTPipe.EndpointAddress = DataOUTEndpoint->EndpointAddress;
    7308:	82 81       	ldd	r24, Z+2	; 0x02
    730a:	19 96       	adiw	r26, 0x09	; 9
    730c:	8c 93       	st	X, r24
    730e:	19 97       	sbiw	r26, 0x09	; 9
	RNDISInterfaceInfo->Config.DataOUTPipe.Type = EP_TYPE_BULK;
    7310:	1a 96       	adiw	r26, 0x0a	; 10
    7312:	2c 93       	st	X, r18
	
	RNDISInterfaceInfo->Config.NotificationPipe.Size = le16_to_cpu(NotificationEndpoint->EndpointSize);
    7314:	d5 01       	movw	r26, r10
    7316:	14 96       	adiw	r26, 0x04	; 4
    7318:	8d 91       	ld	r24, X+
    731a:	9c 91       	ld	r25, X
    731c:	15 97       	sbiw	r26, 0x05	; 5
    731e:	f8 01       	movw	r30, r16
    7320:	96 87       	std	Z+14, r25	; 0x0e
    7322:	85 87       	std	Z+13, r24	; 0x0d
	RNDISInterfaceInfo->Config.NotificationPipe.EndpointAddress = NotificationEndpoint->EndpointAddress;
    7324:	12 96       	adiw	r26, 0x02	; 2
    7326:	8c 91       	ld	r24, X
    7328:	87 87       	std	Z+15, r24	; 0x0f
	RNDISInterfaceInfo->Config.NotificationPipe.Type = EP_TYPE_INTERRUPT;
    732a:	83 e0       	ldi	r24, 0x03	; 3
    732c:	80 8b       	std	Z+16, r24	; 0x10

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataINPipe, 1)))
    732e:	c8 01       	movw	r24, r16
    7330:	61 e0       	ldi	r22, 0x01	; 1
    7332:	0e 94 44 2c 	call	0x5888	; 0x5888 <Pipe_ConfigurePipeTable>
    7336:	88 23       	and	r24, r24
    7338:	d9 f0       	breq	.+54     	; 0x7370 <RNDIS_Host_ConfigurePipes+0x180>
	  return false;
	
	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataOUTPipe, 1)))
    733a:	c8 01       	movw	r24, r16
    733c:	06 96       	adiw	r24, 0x06	; 6
    733e:	61 e0       	ldi	r22, 0x01	; 1
    7340:	0e 94 44 2c 	call	0x5888	; 0x5888 <Pipe_ConfigurePipeTable>
    7344:	88 23       	and	r24, r24
    7346:	a1 f0       	breq	.+40     	; 0x7370 <RNDIS_Host_ConfigurePipes+0x180>
	  return false;

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.NotificationPipe, 1)))
    7348:	c8 01       	movw	r24, r16
    734a:	0c 96       	adiw	r24, 0x0c	; 12
    734c:	61 e0       	ldi	r22, 0x01	; 1
    734e:	0e 94 44 2c 	call	0x5888	; 0x5888 <Pipe_ConfigurePipeTable>
    7352:	88 23       	and	r24, r24
    7354:	69 f0       	breq	.+26     	; 0x7370 <RNDIS_Host_ConfigurePipes+0x180>
	  return false;

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
    7356:	d2 01       	movw	r26, r4
    7358:	12 96       	adiw	r26, 0x02	; 2
    735a:	8c 91       	ld	r24, X
    735c:	12 97       	sbiw	r26, 0x02	; 2
    735e:	f8 01       	movw	r30, r16
    7360:	87 8b       	std	Z+23, r24	; 0x17
	RNDISInterfaceInfo->State.IsActive = true;
    7362:	81 e0       	ldi	r24, 0x01	; 1
    7364:	86 8b       	std	Z+22, r24	; 0x16
    7366:	04 c0       	rjmp	.+8      	; 0x7370 <RNDIS_Host_ConfigurePipes+0x180>
	USB_Descriptor_Interface_t* RNDISControlInterface = NULL;

	memset(&RNDISInterfaceInfo->State, 0x00, sizeof(RNDISInterfaceInfo->State));

	if (DESCRIPTOR_TYPE(ConfigDescriptorData) != DTYPE_Configuration)
	  return RNDIS_ENUMERROR_InvalidConfigDescriptor;
    7368:	81 e0       	ldi	r24, 0x01	; 1
    736a:	03 c0       	rjmp	.+6      	; 0x7372 <RNDIS_Host_ConfigurePipes+0x182>
			else
			{
				if (USB_GetNextDescriptorComp(&ConfigDescriptorSize, &ConfigDescriptorData,
											  DCOMP_RNDIS_Host_NextRNDISControlInterface) != DESCRIPTOR_SEARCH_COMP_Found)
				{
					return RNDIS_ENUMERROR_NoCompatibleInterfaceFound;
    736c:	82 e0       	ldi	r24, 0x02	; 2
    736e:	01 c0       	rjmp	.+2      	; 0x7372 <RNDIS_Host_ConfigurePipes+0x182>
	
	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.DataOUTPipe, 1)))
	  return false;

	if (!(Pipe_ConfigurePipeTable(&RNDISInterfaceInfo->Config.NotificationPipe, 1)))
	  return false;
    7370:	80 e0       	ldi	r24, 0x00	; 0

	RNDISInterfaceInfo->State.ControlInterfaceNumber = RNDISControlInterface->InterfaceNumber;
	RNDISInterfaceInfo->State.IsActive = true;

	return RNDIS_ENUMERROR_NoError;
}
    7372:	0f 90       	pop	r0
    7374:	0f 90       	pop	r0
    7376:	0f 90       	pop	r0
    7378:	0f 90       	pop	r0
    737a:	cf 91       	pop	r28
    737c:	df 91       	pop	r29
    737e:	1f 91       	pop	r17
    7380:	0f 91       	pop	r16
    7382:	ff 90       	pop	r15
    7384:	ef 90       	pop	r14
    7386:	df 90       	pop	r13
    7388:	cf 90       	pop	r12
    738a:	bf 90       	pop	r11
    738c:	af 90       	pop	r10
    738e:	9f 90       	pop	r9
    7390:	8f 90       	pop	r8
    7392:	7f 90       	pop	r7
    7394:	6f 90       	pop	r6
    7396:	5f 90       	pop	r5
    7398:	4f 90       	pop	r4
    739a:	08 95       	ret

0000739c <RNDIS_Host_InitializeDevice>:

	return HOST_SENDCONTROL_Successful;
}

uint8_t RNDIS_Host_InitializeDevice(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    739c:	0f 93       	push	r16
    739e:	1f 93       	push	r17
    73a0:	df 93       	push	r29
    73a2:	cf 93       	push	r28
    73a4:	cd b7       	in	r28, 0x3d	; 61
    73a6:	de b7       	in	r29, 0x3e	; 62
    73a8:	cc 54       	subi	r28, 0x4C	; 76
    73aa:	d0 40       	sbci	r29, 0x00	; 0
    73ac:	0f b6       	in	r0, 0x3f	; 63
    73ae:	f8 94       	cli
    73b0:	de bf       	out	0x3e, r29	; 62
    73b2:	0f be       	out	0x3f, r0	; 63
    73b4:	cd bf       	out	0x3d, r28	; 61
    73b6:	8c 01       	movw	r16, r24
	uint8_t ErrorCode;

	RNDIS_Initialize_Message_t  InitMessage;
	RNDIS_Initialize_Complete_t InitMessageResponse;

	InitMessage.MessageType     = CPU_TO_LE32(REMOTE_NDIS_INITIALIZE_MSG);
    73b8:	82 e0       	ldi	r24, 0x02	; 2
    73ba:	90 e0       	ldi	r25, 0x00	; 0
    73bc:	a0 e0       	ldi	r26, 0x00	; 0
    73be:	b0 e0       	ldi	r27, 0x00	; 0
    73c0:	89 83       	std	Y+1, r24	; 0x01
    73c2:	9a 83       	std	Y+2, r25	; 0x02
    73c4:	ab 83       	std	Y+3, r26	; 0x03
    73c6:	bc 83       	std	Y+4, r27	; 0x04
	InitMessage.MessageLength   = CPU_TO_LE32(sizeof(RNDIS_Initialize_Message_t));
    73c8:	88 e1       	ldi	r24, 0x18	; 24
    73ca:	90 e0       	ldi	r25, 0x00	; 0
    73cc:	a0 e0       	ldi	r26, 0x00	; 0
    73ce:	b0 e0       	ldi	r27, 0x00	; 0
    73d0:	8d 83       	std	Y+5, r24	; 0x05
    73d2:	9e 83       	std	Y+6, r25	; 0x06
    73d4:	af 83       	std	Y+7, r26	; 0x07
    73d6:	b8 87       	std	Y+8, r27	; 0x08
	InitMessage.RequestId       = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    73d8:	f8 01       	movw	r30, r16
    73da:	84 8d       	ldd	r24, Z+28	; 0x1c
    73dc:	95 8d       	ldd	r25, Z+29	; 0x1d
    73de:	a6 8d       	ldd	r26, Z+30	; 0x1e
    73e0:	b7 8d       	ldd	r27, Z+31	; 0x1f
    73e2:	89 87       	std	Y+9, r24	; 0x09
    73e4:	9a 87       	std	Y+10, r25	; 0x0a
    73e6:	ab 87       	std	Y+11, r26	; 0x0b
    73e8:	bc 87       	std	Y+12, r27	; 0x0c
    73ea:	01 96       	adiw	r24, 0x01	; 1
    73ec:	a1 1d       	adc	r26, r1
    73ee:	b1 1d       	adc	r27, r1
    73f0:	84 8f       	std	Z+28, r24	; 0x1c
    73f2:	95 8f       	std	Z+29, r25	; 0x1d
    73f4:	a6 8f       	std	Z+30, r26	; 0x1e
    73f6:	b7 8f       	std	Z+31, r27	; 0x1f

	InitMessage.MajorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MAJOR);
    73f8:	81 e0       	ldi	r24, 0x01	; 1
    73fa:	90 e0       	ldi	r25, 0x00	; 0
    73fc:	a0 e0       	ldi	r26, 0x00	; 0
    73fe:	b0 e0       	ldi	r27, 0x00	; 0
    7400:	8d 87       	std	Y+13, r24	; 0x0d
    7402:	9e 87       	std	Y+14, r25	; 0x0e
    7404:	af 87       	std	Y+15, r26	; 0x0f
    7406:	b8 8b       	std	Y+16, r27	; 0x10
	InitMessage.MinorVersion    = CPU_TO_LE32(REMOTE_NDIS_VERSION_MINOR);
    7408:	19 8a       	std	Y+17, r1	; 0x11
    740a:	1a 8a       	std	Y+18, r1	; 0x12
    740c:	1b 8a       	std	Y+19, r1	; 0x13
    740e:	1c 8a       	std	Y+20, r1	; 0x14
	InitMessage.MaxTransferSize = cpu_to_le32(RNDISInterfaceInfo->Config.HostMaxPacketSize);
    7410:	82 89       	ldd	r24, Z+18	; 0x12
    7412:	93 89       	ldd	r25, Z+19	; 0x13
    7414:	a4 89       	ldd	r26, Z+20	; 0x14
    7416:	b5 89       	ldd	r27, Z+21	; 0x15
    7418:	8d 8b       	std	Y+21, r24	; 0x15
    741a:	9e 8b       	std	Y+22, r25	; 0x16
    741c:	af 8b       	std	Y+23, r26	; 0x17
    741e:	b8 8f       	std	Y+24, r27	; 0x18

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &InitMessage,
    7420:	c8 01       	movw	r24, r16
    7422:	be 01       	movw	r22, r28
    7424:	6f 5f       	subi	r22, 0xFF	; 255
    7426:	7f 4f       	sbci	r23, 0xFF	; 255
    7428:	48 e1       	ldi	r20, 0x18	; 24
    742a:	50 e0       	ldi	r21, 0x00	; 0
    742c:	9b de       	rcall	.-714    	; 0x7164 <RNDIS_SendEncapsulatedCommand>
    742e:	88 23       	and	r24, r24
    7430:	f9 f4       	brne	.+62     	; 0x7470 <RNDIS_Host_InitializeDevice+0xd4>
	                                               sizeof(RNDIS_Initialize_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &InitMessageResponse,
    7432:	c8 01       	movw	r24, r16
    7434:	be 01       	movw	r22, r28
    7436:	67 5e       	subi	r22, 0xE7	; 231
    7438:	7f 4f       	sbci	r23, 0xFF	; 255
    743a:	44 e3       	ldi	r20, 0x34	; 52
    743c:	50 e0       	ldi	r21, 0x00	; 0
    743e:	a9 de       	rcall	.-686    	; 0x7192 <RNDIS_GetEncapsulatedResponse>
    7440:	88 23       	and	r24, r24
    7442:	b1 f4       	brne	.+44     	; 0x7470 <RNDIS_Host_InitializeDevice+0xd4>
	                                               sizeof(RNDIS_Initialize_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7444:	2d a1       	ldd	r18, Y+37	; 0x25
    7446:	3e a1       	ldd	r19, Y+38	; 0x26
    7448:	4f a1       	ldd	r20, Y+39	; 0x27
    744a:	58 a5       	ldd	r21, Y+40	; 0x28
    744c:	21 15       	cp	r18, r1
    744e:	31 05       	cpc	r19, r1
    7450:	41 05       	cpc	r20, r1
    7452:	51 05       	cpc	r21, r1
    7454:	61 f4       	brne	.+24     	; 0x746e <RNDIS_Host_InitializeDevice+0xd2>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);
    7456:	fe 01       	movw	r30, r28
    7458:	fd 96       	adiw	r30, 0x3d	; 61
    745a:	20 81       	ld	r18, Z
    745c:	31 81       	ldd	r19, Z+1	; 0x01
    745e:	42 81       	ldd	r20, Z+2	; 0x02
    7460:	53 81       	ldd	r21, Z+3	; 0x03
    7462:	f8 01       	movw	r30, r16
    7464:	20 8f       	std	Z+24, r18	; 0x18
    7466:	31 8f       	std	Z+25, r19	; 0x19
    7468:	42 8f       	std	Z+26, r20	; 0x1a
    746a:	53 8f       	std	Z+27, r21	; 0x1b

	return HOST_SENDCONTROL_Successful;
    746c:	01 c0       	rjmp	.+2      	; 0x7470 <RNDIS_Host_InitializeDevice+0xd4>
	{
		return ErrorCode;
	}

	if (InitMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    746e:	80 e8       	ldi	r24, 0x80	; 128

	RNDISInterfaceInfo->State.DeviceMaxPacketSize = le32_to_cpu(InitMessageResponse.MaxTransferSize);

	return HOST_SENDCONTROL_Successful;
}
    7470:	c4 5b       	subi	r28, 0xB4	; 180
    7472:	df 4f       	sbci	r29, 0xFF	; 255
    7474:	0f b6       	in	r0, 0x3f	; 63
    7476:	f8 94       	cli
    7478:	de bf       	out	0x3e, r29	; 62
    747a:	0f be       	out	0x3f, r0	; 63
    747c:	cd bf       	out	0x3d, r28	; 61
    747e:	cf 91       	pop	r28
    7480:	df 91       	pop	r29
    7482:	1f 91       	pop	r17
    7484:	0f 91       	pop	r16
    7486:	08 95       	ret

00007488 <RNDIS_Host_SetRNDISProperty>:

uint8_t RNDIS_Host_SetRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                    const uint32_t Oid,
                                    void* Buffer,
                                    const uint16_t Length)
{
    7488:	8f 92       	push	r8
    748a:	9f 92       	push	r9
    748c:	af 92       	push	r10
    748e:	bf 92       	push	r11
    7490:	cf 92       	push	r12
    7492:	df 92       	push	r13
    7494:	ef 92       	push	r14
    7496:	ff 92       	push	r15
    7498:	0f 93       	push	r16
    749a:	1f 93       	push	r17
    749c:	df 93       	push	r29
    749e:	cf 93       	push	r28
    74a0:	cd b7       	in	r28, 0x3d	; 61
    74a2:	de b7       	in	r29, 0x3e	; 62
    74a4:	60 97       	sbiw	r28, 0x10	; 16
    74a6:	0f b6       	in	r0, 0x3f	; 63
    74a8:	f8 94       	cli
    74aa:	de bf       	out	0x3e, r29	; 62
    74ac:	0f be       	out	0x3f, r0	; 63
    74ae:	cd bf       	out	0x3d, r28	; 61
    74b0:	6c 01       	movw	r12, r24

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	return HOST_SENDCONTROL_Successful;
}
    74b2:	8d b6       	in	r8, 0x3d	; 61
    74b4:	9e b6       	in	r9, 0x3e	; 62

	struct
	{
		RNDIS_Set_Message_t SetMessage;
		uint8_t             ContiguousBuffer[Length];
	} SetMessageData;
    74b6:	9c e1       	ldi	r25, 0x1C	; 28
    74b8:	a9 2e       	mov	r10, r25
    74ba:	b1 2c       	mov	r11, r1
    74bc:	a0 0e       	add	r10, r16
    74be:	b1 1e       	adc	r11, r17
    74c0:	8d b7       	in	r24, 0x3d	; 61
    74c2:	9e b7       	in	r25, 0x3e	; 62
    74c4:	8a 19       	sub	r24, r10
    74c6:	9b 09       	sbc	r25, r11
    74c8:	0f b6       	in	r0, 0x3f	; 63
    74ca:	f8 94       	cli
    74cc:	9e bf       	out	0x3e, r25	; 62
    74ce:	0f be       	out	0x3f, r0	; 63
    74d0:	8d bf       	out	0x3d, r24	; 61
    74d2:	ed b6       	in	r14, 0x3d	; 61
    74d4:	fe b6       	in	r15, 0x3e	; 62
    74d6:	08 94       	sec
    74d8:	e1 1c       	adc	r14, r1
    74da:	f1 1c       	adc	r15, r1

	RNDIS_Set_Complete_t SetMessageResponse;

	SetMessageData.SetMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_SET_MSG);
    74dc:	85 e0       	ldi	r24, 0x05	; 5
    74de:	90 e0       	ldi	r25, 0x00	; 0
    74e0:	a0 e0       	ldi	r26, 0x00	; 0
    74e2:	b0 e0       	ldi	r27, 0x00	; 0
    74e4:	ed b7       	in	r30, 0x3d	; 61
    74e6:	fe b7       	in	r31, 0x3e	; 62
    74e8:	81 83       	std	Z+1, r24	; 0x01
    74ea:	92 83       	std	Z+2, r25	; 0x02
    74ec:	a3 83       	std	Z+3, r26	; 0x03
    74ee:	b4 83       	std	Z+4, r27	; 0x04
	SetMessageData.SetMessage.MessageLength  = cpu_to_le32(sizeof(RNDIS_Set_Message_t) + Length);
    74f0:	c5 01       	movw	r24, r10
    74f2:	a0 e0       	ldi	r26, 0x00	; 0
    74f4:	b0 e0       	ldi	r27, 0x00	; 0
    74f6:	f7 01       	movw	r30, r14
    74f8:	84 83       	std	Z+4, r24	; 0x04
    74fa:	95 83       	std	Z+5, r25	; 0x05
    74fc:	a6 83       	std	Z+6, r26	; 0x06
    74fe:	b7 83       	std	Z+7, r27	; 0x07
	SetMessageData.SetMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    7500:	f6 01       	movw	r30, r12
    7502:	84 8d       	ldd	r24, Z+28	; 0x1c
    7504:	95 8d       	ldd	r25, Z+29	; 0x1d
    7506:	a6 8d       	ldd	r26, Z+30	; 0x1e
    7508:	b7 8d       	ldd	r27, Z+31	; 0x1f
    750a:	f7 01       	movw	r30, r14
    750c:	80 87       	std	Z+8, r24	; 0x08
    750e:	91 87       	std	Z+9, r25	; 0x09
    7510:	a2 87       	std	Z+10, r26	; 0x0a
    7512:	b3 87       	std	Z+11, r27	; 0x0b
    7514:	01 96       	adiw	r24, 0x01	; 1
    7516:	a1 1d       	adc	r26, r1
    7518:	b1 1d       	adc	r27, r1
    751a:	f6 01       	movw	r30, r12
    751c:	84 8f       	std	Z+28, r24	; 0x1c
    751e:	95 8f       	std	Z+29, r25	; 0x1d
    7520:	a6 8f       	std	Z+30, r26	; 0x1e
    7522:	b7 8f       	std	Z+31, r27	; 0x1f

	SetMessageData.SetMessage.Oid            = cpu_to_le32(Oid);
    7524:	f7 01       	movw	r30, r14
    7526:	44 87       	std	Z+12, r20	; 0x0c
    7528:	55 87       	std	Z+13, r21	; 0x0d
    752a:	66 87       	std	Z+14, r22	; 0x0e
    752c:	77 87       	std	Z+15, r23	; 0x0f
	SetMessageData.SetMessage.InformationBufferLength = cpu_to_le32(Length);
    752e:	c8 01       	movw	r24, r16
    7530:	a0 e0       	ldi	r26, 0x00	; 0
    7532:	b0 e0       	ldi	r27, 0x00	; 0
    7534:	80 8b       	std	Z+16, r24	; 0x10
    7536:	91 8b       	std	Z+17, r25	; 0x11
    7538:	a2 8b       	std	Z+18, r26	; 0x12
    753a:	b3 8b       	std	Z+19, r27	; 0x13
	SetMessageData.SetMessage.InformationBufferOffset = CPU_TO_LE32(sizeof(RNDIS_Set_Message_t) - sizeof(RNDIS_Message_Header_t));
    753c:	84 e1       	ldi	r24, 0x14	; 20
    753e:	90 e0       	ldi	r25, 0x00	; 0
    7540:	a0 e0       	ldi	r26, 0x00	; 0
    7542:	b0 e0       	ldi	r27, 0x00	; 0
    7544:	84 8b       	std	Z+20, r24	; 0x14
    7546:	95 8b       	std	Z+21, r25	; 0x15
    7548:	a6 8b       	std	Z+22, r26	; 0x16
    754a:	b7 8b       	std	Z+23, r27	; 0x17
	SetMessageData.SetMessage.DeviceVcHandle = CPU_TO_LE32(0);
    754c:	10 8e       	std	Z+24, r1	; 0x18
    754e:	11 8e       	std	Z+25, r1	; 0x19
    7550:	12 8e       	std	Z+26, r1	; 0x1a
    7552:	13 8e       	std	Z+27, r1	; 0x1b

	memcpy(&SetMessageData.ContiguousBuffer, Buffer, Length);
    7554:	4d b7       	in	r20, 0x3d	; 61
    7556:	5e b7       	in	r21, 0x3e	; 62
    7558:	43 5e       	subi	r20, 0xE3	; 227
    755a:	5f 4f       	sbci	r21, 0xFF	; 255
    755c:	ca 01       	movw	r24, r20
    755e:	b9 01       	movw	r22, r18
    7560:	a8 01       	movw	r20, r16
    7562:	58 d2       	rcall	.+1200   	; 0x7a14 <memcpy>

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &SetMessageData,
    7564:	c6 01       	movw	r24, r12
    7566:	b7 01       	movw	r22, r14
    7568:	a5 01       	movw	r20, r10
    756a:	fc dd       	rcall	.-1032   	; 0x7164 <RNDIS_SendEncapsulatedCommand>
    756c:	88 23       	and	r24, r24
    756e:	99 f4       	brne	.+38     	; 0x7596 <RNDIS_Host_SetRNDISProperty+0x10e>
	                                               (sizeof(RNDIS_Set_Message_t) + Length))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &SetMessageResponse,
    7570:	c6 01       	movw	r24, r12
    7572:	be 01       	movw	r22, r28
    7574:	6f 5f       	subi	r22, 0xFF	; 255
    7576:	7f 4f       	sbci	r23, 0xFF	; 255
    7578:	40 e1       	ldi	r20, 0x10	; 16
    757a:	50 e0       	ldi	r21, 0x00	; 0
    757c:	0a de       	rcall	.-1004   	; 0x7192 <RNDIS_GetEncapsulatedResponse>
    757e:	88 23       	and	r24, r24
    7580:	51 f4       	brne	.+20     	; 0x7596 <RNDIS_Host_SetRNDISProperty+0x10e>
	                                               sizeof(RNDIS_Set_Complete_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (SetMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    7582:	2d 85       	ldd	r18, Y+13	; 0x0d
    7584:	3e 85       	ldd	r19, Y+14	; 0x0e
    7586:	4f 85       	ldd	r20, Y+15	; 0x0f
    7588:	58 89       	ldd	r21, Y+16	; 0x10
    758a:	21 15       	cp	r18, r1
    758c:	31 05       	cpc	r19, r1
    758e:	41 05       	cpc	r20, r1
    7590:	51 05       	cpc	r21, r1
    7592:	09 f0       	breq	.+2      	; 0x7596 <RNDIS_Host_SetRNDISProperty+0x10e>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    7594:	80 e8       	ldi	r24, 0x80	; 128

	return HOST_SENDCONTROL_Successful;
}
    7596:	0f b6       	in	r0, 0x3f	; 63
    7598:	f8 94       	cli
    759a:	9e be       	out	0x3e, r9	; 62
    759c:	0f be       	out	0x3f, r0	; 63
    759e:	8d be       	out	0x3d, r8	; 61
    75a0:	60 96       	adiw	r28, 0x10	; 16
    75a2:	0f b6       	in	r0, 0x3f	; 63
    75a4:	f8 94       	cli
    75a6:	de bf       	out	0x3e, r29	; 62
    75a8:	0f be       	out	0x3f, r0	; 63
    75aa:	cd bf       	out	0x3d, r28	; 61
    75ac:	cf 91       	pop	r28
    75ae:	df 91       	pop	r29
    75b0:	1f 91       	pop	r17
    75b2:	0f 91       	pop	r16
    75b4:	ff 90       	pop	r15
    75b6:	ef 90       	pop	r14
    75b8:	df 90       	pop	r13
    75ba:	cf 90       	pop	r12
    75bc:	bf 90       	pop	r11
    75be:	af 90       	pop	r10
    75c0:	9f 90       	pop	r9
    75c2:	8f 90       	pop	r8
    75c4:	08 95       	ret

000075c6 <RNDIS_Host_QueryRNDISProperty>:

uint8_t RNDIS_Host_QueryRNDISProperty(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                                      const uint32_t Oid,
                                      void* Buffer,
                                      const uint16_t MaxLength)
{
    75c6:	5f 92       	push	r5
    75c8:	6f 92       	push	r6
    75ca:	7f 92       	push	r7
    75cc:	8f 92       	push	r8
    75ce:	9f 92       	push	r9
    75d0:	af 92       	push	r10
    75d2:	bf 92       	push	r11
    75d4:	cf 92       	push	r12
    75d6:	df 92       	push	r13
    75d8:	ef 92       	push	r14
    75da:	ff 92       	push	r15
    75dc:	0f 93       	push	r16
    75de:	1f 93       	push	r17
    75e0:	df 93       	push	r29
    75e2:	cf 93       	push	r28
    75e4:	cd b7       	in	r28, 0x3d	; 61
    75e6:	de b7       	in	r29, 0x3e	; 62
    75e8:	6c 97       	sbiw	r28, 0x1c	; 28
    75ea:	0f b6       	in	r0, 0x3f	; 63
    75ec:	f8 94       	cli
    75ee:	de bf       	out	0x3e, r29	; 62
    75f0:	0f be       	out	0x3f, r0	; 63
    75f2:	cd bf       	out	0x3d, r28	; 61
    75f4:	7c 01       	movw	r14, r24
    75f6:	52 2e       	mov	r5, r18
    75f8:	a3 2e       	mov	r10, r19
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    75fa:	6d b6       	in	r6, 0x3d	; 61
    75fc:	7e b6       	in	r7, 0x3e	; 62

	struct
	{
		RNDIS_Query_Complete_t QueryMessageResponse;
		uint8_t                ContiguousBuffer[MaxLength];
	} QueryMessageResponseData;
    75fe:	38 e1       	ldi	r19, 0x18	; 24
    7600:	83 2e       	mov	r8, r19
    7602:	91 2c       	mov	r9, r1
    7604:	80 0e       	add	r8, r16
    7606:	91 1e       	adc	r9, r17
    7608:	8d b7       	in	r24, 0x3d	; 61
    760a:	9e b7       	in	r25, 0x3e	; 62
    760c:	88 19       	sub	r24, r8
    760e:	99 09       	sbc	r25, r9
    7610:	0f b6       	in	r0, 0x3f	; 63
    7612:	f8 94       	cli
    7614:	9e bf       	out	0x3e, r25	; 62
    7616:	0f be       	out	0x3f, r0	; 63
    7618:	8d bf       	out	0x3d, r24	; 61
    761a:	cd b6       	in	r12, 0x3d	; 61
    761c:	de b6       	in	r13, 0x3e	; 62
    761e:	08 94       	sec
    7620:	c1 1c       	adc	r12, r1
    7622:	d1 1c       	adc	r13, r1

	QueryMessage.MessageType    = CPU_TO_LE32(REMOTE_NDIS_QUERY_MSG);
    7624:	84 e0       	ldi	r24, 0x04	; 4
    7626:	90 e0       	ldi	r25, 0x00	; 0
    7628:	a0 e0       	ldi	r26, 0x00	; 0
    762a:	b0 e0       	ldi	r27, 0x00	; 0
    762c:	89 83       	std	Y+1, r24	; 0x01
    762e:	9a 83       	std	Y+2, r25	; 0x02
    7630:	ab 83       	std	Y+3, r26	; 0x03
    7632:	bc 83       	std	Y+4, r27	; 0x04
	QueryMessage.MessageLength  = CPU_TO_LE32(sizeof(RNDIS_Query_Message_t));
    7634:	8c e1       	ldi	r24, 0x1C	; 28
    7636:	90 e0       	ldi	r25, 0x00	; 0
    7638:	a0 e0       	ldi	r26, 0x00	; 0
    763a:	b0 e0       	ldi	r27, 0x00	; 0
    763c:	8d 83       	std	Y+5, r24	; 0x05
    763e:	9e 83       	std	Y+6, r25	; 0x06
    7640:	af 83       	std	Y+7, r26	; 0x07
    7642:	b8 87       	std	Y+8, r27	; 0x08
	QueryMessage.RequestId      = cpu_to_le32(RNDISInterfaceInfo->State.RequestID++);
    7644:	f7 01       	movw	r30, r14
    7646:	84 8d       	ldd	r24, Z+28	; 0x1c
    7648:	95 8d       	ldd	r25, Z+29	; 0x1d
    764a:	a6 8d       	ldd	r26, Z+30	; 0x1e
    764c:	b7 8d       	ldd	r27, Z+31	; 0x1f
    764e:	89 87       	std	Y+9, r24	; 0x09
    7650:	9a 87       	std	Y+10, r25	; 0x0a
    7652:	ab 87       	std	Y+11, r26	; 0x0b
    7654:	bc 87       	std	Y+12, r27	; 0x0c
    7656:	01 96       	adiw	r24, 0x01	; 1
    7658:	a1 1d       	adc	r26, r1
    765a:	b1 1d       	adc	r27, r1
    765c:	84 8f       	std	Z+28, r24	; 0x1c
    765e:	95 8f       	std	Z+29, r25	; 0x1d
    7660:	a6 8f       	std	Z+30, r26	; 0x1e
    7662:	b7 8f       	std	Z+31, r27	; 0x1f

	QueryMessage.Oid            = cpu_to_le32(Oid);
    7664:	4d 87       	std	Y+13, r20	; 0x0d
    7666:	5e 87       	std	Y+14, r21	; 0x0e
    7668:	6f 87       	std	Y+15, r22	; 0x0f
    766a:	78 8b       	std	Y+16, r23	; 0x10
	QueryMessage.InformationBufferLength = CPU_TO_LE32(0);
    766c:	19 8a       	std	Y+17, r1	; 0x11
    766e:	1a 8a       	std	Y+18, r1	; 0x12
    7670:	1b 8a       	std	Y+19, r1	; 0x13
    7672:	1c 8a       	std	Y+20, r1	; 0x14
	QueryMessage.InformationBufferOffset = CPU_TO_LE32(0);
    7674:	1d 8a       	std	Y+21, r1	; 0x15
    7676:	1e 8a       	std	Y+22, r1	; 0x16
    7678:	1f 8a       	std	Y+23, r1	; 0x17
    767a:	18 8e       	std	Y+24, r1	; 0x18
	QueryMessage.DeviceVcHandle = CPU_TO_LE32(0);
    767c:	19 8e       	std	Y+25, r1	; 0x19
    767e:	1a 8e       	std	Y+26, r1	; 0x1a
    7680:	1b 8e       	std	Y+27, r1	; 0x1b
    7682:	1c 8e       	std	Y+28, r1	; 0x1c

	if ((ErrorCode = RNDIS_SendEncapsulatedCommand(RNDISInterfaceInfo, &QueryMessage,
    7684:	c7 01       	movw	r24, r14
    7686:	be 01       	movw	r22, r28
    7688:	6f 5f       	subi	r22, 0xFF	; 255
    768a:	7f 4f       	sbci	r23, 0xFF	; 255
    768c:	4c e1       	ldi	r20, 0x1C	; 28
    768e:	50 e0       	ldi	r21, 0x00	; 0
    7690:	69 dd       	rcall	.-1326   	; 0x7164 <RNDIS_SendEncapsulatedCommand>
    7692:	b8 2e       	mov	r11, r24
    7694:	88 23       	and	r24, r24
    7696:	d9 f4       	brne	.+54     	; 0x76ce <RNDIS_Host_QueryRNDISProperty+0x108>
	                                               sizeof(RNDIS_Query_Message_t))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if ((ErrorCode = RNDIS_GetEncapsulatedResponse(RNDISInterfaceInfo, &QueryMessageResponseData,
    7698:	c7 01       	movw	r24, r14
    769a:	b6 01       	movw	r22, r12
    769c:	a4 01       	movw	r20, r8
    769e:	79 dd       	rcall	.-1294   	; 0x7192 <RNDIS_GetEncapsulatedResponse>
    76a0:	b8 2e       	mov	r11, r24
    76a2:	88 23       	and	r24, r24
    76a4:	a1 f4       	brne	.+40     	; 0x76ce <RNDIS_Host_QueryRNDISProperty+0x108>
	                                               sizeof(QueryMessageResponseData))) != HOST_SENDCONTROL_Successful)
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
    76a6:	f6 01       	movw	r30, r12
    76a8:	84 85       	ldd	r24, Z+12	; 0x0c
    76aa:	95 85       	ldd	r25, Z+13	; 0x0d
    76ac:	a6 85       	ldd	r26, Z+14	; 0x0e
    76ae:	b7 85       	ldd	r27, Z+15	; 0x0f
    76b0:	00 97       	sbiw	r24, 0x00	; 0
    76b2:	a1 05       	cpc	r26, r1
    76b4:	b1 05       	cpc	r27, r1
    76b6:	49 f4       	brne	.+18     	; 0x76ca <RNDIS_Host_QueryRNDISProperty+0x104>
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);
    76b8:	96 01       	movw	r18, r12
    76ba:	28 5e       	subi	r18, 0xE8	; 232
    76bc:	3f 4f       	sbci	r19, 0xFF	; 255
    76be:	85 2d       	mov	r24, r5
    76c0:	9a 2d       	mov	r25, r10
    76c2:	b9 01       	movw	r22, r18
    76c4:	a8 01       	movw	r20, r16
    76c6:	a6 d1       	rcall	.+844    	; 0x7a14 <memcpy>
    76c8:	02 c0       	rjmp	.+4      	; 0x76ce <RNDIS_Host_QueryRNDISProperty+0x108>
	{
		return ErrorCode;
	}

	if (QueryMessageResponseData.QueryMessageResponse.Status != CPU_TO_LE32(REMOTE_NDIS_STATUS_SUCCESS))
	  return RNDIS_ERROR_LOGICAL_CMD_FAILED;
    76ca:	20 e8       	ldi	r18, 0x80	; 128
    76cc:	b2 2e       	mov	r11, r18

	memcpy(Buffer, &QueryMessageResponseData.ContiguousBuffer, MaxLength);

	return HOST_SENDCONTROL_Successful;
}
    76ce:	8b 2d       	mov	r24, r11
    76d0:	0f b6       	in	r0, 0x3f	; 63
    76d2:	f8 94       	cli
    76d4:	7e be       	out	0x3e, r7	; 62
    76d6:	0f be       	out	0x3f, r0	; 63
    76d8:	6d be       	out	0x3d, r6	; 61
    76da:	6c 96       	adiw	r28, 0x1c	; 28
    76dc:	0f b6       	in	r0, 0x3f	; 63
    76de:	f8 94       	cli
    76e0:	de bf       	out	0x3e, r29	; 62
    76e2:	0f be       	out	0x3f, r0	; 63
    76e4:	cd bf       	out	0x3d, r28	; 61
    76e6:	cf 91       	pop	r28
    76e8:	df 91       	pop	r29
    76ea:	1f 91       	pop	r17
    76ec:	0f 91       	pop	r16
    76ee:	ff 90       	pop	r15
    76f0:	ef 90       	pop	r14
    76f2:	df 90       	pop	r13
    76f4:	cf 90       	pop	r12
    76f6:	bf 90       	pop	r11
    76f8:	af 90       	pop	r10
    76fa:	9f 90       	pop	r9
    76fc:	8f 90       	pop	r8
    76fe:	7f 90       	pop	r7
    7700:	6f 90       	pop	r6
    7702:	5f 90       	pop	r5
    7704:	08 95       	ret

00007706 <RNDIS_Host_IsPacketReceived>:

bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
    7706:	fc 01       	movw	r30, r24
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7708:	8e b3       	in	r24, 0x1e	; 30
    770a:	8b 30       	cpi	r24, 0x0B	; 11
    770c:	a9 f4       	brne	.+42     	; 0x7738 <RNDIS_Host_IsPacketReceived+0x32>
    770e:	86 89       	ldd	r24, Z+22	; 0x16
    7710:	88 23       	and	r24, r24
    7712:	a1 f0       	breq	.+40     	; 0x773c <RNDIS_Host_IsPacketReceived+0x36>
    7714:	80 81       	ld	r24, Z
    7716:	8f 70       	andi	r24, 0x0F	; 15
    7718:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    771c:	80 91 a9 00 	lds	r24, 0x00A9
    7720:	8f 7b       	andi	r24, 0xBF	; 191
    7722:	80 93 a9 00 	sts	0x00A9, r24
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    7726:	80 91 a6 00 	lds	r24, 0x00A6
    772a:	81 70       	andi	r24, 0x01	; 1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    772c:	90 91 a9 00 	lds	r25, 0x00A9
    7730:	90 64       	ori	r25, 0x40	; 64
    7732:	90 93 a9 00 	sts	0x00A9, r25

	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
    7736:	08 95       	ret
bool RNDIS_Host_IsPacketReceived(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo)
{
	bool PacketWaiting;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return false;
    7738:	80 e0       	ldi	r24, 0x00	; 0
    773a:	08 95       	ret
    773c:	80 e0       	ldi	r24, 0x00	; 0
	Pipe_Unfreeze();
	PacketWaiting = Pipe_IsINReceived();
	Pipe_Freeze();

	return PacketWaiting;
}
    773e:	08 95       	ret

00007740 <RNDIS_Host_ReadPacket>:

uint8_t RNDIS_Host_ReadPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              uint16_t* const PacketLength)
{
    7740:	ef 92       	push	r14
    7742:	ff 92       	push	r15
    7744:	0f 93       	push	r16
    7746:	1f 93       	push	r17
    7748:	df 93       	push	r29
    774a:	cf 93       	push	r28
    774c:	cd b7       	in	r28, 0x3d	; 61
    774e:	de b7       	in	r29, 0x3e	; 62
    7750:	ad 97       	sbiw	r28, 0x2d	; 45
    7752:	0f b6       	in	r0, 0x3f	; 63
    7754:	f8 94       	cli
    7756:	de bf       	out	0x3e, r29	; 62
    7758:	0f be       	out	0x3f, r0	; 63
    775a:	cd bf       	out	0x3d, r28	; 61
    775c:	fc 01       	movw	r30, r24
    775e:	7b 01       	movw	r14, r22
    7760:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7762:	8e b3       	in	r24, 0x1e	; 30
    7764:	8b 30       	cpi	r24, 0x0B	; 11
    7766:	09 f0       	breq	.+2      	; 0x776a <RNDIS_Host_ReadPacket+0x2a>
    7768:	56 c0       	rjmp	.+172    	; 0x7816 <RNDIS_Host_ReadPacket+0xd6>
    776a:	86 89       	ldd	r24, Z+22	; 0x16
    776c:	88 23       	and	r24, r24
    776e:	09 f4       	brne	.+2      	; 0x7772 <RNDIS_Host_ReadPacket+0x32>
    7770:	52 c0       	rjmp	.+164    	; 0x7816 <RNDIS_Host_ReadPacket+0xd6>
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    7772:	80 81       	ld	r24, Z
    7774:	8f 70       	andi	r24, 0x0F	; 15
    7776:	80 93 a7 00 	sts	0x00A7, r24

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    777a:	80 91 a9 00 	lds	r24, 0x00A9
    777e:	8f 7b       	andi	r24, 0xBF	; 191
    7780:	80 93 a9 00 	sts	0x00A9, r24
			 *          on its direction.
			 */
			static inline bool Pipe_IsReadWriteAllowed(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsReadWriteAllowed(void)
			{
				return ((UPINTX & (1 << RWAL)) ? true : false);
    7784:	80 91 a6 00 	lds	r24, 0x00A6
	  return PIPE_READYWAIT_DeviceDisconnected;

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataINPipe.Address);
	Pipe_Unfreeze();

	if (!(Pipe_IsReadWriteAllowed()))
    7788:	85 fd       	sbrc	r24, 5
    778a:	13 c0       	rjmp	.+38     	; 0x77b2 <RNDIS_Host_ReadPacket+0x72>
			 *  \return Boolean \c true if the current pipe has received an IN packet, \c false otherwise.
			 */
			static inline bool Pipe_IsINReceived(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline bool Pipe_IsINReceived(void)
			{
				return ((UPINTX & (1 << RXINI)) ? true : false);
    778c:	80 91 a6 00 	lds	r24, 0x00A6
	{
		if (Pipe_IsINReceived())
    7790:	80 ff       	sbrs	r24, 0
    7792:	05 c0       	rjmp	.+10     	; 0x779e <RNDIS_Host_ReadPacket+0x5e>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    7794:	80 91 a6 00 	lds	r24, 0x00A6
    7798:	8e 77       	andi	r24, 0x7E	; 126
    779a:	80 93 a6 00 	sts	0x00A6, r24
		  Pipe_ClearIN();

		*PacketLength = 0;
    779e:	f8 01       	movw	r30, r16
    77a0:	11 82       	std	Z+1, r1	; 0x01
    77a2:	10 82       	st	Z, r1

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    77a4:	80 91 a9 00 	lds	r24, 0x00A9
    77a8:	80 64       	ori	r24, 0x40	; 64
    77aa:	80 93 a9 00 	sts	0x00A9, r24
		Pipe_Freeze();
		return PIPE_RWSTREAM_NoError;
    77ae:	20 e0       	ldi	r18, 0x00	; 0
    77b0:	33 c0       	rjmp	.+102    	; 0x7818 <RNDIS_Host_ReadPacket+0xd8>
	}

	RNDIS_Packet_Message_t DeviceMessage;

	if ((ErrorCode = Pipe_Read_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    77b2:	ce 01       	movw	r24, r28
    77b4:	01 96       	adiw	r24, 0x01	; 1
    77b6:	6c e2       	ldi	r22, 0x2C	; 44
    77b8:	70 e0       	ldi	r23, 0x00	; 0
    77ba:	40 e0       	ldi	r20, 0x00	; 0
    77bc:	50 e0       	ldi	r21, 0x00	; 0
    77be:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <Pipe_Read_Stream_LE>
    77c2:	28 2f       	mov	r18, r24
    77c4:	88 23       	and	r24, r24
    77c6:	41 f5       	brne	.+80     	; 0x7818 <RNDIS_Host_ReadPacket+0xd8>
	                                     NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	*PacketLength = (uint16_t)le32_to_cpu(DeviceMessage.DataLength);
    77c8:	8d 85       	ldd	r24, Y+13	; 0x0d
    77ca:	9e 85       	ldd	r25, Y+14	; 0x0e
    77cc:	f8 01       	movw	r30, r16
    77ce:	91 83       	std	Z+1, r25	; 0x01
    77d0:	80 83       	st	Z, r24

	Pipe_Discard_Stream(le32_to_cpu(DeviceMessage.DataOffset) -
    77d2:	89 85       	ldd	r24, Y+9	; 0x09
    77d4:	9a 85       	ldd	r25, Y+10	; 0x0a
    77d6:	84 97       	sbiw	r24, 0x24	; 36
    77d8:	60 e0       	ldi	r22, 0x00	; 0
    77da:	70 e0       	ldi	r23, 0x00	; 0
    77dc:	2d a7       	std	Y+45, r18	; 0x2d
    77de:	0e 94 cc 2a 	call	0x5598	; 0x5598 <Pipe_Discard_Stream>
	                    (sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t)),
	                    NULL);

	Pipe_Read_Stream_LE(Buffer, *PacketLength, NULL);
    77e2:	f8 01       	movw	r30, r16
    77e4:	60 81       	ld	r22, Z
    77e6:	71 81       	ldd	r23, Z+1	; 0x01
    77e8:	c7 01       	movw	r24, r14
    77ea:	40 e0       	ldi	r20, 0x00	; 0
    77ec:	50 e0       	ldi	r21, 0x00	; 0
    77ee:	0e 94 7a 2b 	call	0x56f4	; 0x56f4 <Pipe_Read_Stream_LE>
			 *  \return Total number of bytes in the currently selected pipe's FIFO buffer.
			 */
			static inline uint16_t Pipe_BytesInPipe(void) ATTR_WARN_UNUSED_RESULT ATTR_ALWAYS_INLINE;
			static inline uint16_t Pipe_BytesInPipe(void)
			{
				return UPBCX;
    77f2:	80 91 f6 00 	lds	r24, 0x00F6
    77f6:	90 91 f7 00 	lds	r25, 0x00F7

	if (!(Pipe_BytesInPipe()))
    77fa:	2d a5       	ldd	r18, Y+45	; 0x2d
    77fc:	00 97       	sbiw	r24, 0x00	; 0
    77fe:	29 f4       	brne	.+10     	; 0x780a <RNDIS_Host_ReadPacket+0xca>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearIN(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearIN(void)
			{
				UPINTX &= ~((1 << RXINI) | (1 << FIFOCON));
    7800:	80 91 a6 00 	lds	r24, 0x00A6
    7804:	8e 77       	andi	r24, 0x7E	; 126
    7806:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    780a:	80 91 a9 00 	lds	r24, 0x00A9
    780e:	80 64       	ori	r24, 0x40	; 64
    7810:	80 93 a9 00 	sts	0x00A9, r24
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    7814:	01 c0       	rjmp	.+2      	; 0x7818 <RNDIS_Host_ReadPacket+0xd8>
                              uint16_t* const PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    7816:	22 e0       	ldi	r18, 0x02	; 2
	  Pipe_ClearIN();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    7818:	82 2f       	mov	r24, r18
    781a:	ad 96       	adiw	r28, 0x2d	; 45
    781c:	0f b6       	in	r0, 0x3f	; 63
    781e:	f8 94       	cli
    7820:	de bf       	out	0x3e, r29	; 62
    7822:	0f be       	out	0x3f, r0	; 63
    7824:	cd bf       	out	0x3d, r28	; 61
    7826:	cf 91       	pop	r28
    7828:	df 91       	pop	r29
    782a:	1f 91       	pop	r17
    782c:	0f 91       	pop	r16
    782e:	ff 90       	pop	r15
    7830:	ef 90       	pop	r14
    7832:	08 95       	ret

00007834 <RNDIS_Host_SendPacket>:

uint8_t RNDIS_Host_SendPacket(USB_ClassInfo_RNDIS_Host_t* const RNDISInterfaceInfo,
                              void* Buffer,
                              const uint16_t PacketLength)
{
    7834:	ef 92       	push	r14
    7836:	ff 92       	push	r15
    7838:	0f 93       	push	r16
    783a:	1f 93       	push	r17
    783c:	df 93       	push	r29
    783e:	cf 93       	push	r28
    7840:	cd b7       	in	r28, 0x3d	; 61
    7842:	de b7       	in	r29, 0x3e	; 62
    7844:	ad 97       	sbiw	r28, 0x2d	; 45
    7846:	0f b6       	in	r0, 0x3f	; 63
    7848:	f8 94       	cli
    784a:	de bf       	out	0x3e, r29	; 62
    784c:	0f be       	out	0x3f, r0	; 63
    784e:	cd bf       	out	0x3d, r28	; 61
    7850:	fc 01       	movw	r30, r24
    7852:	7b 01       	movw	r14, r22
    7854:	8a 01       	movw	r16, r20
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
    7856:	8e b3       	in	r24, 0x1e	; 30
    7858:	8b 30       	cpi	r24, 0x0B	; 11
    785a:	09 f0       	breq	.+2      	; 0x785e <RNDIS_Host_SendPacket+0x2a>
    785c:	50 c0       	rjmp	.+160    	; 0x78fe <RNDIS_Host_SendPacket+0xca>
    785e:	86 89       	ldd	r24, Z+22	; 0x16
    7860:	88 23       	and	r24, r24
    7862:	09 f4       	brne	.+2      	; 0x7866 <RNDIS_Host_SendPacket+0x32>
    7864:	4c c0       	rjmp	.+152    	; 0x78fe <RNDIS_Host_SendPacket+0xca>
	  return PIPE_READYWAIT_DeviceDisconnected;

	RNDIS_Packet_Message_t DeviceMessage;

	memset(&DeviceMessage, 0, sizeof(RNDIS_Packet_Message_t));
    7866:	ce 01       	movw	r24, r28
    7868:	01 96       	adiw	r24, 0x01	; 1
    786a:	2c e2       	ldi	r18, 0x2C	; 44
    786c:	dc 01       	movw	r26, r24
    786e:	1d 92       	st	X+, r1
    7870:	2a 95       	dec	r18
    7872:	e9 f7       	brne	.-6      	; 0x786e <RNDIS_Host_SendPacket+0x3a>
	DeviceMessage.MessageType   = CPU_TO_LE32(REMOTE_NDIS_PACKET_MSG);
    7874:	21 e0       	ldi	r18, 0x01	; 1
    7876:	30 e0       	ldi	r19, 0x00	; 0
    7878:	40 e0       	ldi	r20, 0x00	; 0
    787a:	50 e0       	ldi	r21, 0x00	; 0
    787c:	29 83       	std	Y+1, r18	; 0x01
    787e:	3a 83       	std	Y+2, r19	; 0x02
    7880:	4b 83       	std	Y+3, r20	; 0x03
    7882:	5c 83       	std	Y+4, r21	; 0x04
	DeviceMessage.MessageLength = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) + PacketLength);
    7884:	98 01       	movw	r18, r16
    7886:	24 5d       	subi	r18, 0xD4	; 212
    7888:	3f 4f       	sbci	r19, 0xFF	; 255
    788a:	40 e0       	ldi	r20, 0x00	; 0
    788c:	50 e0       	ldi	r21, 0x00	; 0
    788e:	2d 83       	std	Y+5, r18	; 0x05
    7890:	3e 83       	std	Y+6, r19	; 0x06
    7892:	4f 83       	std	Y+7, r20	; 0x07
    7894:	58 87       	std	Y+8, r21	; 0x08
	DeviceMessage.DataOffset    = CPU_TO_LE32(sizeof(RNDIS_Packet_Message_t) - sizeof(RNDIS_Message_Header_t));
    7896:	24 e2       	ldi	r18, 0x24	; 36
    7898:	30 e0       	ldi	r19, 0x00	; 0
    789a:	40 e0       	ldi	r20, 0x00	; 0
    789c:	50 e0       	ldi	r21, 0x00	; 0
    789e:	29 87       	std	Y+9, r18	; 0x09
    78a0:	3a 87       	std	Y+10, r19	; 0x0a
    78a2:	4b 87       	std	Y+11, r20	; 0x0b
    78a4:	5c 87       	std	Y+12, r21	; 0x0c
	DeviceMessage.DataLength    = cpu_to_le32(PacketLength);
    78a6:	98 01       	movw	r18, r16
    78a8:	40 e0       	ldi	r20, 0x00	; 0
    78aa:	50 e0       	ldi	r21, 0x00	; 0
    78ac:	2d 87       	std	Y+13, r18	; 0x0d
    78ae:	3e 87       	std	Y+14, r19	; 0x0e
    78b0:	4f 87       	std	Y+15, r20	; 0x0f
    78b2:	58 8b       	std	Y+16, r21	; 0x10
			 *  \param[in] Address  Address of the pipe to select.
			 */
			static inline void Pipe_SelectPipe(const uint8_t Address) ATTR_ALWAYS_INLINE;
			static inline void Pipe_SelectPipe(const uint8_t Address)
			{
				UPNUM = (Address & PIPE_PIPENUM_MASK);
    78b4:	26 81       	ldd	r18, Z+6	; 0x06
    78b6:	2f 70       	andi	r18, 0x0F	; 15
    78b8:	20 93 a7 00 	sts	0x00A7, r18

			/** Unfreezes the selected pipe, allowing it to communicate with an attached device. */
			static inline void Pipe_Unfreeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Unfreeze(void)
			{
				UPCONX &= ~(1 << PFREEZE);
    78bc:	20 91 a9 00 	lds	r18, 0x00A9
    78c0:	2f 7b       	andi	r18, 0xBF	; 191
    78c2:	20 93 a9 00 	sts	0x00A9, r18

	Pipe_SelectPipe(RNDISInterfaceInfo->Config.DataOUTPipe.Address);
	Pipe_Unfreeze();

	if ((ErrorCode = Pipe_Write_Stream_LE(&DeviceMessage, sizeof(RNDIS_Packet_Message_t),
    78c6:	6c e2       	ldi	r22, 0x2C	; 44
    78c8:	70 e0       	ldi	r23, 0x00	; 0
    78ca:	40 e0       	ldi	r20, 0x00	; 0
    78cc:	50 e0       	ldi	r21, 0x00	; 0
    78ce:	0e 94 17 2b 	call	0x562e	; 0x562e <Pipe_Write_Stream_LE>
    78d2:	28 2f       	mov	r18, r24
    78d4:	88 23       	and	r24, r24
    78d6:	a1 f4       	brne	.+40     	; 0x7900 <RNDIS_Host_SendPacket+0xcc>
	                                      NULL)) != PIPE_RWSTREAM_NoError)
	{
		return ErrorCode;
	}

	Pipe_Write_Stream_LE(Buffer, PacketLength, NULL);
    78d8:	c7 01       	movw	r24, r14
    78da:	b8 01       	movw	r22, r16
    78dc:	40 e0       	ldi	r20, 0x00	; 0
    78de:	50 e0       	ldi	r21, 0x00	; 0
    78e0:	2d a7       	std	Y+45, r18	; 0x2d
    78e2:	0e 94 17 2b 	call	0x562e	; 0x562e <Pipe_Write_Stream_LE>
			 *  \ingroup Group_PipePacketManagement_AVR8
			 */
			static inline void Pipe_ClearOUT(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_ClearOUT(void)
			{
				UPINTX &= ~((1 << TXOUTI) | (1 << FIFOCON));
    78e6:	80 91 a6 00 	lds	r24, 0x00A6
    78ea:	8b 77       	andi	r24, 0x7B	; 123
    78ec:	80 93 a6 00 	sts	0x00A6, r24

			/** Freezes the selected pipe, preventing it from communicating with an attached device. */
			static inline void Pipe_Freeze(void) ATTR_ALWAYS_INLINE;
			static inline void Pipe_Freeze(void)
			{
				UPCONX |= (1 << PFREEZE);
    78f0:	80 91 a9 00 	lds	r24, 0x00A9
    78f4:	80 64       	ori	r24, 0x40	; 64
    78f6:	80 93 a9 00 	sts	0x00A9, r24
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
    78fa:	2d a5       	ldd	r18, Y+45	; 0x2d
    78fc:	01 c0       	rjmp	.+2      	; 0x7900 <RNDIS_Host_SendPacket+0xcc>
                              const uint16_t PacketLength)
{
	uint8_t ErrorCode;

	if ((USB_HostState != HOST_STATE_Configured) || !(RNDISInterfaceInfo->State.IsActive))
	  return PIPE_READYWAIT_DeviceDisconnected;
    78fe:	22 e0       	ldi	r18, 0x02	; 2
	Pipe_ClearOUT();

	Pipe_Freeze();

	return PIPE_RWSTREAM_NoError;
}
    7900:	82 2f       	mov	r24, r18
    7902:	ad 96       	adiw	r28, 0x2d	; 45
    7904:	0f b6       	in	r0, 0x3f	; 63
    7906:	f8 94       	cli
    7908:	de bf       	out	0x3e, r29	; 62
    790a:	0f be       	out	0x3f, r0	; 63
    790c:	cd bf       	out	0x3d, r28	; 61
    790e:	cf 91       	pop	r28
    7910:	df 91       	pop	r29
    7912:	1f 91       	pop	r17
    7914:	0f 91       	pop	r16
    7916:	ff 90       	pop	r15
    7918:	ef 90       	pop	r14
    791a:	08 95       	ret

0000791c <__mulsi3>:
    791c:	62 9f       	mul	r22, r18
    791e:	d0 01       	movw	r26, r0
    7920:	73 9f       	mul	r23, r19
    7922:	f0 01       	movw	r30, r0
    7924:	82 9f       	mul	r24, r18
    7926:	e0 0d       	add	r30, r0
    7928:	f1 1d       	adc	r31, r1
    792a:	64 9f       	mul	r22, r20
    792c:	e0 0d       	add	r30, r0
    792e:	f1 1d       	adc	r31, r1
    7930:	92 9f       	mul	r25, r18
    7932:	f0 0d       	add	r31, r0
    7934:	83 9f       	mul	r24, r19
    7936:	f0 0d       	add	r31, r0
    7938:	74 9f       	mul	r23, r20
    793a:	f0 0d       	add	r31, r0
    793c:	65 9f       	mul	r22, r21
    793e:	f0 0d       	add	r31, r0
    7940:	99 27       	eor	r25, r25
    7942:	72 9f       	mul	r23, r18
    7944:	b0 0d       	add	r27, r0
    7946:	e1 1d       	adc	r30, r1
    7948:	f9 1f       	adc	r31, r25
    794a:	63 9f       	mul	r22, r19
    794c:	b0 0d       	add	r27, r0
    794e:	e1 1d       	adc	r30, r1
    7950:	f9 1f       	adc	r31, r25
    7952:	bd 01       	movw	r22, r26
    7954:	cf 01       	movw	r24, r30
    7956:	11 24       	eor	r1, r1
    7958:	08 95       	ret

0000795a <__udivmodsi4>:
    795a:	a1 e2       	ldi	r26, 0x21	; 33
    795c:	1a 2e       	mov	r1, r26
    795e:	aa 1b       	sub	r26, r26
    7960:	bb 1b       	sub	r27, r27
    7962:	fd 01       	movw	r30, r26
    7964:	0d c0       	rjmp	.+26     	; 0x7980 <__udivmodsi4_ep>

00007966 <__udivmodsi4_loop>:
    7966:	aa 1f       	adc	r26, r26
    7968:	bb 1f       	adc	r27, r27
    796a:	ee 1f       	adc	r30, r30
    796c:	ff 1f       	adc	r31, r31
    796e:	a2 17       	cp	r26, r18
    7970:	b3 07       	cpc	r27, r19
    7972:	e4 07       	cpc	r30, r20
    7974:	f5 07       	cpc	r31, r21
    7976:	20 f0       	brcs	.+8      	; 0x7980 <__udivmodsi4_ep>
    7978:	a2 1b       	sub	r26, r18
    797a:	b3 0b       	sbc	r27, r19
    797c:	e4 0b       	sbc	r30, r20
    797e:	f5 0b       	sbc	r31, r21

00007980 <__udivmodsi4_ep>:
    7980:	66 1f       	adc	r22, r22
    7982:	77 1f       	adc	r23, r23
    7984:	88 1f       	adc	r24, r24
    7986:	99 1f       	adc	r25, r25
    7988:	1a 94       	dec	r1
    798a:	69 f7       	brne	.-38     	; 0x7966 <__udivmodsi4_loop>
    798c:	60 95       	com	r22
    798e:	70 95       	com	r23
    7990:	80 95       	com	r24
    7992:	90 95       	com	r25
    7994:	9b 01       	movw	r18, r22
    7996:	ac 01       	movw	r20, r24
    7998:	bd 01       	movw	r22, r26
    799a:	cf 01       	movw	r24, r30
    799c:	08 95       	ret

0000799e <memcpy_P>:
    799e:	fb 01       	movw	r30, r22
    79a0:	dc 01       	movw	r26, r24
    79a2:	02 c0       	rjmp	.+4      	; 0x79a8 <memcpy_P+0xa>
    79a4:	05 90       	lpm	r0, Z+
    79a6:	0d 92       	st	X+, r0
    79a8:	41 50       	subi	r20, 0x01	; 1
    79aa:	50 40       	sbci	r21, 0x00	; 0
    79ac:	d8 f7       	brcc	.-10     	; 0x79a4 <memcpy_P+0x6>
    79ae:	08 95       	ret

000079b0 <strcat_P>:
    79b0:	fb 01       	movw	r30, r22
    79b2:	dc 01       	movw	r26, r24
    79b4:	0d 90       	ld	r0, X+
    79b6:	00 20       	and	r0, r0
    79b8:	e9 f7       	brne	.-6      	; 0x79b4 <strcat_P+0x4>
    79ba:	11 97       	sbiw	r26, 0x01	; 1
    79bc:	05 90       	lpm	r0, Z+
    79be:	0d 92       	st	X+, r0
    79c0:	00 20       	and	r0, r0
    79c2:	e1 f7       	brne	.-8      	; 0x79bc <strcat_P+0xc>
    79c4:	08 95       	ret

000079c6 <strcmp_P>:
    79c6:	fb 01       	movw	r30, r22
    79c8:	dc 01       	movw	r26, r24
    79ca:	8d 91       	ld	r24, X+
    79cc:	05 90       	lpm	r0, Z+
    79ce:	80 19       	sub	r24, r0
    79d0:	01 10       	cpse	r0, r1
    79d2:	d9 f3       	breq	.-10     	; 0x79ca <strcmp_P+0x4>
    79d4:	99 0b       	sbc	r25, r25
    79d6:	08 95       	ret

000079d8 <strcpy_P>:
    79d8:	fb 01       	movw	r30, r22
    79da:	dc 01       	movw	r26, r24
    79dc:	05 90       	lpm	r0, Z+
    79de:	0d 92       	st	X+, r0
    79e0:	00 20       	and	r0, r0
    79e2:	e1 f7       	brne	.-8      	; 0x79dc <strcpy_P+0x4>
    79e4:	08 95       	ret

000079e6 <strlcpy_P>:
    79e6:	dc 01       	movw	r26, r24
    79e8:	fb 01       	movw	r30, r22
    79ea:	41 50       	subi	r20, 0x01	; 1
    79ec:	50 40       	sbci	r21, 0x00	; 0
    79ee:	58 f0       	brcs	.+22     	; 0x7a06 <strlcpy_P+0x20>
    79f0:	49 f0       	breq	.+18     	; 0x7a04 <strlcpy_P+0x1e>
    79f2:	05 90       	lpm	r0, Z+
    79f4:	0d 92       	st	X+, r0
    79f6:	00 20       	and	r0, r0
    79f8:	c1 f7       	brne	.-16     	; 0x79ea <strlcpy_P+0x4>
    79fa:	e6 1b       	sub	r30, r22
    79fc:	f7 0b       	sbc	r31, r23
    79fe:	31 97       	sbiw	r30, 0x01	; 1
    7a00:	cf 01       	movw	r24, r30
    7a02:	08 95       	ret
    7a04:	1c 92       	st	X, r1
    7a06:	05 90       	lpm	r0, Z+
    7a08:	00 20       	and	r0, r0
    7a0a:	e9 f7       	brne	.-6      	; 0x7a06 <strlcpy_P+0x20>
    7a0c:	f6 cf       	rjmp	.-20     	; 0x79fa <strlcpy_P+0x14>

00007a0e <strtok>:
    7a0e:	4a ed       	ldi	r20, 0xDA	; 218
    7a10:	53 e0       	ldi	r21, 0x03	; 3
    7a12:	43 c0       	rjmp	.+134    	; 0x7a9a <strtok_r>

00007a14 <memcpy>:
    7a14:	fb 01       	movw	r30, r22
    7a16:	dc 01       	movw	r26, r24
    7a18:	02 c0       	rjmp	.+4      	; 0x7a1e <memcpy+0xa>
    7a1a:	01 90       	ld	r0, Z+
    7a1c:	0d 92       	st	X+, r0
    7a1e:	41 50       	subi	r20, 0x01	; 1
    7a20:	50 40       	sbci	r21, 0x00	; 0
    7a22:	d8 f7       	brcc	.-10     	; 0x7a1a <memcpy+0x6>
    7a24:	08 95       	ret

00007a26 <memset>:
    7a26:	dc 01       	movw	r26, r24
    7a28:	01 c0       	rjmp	.+2      	; 0x7a2c <memset+0x6>
    7a2a:	6d 93       	st	X+, r22
    7a2c:	41 50       	subi	r20, 0x01	; 1
    7a2e:	50 40       	sbci	r21, 0x00	; 0
    7a30:	e0 f7       	brcc	.-8      	; 0x7a2a <memset+0x4>
    7a32:	08 95       	ret

00007a34 <strcat>:
    7a34:	fb 01       	movw	r30, r22
    7a36:	dc 01       	movw	r26, r24
    7a38:	0d 90       	ld	r0, X+
    7a3a:	00 20       	and	r0, r0
    7a3c:	e9 f7       	brne	.-6      	; 0x7a38 <strcat+0x4>
    7a3e:	11 97       	sbiw	r26, 0x01	; 1
    7a40:	01 90       	ld	r0, Z+
    7a42:	0d 92       	st	X+, r0
    7a44:	00 20       	and	r0, r0
    7a46:	e1 f7       	brne	.-8      	; 0x7a40 <strcat+0xc>
    7a48:	08 95       	ret

00007a4a <strchr>:
    7a4a:	fc 01       	movw	r30, r24
    7a4c:	81 91       	ld	r24, Z+
    7a4e:	86 17       	cp	r24, r22
    7a50:	21 f0       	breq	.+8      	; 0x7a5a <strchr+0x10>
    7a52:	88 23       	and	r24, r24
    7a54:	d9 f7       	brne	.-10     	; 0x7a4c <strchr+0x2>
    7a56:	99 27       	eor	r25, r25
    7a58:	08 95       	ret
    7a5a:	31 97       	sbiw	r30, 0x01	; 1
    7a5c:	cf 01       	movw	r24, r30
    7a5e:	08 95       	ret

00007a60 <strcmp>:
    7a60:	fb 01       	movw	r30, r22
    7a62:	dc 01       	movw	r26, r24
    7a64:	8d 91       	ld	r24, X+
    7a66:	01 90       	ld	r0, Z+
    7a68:	80 19       	sub	r24, r0
    7a6a:	01 10       	cpse	r0, r1
    7a6c:	d9 f3       	breq	.-10     	; 0x7a64 <strcmp+0x4>
    7a6e:	99 0b       	sbc	r25, r25
    7a70:	08 95       	ret

00007a72 <strlcpy>:
    7a72:	dc 01       	movw	r26, r24
    7a74:	fb 01       	movw	r30, r22
    7a76:	41 50       	subi	r20, 0x01	; 1
    7a78:	50 40       	sbci	r21, 0x00	; 0
    7a7a:	58 f0       	brcs	.+22     	; 0x7a92 <strlcpy+0x20>
    7a7c:	49 f0       	breq	.+18     	; 0x7a90 <strlcpy+0x1e>
    7a7e:	01 90       	ld	r0, Z+
    7a80:	0d 92       	st	X+, r0
    7a82:	00 20       	and	r0, r0
    7a84:	c1 f7       	brne	.-16     	; 0x7a76 <strlcpy+0x4>
    7a86:	e6 1b       	sub	r30, r22
    7a88:	f7 0b       	sbc	r31, r23
    7a8a:	31 97       	sbiw	r30, 0x01	; 1
    7a8c:	cf 01       	movw	r24, r30
    7a8e:	08 95       	ret
    7a90:	1c 92       	st	X, r1
    7a92:	01 90       	ld	r0, Z+
    7a94:	00 20       	and	r0, r0
    7a96:	e9 f7       	brne	.-6      	; 0x7a92 <strlcpy+0x20>
    7a98:	f6 cf       	rjmp	.-20     	; 0x7a86 <strlcpy+0x14>

00007a9a <strtok_r>:
    7a9a:	fa 01       	movw	r30, r20
    7a9c:	a1 91       	ld	r26, Z+
    7a9e:	b0 81       	ld	r27, Z
    7aa0:	00 97       	sbiw	r24, 0x00	; 0
    7aa2:	19 f4       	brne	.+6      	; 0x7aaa <strtok_r+0x10>
    7aa4:	10 97       	sbiw	r26, 0x00	; 0
    7aa6:	e1 f0       	breq	.+56     	; 0x7ae0 <strtok_r+0x46>
    7aa8:	cd 01       	movw	r24, r26
    7aaa:	dc 01       	movw	r26, r24
    7aac:	cd 01       	movw	r24, r26
    7aae:	0d 90       	ld	r0, X+
    7ab0:	00 20       	and	r0, r0
    7ab2:	11 f4       	brne	.+4      	; 0x7ab8 <strtok_r+0x1e>
    7ab4:	c0 01       	movw	r24, r0
    7ab6:	13 c0       	rjmp	.+38     	; 0x7ade <strtok_r+0x44>
    7ab8:	fb 01       	movw	r30, r22
    7aba:	21 91       	ld	r18, Z+
    7abc:	22 23       	and	r18, r18
    7abe:	19 f0       	breq	.+6      	; 0x7ac6 <strtok_r+0x2c>
    7ac0:	20 15       	cp	r18, r0
    7ac2:	d9 f7       	brne	.-10     	; 0x7aba <strtok_r+0x20>
    7ac4:	f3 cf       	rjmp	.-26     	; 0x7aac <strtok_r+0x12>
    7ac6:	fb 01       	movw	r30, r22
    7ac8:	21 91       	ld	r18, Z+
    7aca:	20 15       	cp	r18, r0
    7acc:	19 f4       	brne	.+6      	; 0x7ad4 <strtok_r+0x3a>
    7ace:	1e 92       	st	-X, r1
    7ad0:	11 96       	adiw	r26, 0x01	; 1
    7ad2:	06 c0       	rjmp	.+12     	; 0x7ae0 <strtok_r+0x46>
    7ad4:	22 23       	and	r18, r18
    7ad6:	c1 f7       	brne	.-16     	; 0x7ac8 <strtok_r+0x2e>
    7ad8:	0d 90       	ld	r0, X+
    7ada:	00 20       	and	r0, r0
    7adc:	a1 f7       	brne	.-24     	; 0x7ac6 <strtok_r+0x2c>
    7ade:	d0 01       	movw	r26, r0
    7ae0:	fa 01       	movw	r30, r20
    7ae2:	a1 93       	st	Z+, r26
    7ae4:	b0 83       	st	Z, r27
    7ae6:	08 95       	ret

00007ae8 <sprintf_P>:
    7ae8:	0f 93       	push	r16
    7aea:	1f 93       	push	r17
    7aec:	df 93       	push	r29
    7aee:	cf 93       	push	r28
    7af0:	cd b7       	in	r28, 0x3d	; 61
    7af2:	de b7       	in	r29, 0x3e	; 62
    7af4:	2e 97       	sbiw	r28, 0x0e	; 14
    7af6:	0f b6       	in	r0, 0x3f	; 63
    7af8:	f8 94       	cli
    7afa:	de bf       	out	0x3e, r29	; 62
    7afc:	0f be       	out	0x3f, r0	; 63
    7afe:	cd bf       	out	0x3d, r28	; 61
    7b00:	0d 89       	ldd	r16, Y+21	; 0x15
    7b02:	1e 89       	ldd	r17, Y+22	; 0x16
    7b04:	8e e0       	ldi	r24, 0x0E	; 14
    7b06:	8c 83       	std	Y+4, r24	; 0x04
    7b08:	1a 83       	std	Y+2, r17	; 0x02
    7b0a:	09 83       	std	Y+1, r16	; 0x01
    7b0c:	8f ef       	ldi	r24, 0xFF	; 255
    7b0e:	9f e7       	ldi	r25, 0x7F	; 127
    7b10:	9e 83       	std	Y+6, r25	; 0x06
    7b12:	8d 83       	std	Y+5, r24	; 0x05
    7b14:	9e 01       	movw	r18, r28
    7b16:	27 5e       	subi	r18, 0xE7	; 231
    7b18:	3f 4f       	sbci	r19, 0xFF	; 255
    7b1a:	ce 01       	movw	r24, r28
    7b1c:	01 96       	adiw	r24, 0x01	; 1
    7b1e:	6f 89       	ldd	r22, Y+23	; 0x17
    7b20:	78 8d       	ldd	r23, Y+24	; 0x18
    7b22:	a9 01       	movw	r20, r18
    7b24:	10 d0       	rcall	.+32     	; 0x7b46 <vfprintf>
    7b26:	ef 81       	ldd	r30, Y+7	; 0x07
    7b28:	f8 85       	ldd	r31, Y+8	; 0x08
    7b2a:	e0 0f       	add	r30, r16
    7b2c:	f1 1f       	adc	r31, r17
    7b2e:	10 82       	st	Z, r1
    7b30:	2e 96       	adiw	r28, 0x0e	; 14
    7b32:	0f b6       	in	r0, 0x3f	; 63
    7b34:	f8 94       	cli
    7b36:	de bf       	out	0x3e, r29	; 62
    7b38:	0f be       	out	0x3f, r0	; 63
    7b3a:	cd bf       	out	0x3d, r28	; 61
    7b3c:	cf 91       	pop	r28
    7b3e:	df 91       	pop	r29
    7b40:	1f 91       	pop	r17
    7b42:	0f 91       	pop	r16
    7b44:	08 95       	ret

00007b46 <vfprintf>:
    7b46:	2f 92       	push	r2
    7b48:	3f 92       	push	r3
    7b4a:	4f 92       	push	r4
    7b4c:	5f 92       	push	r5
    7b4e:	6f 92       	push	r6
    7b50:	7f 92       	push	r7
    7b52:	8f 92       	push	r8
    7b54:	9f 92       	push	r9
    7b56:	af 92       	push	r10
    7b58:	bf 92       	push	r11
    7b5a:	cf 92       	push	r12
    7b5c:	df 92       	push	r13
    7b5e:	ef 92       	push	r14
    7b60:	ff 92       	push	r15
    7b62:	0f 93       	push	r16
    7b64:	1f 93       	push	r17
    7b66:	df 93       	push	r29
    7b68:	cf 93       	push	r28
    7b6a:	cd b7       	in	r28, 0x3d	; 61
    7b6c:	de b7       	in	r29, 0x3e	; 62
    7b6e:	2c 97       	sbiw	r28, 0x0c	; 12
    7b70:	0f b6       	in	r0, 0x3f	; 63
    7b72:	f8 94       	cli
    7b74:	de bf       	out	0x3e, r29	; 62
    7b76:	0f be       	out	0x3f, r0	; 63
    7b78:	cd bf       	out	0x3d, r28	; 61
    7b7a:	6c 01       	movw	r12, r24
    7b7c:	1b 01       	movw	r2, r22
    7b7e:	8a 01       	movw	r16, r20
    7b80:	fc 01       	movw	r30, r24
    7b82:	17 82       	std	Z+7, r1	; 0x07
    7b84:	16 82       	std	Z+6, r1	; 0x06
    7b86:	83 81       	ldd	r24, Z+3	; 0x03
    7b88:	81 ff       	sbrs	r24, 1
    7b8a:	c4 c1       	rjmp	.+904    	; 0x7f14 <vfprintf+0x3ce>
    7b8c:	2e 01       	movw	r4, r28
    7b8e:	08 94       	sec
    7b90:	41 1c       	adc	r4, r1
    7b92:	51 1c       	adc	r5, r1
    7b94:	f6 01       	movw	r30, r12
    7b96:	93 81       	ldd	r25, Z+3	; 0x03
    7b98:	f1 01       	movw	r30, r2
    7b9a:	93 fd       	sbrc	r25, 3
    7b9c:	85 91       	lpm	r24, Z+
    7b9e:	93 ff       	sbrs	r25, 3
    7ba0:	81 91       	ld	r24, Z+
    7ba2:	1f 01       	movw	r2, r30
    7ba4:	88 23       	and	r24, r24
    7ba6:	09 f4       	brne	.+2      	; 0x7baa <vfprintf+0x64>
    7ba8:	b1 c1       	rjmp	.+866    	; 0x7f0c <vfprintf+0x3c6>
    7baa:	85 32       	cpi	r24, 0x25	; 37
    7bac:	39 f4       	brne	.+14     	; 0x7bbc <vfprintf+0x76>
    7bae:	93 fd       	sbrc	r25, 3
    7bb0:	85 91       	lpm	r24, Z+
    7bb2:	93 ff       	sbrs	r25, 3
    7bb4:	81 91       	ld	r24, Z+
    7bb6:	1f 01       	movw	r2, r30
    7bb8:	85 32       	cpi	r24, 0x25	; 37
    7bba:	21 f4       	brne	.+8      	; 0x7bc4 <vfprintf+0x7e>
    7bbc:	90 e0       	ldi	r25, 0x00	; 0
    7bbe:	b6 01       	movw	r22, r12
    7bc0:	db d1       	rcall	.+950    	; 0x7f78 <fputc>
    7bc2:	e8 cf       	rjmp	.-48     	; 0x7b94 <vfprintf+0x4e>
    7bc4:	ee 24       	eor	r14, r14
    7bc6:	ff 24       	eor	r15, r15
    7bc8:	20 e0       	ldi	r18, 0x00	; 0
    7bca:	20 32       	cpi	r18, 0x20	; 32
    7bcc:	b0 f4       	brcc	.+44     	; 0x7bfa <vfprintf+0xb4>
    7bce:	8b 32       	cpi	r24, 0x2B	; 43
    7bd0:	69 f0       	breq	.+26     	; 0x7bec <vfprintf+0xa6>
    7bd2:	8c 32       	cpi	r24, 0x2C	; 44
    7bd4:	28 f4       	brcc	.+10     	; 0x7be0 <vfprintf+0x9a>
    7bd6:	80 32       	cpi	r24, 0x20	; 32
    7bd8:	51 f0       	breq	.+20     	; 0x7bee <vfprintf+0xa8>
    7bda:	83 32       	cpi	r24, 0x23	; 35
    7bdc:	71 f4       	brne	.+28     	; 0x7bfa <vfprintf+0xb4>
    7bde:	0b c0       	rjmp	.+22     	; 0x7bf6 <vfprintf+0xb0>
    7be0:	8d 32       	cpi	r24, 0x2D	; 45
    7be2:	39 f0       	breq	.+14     	; 0x7bf2 <vfprintf+0xac>
    7be4:	80 33       	cpi	r24, 0x30	; 48
    7be6:	49 f4       	brne	.+18     	; 0x7bfa <vfprintf+0xb4>
    7be8:	21 60       	ori	r18, 0x01	; 1
    7bea:	2c c0       	rjmp	.+88     	; 0x7c44 <vfprintf+0xfe>
    7bec:	22 60       	ori	r18, 0x02	; 2
    7bee:	24 60       	ori	r18, 0x04	; 4
    7bf0:	29 c0       	rjmp	.+82     	; 0x7c44 <vfprintf+0xfe>
    7bf2:	28 60       	ori	r18, 0x08	; 8
    7bf4:	27 c0       	rjmp	.+78     	; 0x7c44 <vfprintf+0xfe>
    7bf6:	20 61       	ori	r18, 0x10	; 16
    7bf8:	25 c0       	rjmp	.+74     	; 0x7c44 <vfprintf+0xfe>
    7bfa:	27 fd       	sbrc	r18, 7
    7bfc:	2c c0       	rjmp	.+88     	; 0x7c56 <vfprintf+0x110>
    7bfe:	38 2f       	mov	r19, r24
    7c00:	30 53       	subi	r19, 0x30	; 48
    7c02:	3a 30       	cpi	r19, 0x0A	; 10
    7c04:	98 f4       	brcc	.+38     	; 0x7c2c <vfprintf+0xe6>
    7c06:	26 ff       	sbrs	r18, 6
    7c08:	08 c0       	rjmp	.+16     	; 0x7c1a <vfprintf+0xd4>
    7c0a:	8e 2d       	mov	r24, r14
    7c0c:	88 0f       	add	r24, r24
    7c0e:	e8 2e       	mov	r14, r24
    7c10:	ee 0c       	add	r14, r14
    7c12:	ee 0c       	add	r14, r14
    7c14:	e8 0e       	add	r14, r24
    7c16:	e3 0e       	add	r14, r19
    7c18:	15 c0       	rjmp	.+42     	; 0x7c44 <vfprintf+0xfe>
    7c1a:	8f 2d       	mov	r24, r15
    7c1c:	88 0f       	add	r24, r24
    7c1e:	f8 2e       	mov	r15, r24
    7c20:	ff 0c       	add	r15, r15
    7c22:	ff 0c       	add	r15, r15
    7c24:	f8 0e       	add	r15, r24
    7c26:	f3 0e       	add	r15, r19
    7c28:	20 62       	ori	r18, 0x20	; 32
    7c2a:	0c c0       	rjmp	.+24     	; 0x7c44 <vfprintf+0xfe>
    7c2c:	8e 32       	cpi	r24, 0x2E	; 46
    7c2e:	21 f4       	brne	.+8      	; 0x7c38 <vfprintf+0xf2>
    7c30:	26 fd       	sbrc	r18, 6
    7c32:	6c c1       	rjmp	.+728    	; 0x7f0c <vfprintf+0x3c6>
    7c34:	20 64       	ori	r18, 0x40	; 64
    7c36:	06 c0       	rjmp	.+12     	; 0x7c44 <vfprintf+0xfe>
    7c38:	8c 36       	cpi	r24, 0x6C	; 108
    7c3a:	11 f4       	brne	.+4      	; 0x7c40 <vfprintf+0xfa>
    7c3c:	20 68       	ori	r18, 0x80	; 128
    7c3e:	02 c0       	rjmp	.+4      	; 0x7c44 <vfprintf+0xfe>
    7c40:	88 36       	cpi	r24, 0x68	; 104
    7c42:	49 f4       	brne	.+18     	; 0x7c56 <vfprintf+0x110>
    7c44:	f1 01       	movw	r30, r2
    7c46:	93 fd       	sbrc	r25, 3
    7c48:	85 91       	lpm	r24, Z+
    7c4a:	93 ff       	sbrs	r25, 3
    7c4c:	81 91       	ld	r24, Z+
    7c4e:	1f 01       	movw	r2, r30
    7c50:	88 23       	and	r24, r24
    7c52:	09 f0       	breq	.+2      	; 0x7c56 <vfprintf+0x110>
    7c54:	ba cf       	rjmp	.-140    	; 0x7bca <vfprintf+0x84>
    7c56:	98 2f       	mov	r25, r24
    7c58:	95 54       	subi	r25, 0x45	; 69
    7c5a:	93 30       	cpi	r25, 0x03	; 3
    7c5c:	18 f0       	brcs	.+6      	; 0x7c64 <vfprintf+0x11e>
    7c5e:	90 52       	subi	r25, 0x20	; 32
    7c60:	93 30       	cpi	r25, 0x03	; 3
    7c62:	28 f4       	brcc	.+10     	; 0x7c6e <vfprintf+0x128>
    7c64:	0c 5f       	subi	r16, 0xFC	; 252
    7c66:	1f 4f       	sbci	r17, 0xFF	; 255
    7c68:	ff e3       	ldi	r31, 0x3F	; 63
    7c6a:	f9 83       	std	Y+1, r31	; 0x01
    7c6c:	0d c0       	rjmp	.+26     	; 0x7c88 <vfprintf+0x142>
    7c6e:	83 36       	cpi	r24, 0x63	; 99
    7c70:	31 f0       	breq	.+12     	; 0x7c7e <vfprintf+0x138>
    7c72:	83 37       	cpi	r24, 0x73	; 115
    7c74:	71 f0       	breq	.+28     	; 0x7c92 <vfprintf+0x14c>
    7c76:	83 35       	cpi	r24, 0x53	; 83
    7c78:	09 f0       	breq	.+2      	; 0x7c7c <vfprintf+0x136>
    7c7a:	5c c0       	rjmp	.+184    	; 0x7d34 <vfprintf+0x1ee>
    7c7c:	21 c0       	rjmp	.+66     	; 0x7cc0 <vfprintf+0x17a>
    7c7e:	f8 01       	movw	r30, r16
    7c80:	80 81       	ld	r24, Z
    7c82:	89 83       	std	Y+1, r24	; 0x01
    7c84:	0e 5f       	subi	r16, 0xFE	; 254
    7c86:	1f 4f       	sbci	r17, 0xFF	; 255
    7c88:	42 01       	movw	r8, r4
    7c8a:	71 e0       	ldi	r23, 0x01	; 1
    7c8c:	a7 2e       	mov	r10, r23
    7c8e:	b1 2c       	mov	r11, r1
    7c90:	15 c0       	rjmp	.+42     	; 0x7cbc <vfprintf+0x176>
    7c92:	62 e0       	ldi	r22, 0x02	; 2
    7c94:	66 2e       	mov	r6, r22
    7c96:	71 2c       	mov	r7, r1
    7c98:	60 0e       	add	r6, r16
    7c9a:	71 1e       	adc	r7, r17
    7c9c:	f8 01       	movw	r30, r16
    7c9e:	80 80       	ld	r8, Z
    7ca0:	91 80       	ldd	r9, Z+1	; 0x01
    7ca2:	26 ff       	sbrs	r18, 6
    7ca4:	03 c0       	rjmp	.+6      	; 0x7cac <vfprintf+0x166>
    7ca6:	6e 2d       	mov	r22, r14
    7ca8:	70 e0       	ldi	r23, 0x00	; 0
    7caa:	02 c0       	rjmp	.+4      	; 0x7cb0 <vfprintf+0x16a>
    7cac:	6f ef       	ldi	r22, 0xFF	; 255
    7cae:	7f ef       	ldi	r23, 0xFF	; 255
    7cb0:	c4 01       	movw	r24, r8
    7cb2:	2c 87       	std	Y+12, r18	; 0x0c
    7cb4:	56 d1       	rcall	.+684    	; 0x7f62 <strnlen>
    7cb6:	5c 01       	movw	r10, r24
    7cb8:	83 01       	movw	r16, r6
    7cba:	2c 85       	ldd	r18, Y+12	; 0x0c
    7cbc:	2f 77       	andi	r18, 0x7F	; 127
    7cbe:	16 c0       	rjmp	.+44     	; 0x7cec <vfprintf+0x1a6>
    7cc0:	52 e0       	ldi	r21, 0x02	; 2
    7cc2:	65 2e       	mov	r6, r21
    7cc4:	71 2c       	mov	r7, r1
    7cc6:	60 0e       	add	r6, r16
    7cc8:	71 1e       	adc	r7, r17
    7cca:	f8 01       	movw	r30, r16
    7ccc:	80 80       	ld	r8, Z
    7cce:	91 80       	ldd	r9, Z+1	; 0x01
    7cd0:	26 ff       	sbrs	r18, 6
    7cd2:	03 c0       	rjmp	.+6      	; 0x7cda <vfprintf+0x194>
    7cd4:	6e 2d       	mov	r22, r14
    7cd6:	70 e0       	ldi	r23, 0x00	; 0
    7cd8:	02 c0       	rjmp	.+4      	; 0x7cde <vfprintf+0x198>
    7cda:	6f ef       	ldi	r22, 0xFF	; 255
    7cdc:	7f ef       	ldi	r23, 0xFF	; 255
    7cde:	c4 01       	movw	r24, r8
    7ce0:	2c 87       	std	Y+12, r18	; 0x0c
    7ce2:	34 d1       	rcall	.+616    	; 0x7f4c <strnlen_P>
    7ce4:	5c 01       	movw	r10, r24
    7ce6:	2c 85       	ldd	r18, Y+12	; 0x0c
    7ce8:	20 68       	ori	r18, 0x80	; 128
    7cea:	83 01       	movw	r16, r6
    7cec:	23 fd       	sbrc	r18, 3
    7cee:	1e c0       	rjmp	.+60     	; 0x7d2c <vfprintf+0x1e6>
    7cf0:	07 c0       	rjmp	.+14     	; 0x7d00 <vfprintf+0x1ba>
    7cf2:	80 e2       	ldi	r24, 0x20	; 32
    7cf4:	90 e0       	ldi	r25, 0x00	; 0
    7cf6:	b6 01       	movw	r22, r12
    7cf8:	2c 87       	std	Y+12, r18	; 0x0c
    7cfa:	3e d1       	rcall	.+636    	; 0x7f78 <fputc>
    7cfc:	fa 94       	dec	r15
    7cfe:	2c 85       	ldd	r18, Y+12	; 0x0c
    7d00:	8f 2d       	mov	r24, r15
    7d02:	90 e0       	ldi	r25, 0x00	; 0
    7d04:	a8 16       	cp	r10, r24
    7d06:	b9 06       	cpc	r11, r25
    7d08:	a0 f3       	brcs	.-24     	; 0x7cf2 <vfprintf+0x1ac>
    7d0a:	10 c0       	rjmp	.+32     	; 0x7d2c <vfprintf+0x1e6>
    7d0c:	f4 01       	movw	r30, r8
    7d0e:	27 fd       	sbrc	r18, 7
    7d10:	85 91       	lpm	r24, Z+
    7d12:	27 ff       	sbrs	r18, 7
    7d14:	81 91       	ld	r24, Z+
    7d16:	4f 01       	movw	r8, r30
    7d18:	90 e0       	ldi	r25, 0x00	; 0
    7d1a:	b6 01       	movw	r22, r12
    7d1c:	2c 87       	std	Y+12, r18	; 0x0c
    7d1e:	2c d1       	rcall	.+600    	; 0x7f78 <fputc>
    7d20:	2c 85       	ldd	r18, Y+12	; 0x0c
    7d22:	f1 10       	cpse	r15, r1
    7d24:	fa 94       	dec	r15
    7d26:	08 94       	sec
    7d28:	a1 08       	sbc	r10, r1
    7d2a:	b1 08       	sbc	r11, r1
    7d2c:	a1 14       	cp	r10, r1
    7d2e:	b1 04       	cpc	r11, r1
    7d30:	69 f7       	brne	.-38     	; 0x7d0c <vfprintf+0x1c6>
    7d32:	e9 c0       	rjmp	.+466    	; 0x7f06 <vfprintf+0x3c0>
    7d34:	84 36       	cpi	r24, 0x64	; 100
    7d36:	11 f0       	breq	.+4      	; 0x7d3c <vfprintf+0x1f6>
    7d38:	89 36       	cpi	r24, 0x69	; 105
    7d3a:	41 f5       	brne	.+80     	; 0x7d8c <vfprintf+0x246>
    7d3c:	27 ff       	sbrs	r18, 7
    7d3e:	08 c0       	rjmp	.+16     	; 0x7d50 <vfprintf+0x20a>
    7d40:	f8 01       	movw	r30, r16
    7d42:	60 81       	ld	r22, Z
    7d44:	71 81       	ldd	r23, Z+1	; 0x01
    7d46:	82 81       	ldd	r24, Z+2	; 0x02
    7d48:	93 81       	ldd	r25, Z+3	; 0x03
    7d4a:	0c 5f       	subi	r16, 0xFC	; 252
    7d4c:	1f 4f       	sbci	r17, 0xFF	; 255
    7d4e:	09 c0       	rjmp	.+18     	; 0x7d62 <vfprintf+0x21c>
    7d50:	f8 01       	movw	r30, r16
    7d52:	60 81       	ld	r22, Z
    7d54:	71 81       	ldd	r23, Z+1	; 0x01
    7d56:	88 27       	eor	r24, r24
    7d58:	77 fd       	sbrc	r23, 7
    7d5a:	80 95       	com	r24
    7d5c:	98 2f       	mov	r25, r24
    7d5e:	0e 5f       	subi	r16, 0xFE	; 254
    7d60:	1f 4f       	sbci	r17, 0xFF	; 255
    7d62:	4f e6       	ldi	r20, 0x6F	; 111
    7d64:	b4 2e       	mov	r11, r20
    7d66:	b2 22       	and	r11, r18
    7d68:	97 ff       	sbrs	r25, 7
    7d6a:	09 c0       	rjmp	.+18     	; 0x7d7e <vfprintf+0x238>
    7d6c:	90 95       	com	r25
    7d6e:	80 95       	com	r24
    7d70:	70 95       	com	r23
    7d72:	61 95       	neg	r22
    7d74:	7f 4f       	sbci	r23, 0xFF	; 255
    7d76:	8f 4f       	sbci	r24, 0xFF	; 255
    7d78:	9f 4f       	sbci	r25, 0xFF	; 255
    7d7a:	f0 e8       	ldi	r31, 0x80	; 128
    7d7c:	bf 2a       	or	r11, r31
    7d7e:	a2 01       	movw	r20, r4
    7d80:	2a e0       	ldi	r18, 0x0A	; 10
    7d82:	30 e0       	ldi	r19, 0x00	; 0
    7d84:	25 d1       	rcall	.+586    	; 0x7fd0 <__ultoa_invert>
    7d86:	78 2e       	mov	r7, r24
    7d88:	74 18       	sub	r7, r4
    7d8a:	44 c0       	rjmp	.+136    	; 0x7e14 <vfprintf+0x2ce>
    7d8c:	85 37       	cpi	r24, 0x75	; 117
    7d8e:	31 f4       	brne	.+12     	; 0x7d9c <vfprintf+0x256>
    7d90:	3f ee       	ldi	r19, 0xEF	; 239
    7d92:	b3 2e       	mov	r11, r19
    7d94:	b2 22       	and	r11, r18
    7d96:	2a e0       	ldi	r18, 0x0A	; 10
    7d98:	30 e0       	ldi	r19, 0x00	; 0
    7d9a:	25 c0       	rjmp	.+74     	; 0x7de6 <vfprintf+0x2a0>
    7d9c:	99 ef       	ldi	r25, 0xF9	; 249
    7d9e:	b9 2e       	mov	r11, r25
    7da0:	b2 22       	and	r11, r18
    7da2:	8f 36       	cpi	r24, 0x6F	; 111
    7da4:	c1 f0       	breq	.+48     	; 0x7dd6 <vfprintf+0x290>
    7da6:	80 37       	cpi	r24, 0x70	; 112
    7da8:	20 f4       	brcc	.+8      	; 0x7db2 <vfprintf+0x26c>
    7daa:	88 35       	cpi	r24, 0x58	; 88
    7dac:	09 f0       	breq	.+2      	; 0x7db0 <vfprintf+0x26a>
    7dae:	ae c0       	rjmp	.+348    	; 0x7f0c <vfprintf+0x3c6>
    7db0:	0d c0       	rjmp	.+26     	; 0x7dcc <vfprintf+0x286>
    7db2:	80 37       	cpi	r24, 0x70	; 112
    7db4:	21 f0       	breq	.+8      	; 0x7dbe <vfprintf+0x278>
    7db6:	88 37       	cpi	r24, 0x78	; 120
    7db8:	09 f0       	breq	.+2      	; 0x7dbc <vfprintf+0x276>
    7dba:	a8 c0       	rjmp	.+336    	; 0x7f0c <vfprintf+0x3c6>
    7dbc:	02 c0       	rjmp	.+4      	; 0x7dc2 <vfprintf+0x27c>
    7dbe:	20 e1       	ldi	r18, 0x10	; 16
    7dc0:	b2 2a       	or	r11, r18
    7dc2:	b4 fe       	sbrs	r11, 4
    7dc4:	0b c0       	rjmp	.+22     	; 0x7ddc <vfprintf+0x296>
    7dc6:	84 e0       	ldi	r24, 0x04	; 4
    7dc8:	b8 2a       	or	r11, r24
    7dca:	08 c0       	rjmp	.+16     	; 0x7ddc <vfprintf+0x296>
    7dcc:	b4 fe       	sbrs	r11, 4
    7dce:	09 c0       	rjmp	.+18     	; 0x7de2 <vfprintf+0x29c>
    7dd0:	e6 e0       	ldi	r30, 0x06	; 6
    7dd2:	be 2a       	or	r11, r30
    7dd4:	06 c0       	rjmp	.+12     	; 0x7de2 <vfprintf+0x29c>
    7dd6:	28 e0       	ldi	r18, 0x08	; 8
    7dd8:	30 e0       	ldi	r19, 0x00	; 0
    7dda:	05 c0       	rjmp	.+10     	; 0x7de6 <vfprintf+0x2a0>
    7ddc:	20 e1       	ldi	r18, 0x10	; 16
    7dde:	30 e0       	ldi	r19, 0x00	; 0
    7de0:	02 c0       	rjmp	.+4      	; 0x7de6 <vfprintf+0x2a0>
    7de2:	20 e1       	ldi	r18, 0x10	; 16
    7de4:	32 e0       	ldi	r19, 0x02	; 2
    7de6:	b7 fe       	sbrs	r11, 7
    7de8:	08 c0       	rjmp	.+16     	; 0x7dfa <vfprintf+0x2b4>
    7dea:	f8 01       	movw	r30, r16
    7dec:	60 81       	ld	r22, Z
    7dee:	71 81       	ldd	r23, Z+1	; 0x01
    7df0:	82 81       	ldd	r24, Z+2	; 0x02
    7df2:	93 81       	ldd	r25, Z+3	; 0x03
    7df4:	0c 5f       	subi	r16, 0xFC	; 252
    7df6:	1f 4f       	sbci	r17, 0xFF	; 255
    7df8:	07 c0       	rjmp	.+14     	; 0x7e08 <vfprintf+0x2c2>
    7dfa:	f8 01       	movw	r30, r16
    7dfc:	60 81       	ld	r22, Z
    7dfe:	71 81       	ldd	r23, Z+1	; 0x01
    7e00:	80 e0       	ldi	r24, 0x00	; 0
    7e02:	90 e0       	ldi	r25, 0x00	; 0
    7e04:	0e 5f       	subi	r16, 0xFE	; 254
    7e06:	1f 4f       	sbci	r17, 0xFF	; 255
    7e08:	a2 01       	movw	r20, r4
    7e0a:	e2 d0       	rcall	.+452    	; 0x7fd0 <__ultoa_invert>
    7e0c:	78 2e       	mov	r7, r24
    7e0e:	74 18       	sub	r7, r4
    7e10:	ff e7       	ldi	r31, 0x7F	; 127
    7e12:	bf 22       	and	r11, r31
    7e14:	b6 fe       	sbrs	r11, 6
    7e16:	0b c0       	rjmp	.+22     	; 0x7e2e <vfprintf+0x2e8>
    7e18:	2e ef       	ldi	r18, 0xFE	; 254
    7e1a:	b2 22       	and	r11, r18
    7e1c:	7e 14       	cp	r7, r14
    7e1e:	38 f4       	brcc	.+14     	; 0x7e2e <vfprintf+0x2e8>
    7e20:	b4 fe       	sbrs	r11, 4
    7e22:	07 c0       	rjmp	.+14     	; 0x7e32 <vfprintf+0x2ec>
    7e24:	b2 fc       	sbrc	r11, 2
    7e26:	05 c0       	rjmp	.+10     	; 0x7e32 <vfprintf+0x2ec>
    7e28:	8f ee       	ldi	r24, 0xEF	; 239
    7e2a:	b8 22       	and	r11, r24
    7e2c:	02 c0       	rjmp	.+4      	; 0x7e32 <vfprintf+0x2ec>
    7e2e:	a7 2c       	mov	r10, r7
    7e30:	01 c0       	rjmp	.+2      	; 0x7e34 <vfprintf+0x2ee>
    7e32:	ae 2c       	mov	r10, r14
    7e34:	8b 2d       	mov	r24, r11
    7e36:	90 e0       	ldi	r25, 0x00	; 0
    7e38:	b4 fe       	sbrs	r11, 4
    7e3a:	0d c0       	rjmp	.+26     	; 0x7e56 <vfprintf+0x310>
    7e3c:	fe 01       	movw	r30, r28
    7e3e:	e7 0d       	add	r30, r7
    7e40:	f1 1d       	adc	r31, r1
    7e42:	20 81       	ld	r18, Z
    7e44:	20 33       	cpi	r18, 0x30	; 48
    7e46:	19 f4       	brne	.+6      	; 0x7e4e <vfprintf+0x308>
    7e48:	e9 ee       	ldi	r30, 0xE9	; 233
    7e4a:	be 22       	and	r11, r30
    7e4c:	09 c0       	rjmp	.+18     	; 0x7e60 <vfprintf+0x31a>
    7e4e:	a3 94       	inc	r10
    7e50:	b2 fe       	sbrs	r11, 2
    7e52:	06 c0       	rjmp	.+12     	; 0x7e60 <vfprintf+0x31a>
    7e54:	04 c0       	rjmp	.+8      	; 0x7e5e <vfprintf+0x318>
    7e56:	86 78       	andi	r24, 0x86	; 134
    7e58:	90 70       	andi	r25, 0x00	; 0
    7e5a:	00 97       	sbiw	r24, 0x00	; 0
    7e5c:	09 f0       	breq	.+2      	; 0x7e60 <vfprintf+0x31a>
    7e5e:	a3 94       	inc	r10
    7e60:	8b 2c       	mov	r8, r11
    7e62:	99 24       	eor	r9, r9
    7e64:	b3 fc       	sbrc	r11, 3
    7e66:	13 c0       	rjmp	.+38     	; 0x7e8e <vfprintf+0x348>
    7e68:	b0 fe       	sbrs	r11, 0
    7e6a:	0e c0       	rjmp	.+28     	; 0x7e88 <vfprintf+0x342>
    7e6c:	af 14       	cp	r10, r15
    7e6e:	28 f4       	brcc	.+10     	; 0x7e7a <vfprintf+0x334>
    7e70:	e7 2c       	mov	r14, r7
    7e72:	ef 0c       	add	r14, r15
    7e74:	ea 18       	sub	r14, r10
    7e76:	af 2c       	mov	r10, r15
    7e78:	07 c0       	rjmp	.+14     	; 0x7e88 <vfprintf+0x342>
    7e7a:	e7 2c       	mov	r14, r7
    7e7c:	05 c0       	rjmp	.+10     	; 0x7e88 <vfprintf+0x342>
    7e7e:	80 e2       	ldi	r24, 0x20	; 32
    7e80:	90 e0       	ldi	r25, 0x00	; 0
    7e82:	b6 01       	movw	r22, r12
    7e84:	79 d0       	rcall	.+242    	; 0x7f78 <fputc>
    7e86:	a3 94       	inc	r10
    7e88:	af 14       	cp	r10, r15
    7e8a:	c8 f3       	brcs	.-14     	; 0x7e7e <vfprintf+0x338>
    7e8c:	04 c0       	rjmp	.+8      	; 0x7e96 <vfprintf+0x350>
    7e8e:	af 14       	cp	r10, r15
    7e90:	10 f4       	brcc	.+4      	; 0x7e96 <vfprintf+0x350>
    7e92:	fa 18       	sub	r15, r10
    7e94:	01 c0       	rjmp	.+2      	; 0x7e98 <vfprintf+0x352>
    7e96:	ff 24       	eor	r15, r15
    7e98:	84 fe       	sbrs	r8, 4
    7e9a:	0e c0       	rjmp	.+28     	; 0x7eb8 <vfprintf+0x372>
    7e9c:	80 e3       	ldi	r24, 0x30	; 48
    7e9e:	90 e0       	ldi	r25, 0x00	; 0
    7ea0:	b6 01       	movw	r22, r12
    7ea2:	6a d0       	rcall	.+212    	; 0x7f78 <fputc>
    7ea4:	82 fe       	sbrs	r8, 2
    7ea6:	1d c0       	rjmp	.+58     	; 0x7ee2 <vfprintf+0x39c>
    7ea8:	81 fe       	sbrs	r8, 1
    7eaa:	03 c0       	rjmp	.+6      	; 0x7eb2 <vfprintf+0x36c>
    7eac:	88 e5       	ldi	r24, 0x58	; 88
    7eae:	90 e0       	ldi	r25, 0x00	; 0
    7eb0:	10 c0       	rjmp	.+32     	; 0x7ed2 <vfprintf+0x38c>
    7eb2:	88 e7       	ldi	r24, 0x78	; 120
    7eb4:	90 e0       	ldi	r25, 0x00	; 0
    7eb6:	0d c0       	rjmp	.+26     	; 0x7ed2 <vfprintf+0x38c>
    7eb8:	c4 01       	movw	r24, r8
    7eba:	86 78       	andi	r24, 0x86	; 134
    7ebc:	90 70       	andi	r25, 0x00	; 0
    7ebe:	00 97       	sbiw	r24, 0x00	; 0
    7ec0:	81 f0       	breq	.+32     	; 0x7ee2 <vfprintf+0x39c>
    7ec2:	81 fc       	sbrc	r8, 1
    7ec4:	02 c0       	rjmp	.+4      	; 0x7eca <vfprintf+0x384>
    7ec6:	80 e2       	ldi	r24, 0x20	; 32
    7ec8:	01 c0       	rjmp	.+2      	; 0x7ecc <vfprintf+0x386>
    7eca:	8b e2       	ldi	r24, 0x2B	; 43
    7ecc:	b7 fc       	sbrc	r11, 7
    7ece:	8d e2       	ldi	r24, 0x2D	; 45
    7ed0:	90 e0       	ldi	r25, 0x00	; 0
    7ed2:	b6 01       	movw	r22, r12
    7ed4:	51 d0       	rcall	.+162    	; 0x7f78 <fputc>
    7ed6:	05 c0       	rjmp	.+10     	; 0x7ee2 <vfprintf+0x39c>
    7ed8:	80 e3       	ldi	r24, 0x30	; 48
    7eda:	90 e0       	ldi	r25, 0x00	; 0
    7edc:	b6 01       	movw	r22, r12
    7ede:	4c d0       	rcall	.+152    	; 0x7f78 <fputc>
    7ee0:	ea 94       	dec	r14
    7ee2:	7e 14       	cp	r7, r14
    7ee4:	c8 f3       	brcs	.-14     	; 0x7ed8 <vfprintf+0x392>
    7ee6:	7a 94       	dec	r7
    7ee8:	f2 01       	movw	r30, r4
    7eea:	e7 0d       	add	r30, r7
    7eec:	f1 1d       	adc	r31, r1
    7eee:	80 81       	ld	r24, Z
    7ef0:	90 e0       	ldi	r25, 0x00	; 0
    7ef2:	b6 01       	movw	r22, r12
    7ef4:	41 d0       	rcall	.+130    	; 0x7f78 <fputc>
    7ef6:	77 20       	and	r7, r7
    7ef8:	b1 f7       	brne	.-20     	; 0x7ee6 <vfprintf+0x3a0>
    7efa:	05 c0       	rjmp	.+10     	; 0x7f06 <vfprintf+0x3c0>
    7efc:	80 e2       	ldi	r24, 0x20	; 32
    7efe:	90 e0       	ldi	r25, 0x00	; 0
    7f00:	b6 01       	movw	r22, r12
    7f02:	3a d0       	rcall	.+116    	; 0x7f78 <fputc>
    7f04:	fa 94       	dec	r15
    7f06:	ff 20       	and	r15, r15
    7f08:	c9 f7       	brne	.-14     	; 0x7efc <vfprintf+0x3b6>
    7f0a:	44 ce       	rjmp	.-888    	; 0x7b94 <vfprintf+0x4e>
    7f0c:	f6 01       	movw	r30, r12
    7f0e:	26 81       	ldd	r18, Z+6	; 0x06
    7f10:	37 81       	ldd	r19, Z+7	; 0x07
    7f12:	02 c0       	rjmp	.+4      	; 0x7f18 <vfprintf+0x3d2>
    7f14:	2f ef       	ldi	r18, 0xFF	; 255
    7f16:	3f ef       	ldi	r19, 0xFF	; 255
    7f18:	c9 01       	movw	r24, r18
    7f1a:	2c 96       	adiw	r28, 0x0c	; 12
    7f1c:	0f b6       	in	r0, 0x3f	; 63
    7f1e:	f8 94       	cli
    7f20:	de bf       	out	0x3e, r29	; 62
    7f22:	0f be       	out	0x3f, r0	; 63
    7f24:	cd bf       	out	0x3d, r28	; 61
    7f26:	cf 91       	pop	r28
    7f28:	df 91       	pop	r29
    7f2a:	1f 91       	pop	r17
    7f2c:	0f 91       	pop	r16
    7f2e:	ff 90       	pop	r15
    7f30:	ef 90       	pop	r14
    7f32:	df 90       	pop	r13
    7f34:	cf 90       	pop	r12
    7f36:	bf 90       	pop	r11
    7f38:	af 90       	pop	r10
    7f3a:	9f 90       	pop	r9
    7f3c:	8f 90       	pop	r8
    7f3e:	7f 90       	pop	r7
    7f40:	6f 90       	pop	r6
    7f42:	5f 90       	pop	r5
    7f44:	4f 90       	pop	r4
    7f46:	3f 90       	pop	r3
    7f48:	2f 90       	pop	r2
    7f4a:	08 95       	ret

00007f4c <strnlen_P>:
    7f4c:	fc 01       	movw	r30, r24
    7f4e:	05 90       	lpm	r0, Z+
    7f50:	61 50       	subi	r22, 0x01	; 1
    7f52:	70 40       	sbci	r23, 0x00	; 0
    7f54:	01 10       	cpse	r0, r1
    7f56:	d8 f7       	brcc	.-10     	; 0x7f4e <strnlen_P+0x2>
    7f58:	80 95       	com	r24
    7f5a:	90 95       	com	r25
    7f5c:	8e 0f       	add	r24, r30
    7f5e:	9f 1f       	adc	r25, r31
    7f60:	08 95       	ret

00007f62 <strnlen>:
    7f62:	fc 01       	movw	r30, r24
    7f64:	61 50       	subi	r22, 0x01	; 1
    7f66:	70 40       	sbci	r23, 0x00	; 0
    7f68:	01 90       	ld	r0, Z+
    7f6a:	01 10       	cpse	r0, r1
    7f6c:	d8 f7       	brcc	.-10     	; 0x7f64 <strnlen+0x2>
    7f6e:	80 95       	com	r24
    7f70:	90 95       	com	r25
    7f72:	8e 0f       	add	r24, r30
    7f74:	9f 1f       	adc	r25, r31
    7f76:	08 95       	ret

00007f78 <fputc>:
    7f78:	0f 93       	push	r16
    7f7a:	1f 93       	push	r17
    7f7c:	cf 93       	push	r28
    7f7e:	df 93       	push	r29
    7f80:	8c 01       	movw	r16, r24
    7f82:	eb 01       	movw	r28, r22
    7f84:	8b 81       	ldd	r24, Y+3	; 0x03
    7f86:	81 ff       	sbrs	r24, 1
    7f88:	1b c0       	rjmp	.+54     	; 0x7fc0 <fputc+0x48>
    7f8a:	82 ff       	sbrs	r24, 2
    7f8c:	0d c0       	rjmp	.+26     	; 0x7fa8 <fputc+0x30>
    7f8e:	2e 81       	ldd	r18, Y+6	; 0x06
    7f90:	3f 81       	ldd	r19, Y+7	; 0x07
    7f92:	8c 81       	ldd	r24, Y+4	; 0x04
    7f94:	9d 81       	ldd	r25, Y+5	; 0x05
    7f96:	28 17       	cp	r18, r24
    7f98:	39 07       	cpc	r19, r25
    7f9a:	64 f4       	brge	.+24     	; 0x7fb4 <fputc+0x3c>
    7f9c:	e8 81       	ld	r30, Y
    7f9e:	f9 81       	ldd	r31, Y+1	; 0x01
    7fa0:	01 93       	st	Z+, r16
    7fa2:	f9 83       	std	Y+1, r31	; 0x01
    7fa4:	e8 83       	st	Y, r30
    7fa6:	06 c0       	rjmp	.+12     	; 0x7fb4 <fputc+0x3c>
    7fa8:	e8 85       	ldd	r30, Y+8	; 0x08
    7faa:	f9 85       	ldd	r31, Y+9	; 0x09
    7fac:	80 2f       	mov	r24, r16
    7fae:	09 95       	icall
    7fb0:	00 97       	sbiw	r24, 0x00	; 0
    7fb2:	31 f4       	brne	.+12     	; 0x7fc0 <fputc+0x48>
    7fb4:	8e 81       	ldd	r24, Y+6	; 0x06
    7fb6:	9f 81       	ldd	r25, Y+7	; 0x07
    7fb8:	01 96       	adiw	r24, 0x01	; 1
    7fba:	9f 83       	std	Y+7, r25	; 0x07
    7fbc:	8e 83       	std	Y+6, r24	; 0x06
    7fbe:	02 c0       	rjmp	.+4      	; 0x7fc4 <fputc+0x4c>
    7fc0:	0f ef       	ldi	r16, 0xFF	; 255
    7fc2:	1f ef       	ldi	r17, 0xFF	; 255
    7fc4:	c8 01       	movw	r24, r16
    7fc6:	df 91       	pop	r29
    7fc8:	cf 91       	pop	r28
    7fca:	1f 91       	pop	r17
    7fcc:	0f 91       	pop	r16
    7fce:	08 95       	ret

00007fd0 <__ultoa_invert>:
    7fd0:	fa 01       	movw	r30, r20
    7fd2:	aa 27       	eor	r26, r26
    7fd4:	28 30       	cpi	r18, 0x08	; 8
    7fd6:	51 f1       	breq	.+84     	; 0x802c <__ultoa_invert+0x5c>
    7fd8:	20 31       	cpi	r18, 0x10	; 16
    7fda:	81 f1       	breq	.+96     	; 0x803c <__ultoa_invert+0x6c>
    7fdc:	e8 94       	clt
    7fde:	6f 93       	push	r22
    7fe0:	6e 7f       	andi	r22, 0xFE	; 254
    7fe2:	6e 5f       	subi	r22, 0xFE	; 254
    7fe4:	7f 4f       	sbci	r23, 0xFF	; 255
    7fe6:	8f 4f       	sbci	r24, 0xFF	; 255
    7fe8:	9f 4f       	sbci	r25, 0xFF	; 255
    7fea:	af 4f       	sbci	r26, 0xFF	; 255
    7fec:	b1 e0       	ldi	r27, 0x01	; 1
    7fee:	3e d0       	rcall	.+124    	; 0x806c <__ultoa_invert+0x9c>
    7ff0:	b4 e0       	ldi	r27, 0x04	; 4
    7ff2:	3c d0       	rcall	.+120    	; 0x806c <__ultoa_invert+0x9c>
    7ff4:	67 0f       	add	r22, r23
    7ff6:	78 1f       	adc	r23, r24
    7ff8:	89 1f       	adc	r24, r25
    7ffa:	9a 1f       	adc	r25, r26
    7ffc:	a1 1d       	adc	r26, r1
    7ffe:	68 0f       	add	r22, r24
    8000:	79 1f       	adc	r23, r25
    8002:	8a 1f       	adc	r24, r26
    8004:	91 1d       	adc	r25, r1
    8006:	a1 1d       	adc	r26, r1
    8008:	6a 0f       	add	r22, r26
    800a:	71 1d       	adc	r23, r1
    800c:	81 1d       	adc	r24, r1
    800e:	91 1d       	adc	r25, r1
    8010:	a1 1d       	adc	r26, r1
    8012:	20 d0       	rcall	.+64     	; 0x8054 <__ultoa_invert+0x84>
    8014:	09 f4       	brne	.+2      	; 0x8018 <__ultoa_invert+0x48>
    8016:	68 94       	set
    8018:	3f 91       	pop	r19
    801a:	2a e0       	ldi	r18, 0x0A	; 10
    801c:	26 9f       	mul	r18, r22
    801e:	11 24       	eor	r1, r1
    8020:	30 19       	sub	r19, r0
    8022:	30 5d       	subi	r19, 0xD0	; 208
    8024:	31 93       	st	Z+, r19
    8026:	de f6       	brtc	.-74     	; 0x7fde <__ultoa_invert+0xe>
    8028:	cf 01       	movw	r24, r30
    802a:	08 95       	ret
    802c:	46 2f       	mov	r20, r22
    802e:	47 70       	andi	r20, 0x07	; 7
    8030:	40 5d       	subi	r20, 0xD0	; 208
    8032:	41 93       	st	Z+, r20
    8034:	b3 e0       	ldi	r27, 0x03	; 3
    8036:	0f d0       	rcall	.+30     	; 0x8056 <__ultoa_invert+0x86>
    8038:	c9 f7       	brne	.-14     	; 0x802c <__ultoa_invert+0x5c>
    803a:	f6 cf       	rjmp	.-20     	; 0x8028 <__ultoa_invert+0x58>
    803c:	46 2f       	mov	r20, r22
    803e:	4f 70       	andi	r20, 0x0F	; 15
    8040:	40 5d       	subi	r20, 0xD0	; 208
    8042:	4a 33       	cpi	r20, 0x3A	; 58
    8044:	18 f0       	brcs	.+6      	; 0x804c <__ultoa_invert+0x7c>
    8046:	49 5d       	subi	r20, 0xD9	; 217
    8048:	31 fd       	sbrc	r19, 1
    804a:	40 52       	subi	r20, 0x20	; 32
    804c:	41 93       	st	Z+, r20
    804e:	02 d0       	rcall	.+4      	; 0x8054 <__ultoa_invert+0x84>
    8050:	a9 f7       	brne	.-22     	; 0x803c <__ultoa_invert+0x6c>
    8052:	ea cf       	rjmp	.-44     	; 0x8028 <__ultoa_invert+0x58>
    8054:	b4 e0       	ldi	r27, 0x04	; 4
    8056:	a6 95       	lsr	r26
    8058:	97 95       	ror	r25
    805a:	87 95       	ror	r24
    805c:	77 95       	ror	r23
    805e:	67 95       	ror	r22
    8060:	ba 95       	dec	r27
    8062:	c9 f7       	brne	.-14     	; 0x8056 <__ultoa_invert+0x86>
    8064:	00 97       	sbiw	r24, 0x00	; 0
    8066:	61 05       	cpc	r22, r1
    8068:	71 05       	cpc	r23, r1
    806a:	08 95       	ret
    806c:	9b 01       	movw	r18, r22
    806e:	ac 01       	movw	r20, r24
    8070:	0a 2e       	mov	r0, r26
    8072:	06 94       	lsr	r0
    8074:	57 95       	ror	r21
    8076:	47 95       	ror	r20
    8078:	37 95       	ror	r19
    807a:	27 95       	ror	r18
    807c:	ba 95       	dec	r27
    807e:	c9 f7       	brne	.-14     	; 0x8072 <__ultoa_invert+0xa2>
    8080:	62 0f       	add	r22, r18
    8082:	73 1f       	adc	r23, r19
    8084:	84 1f       	adc	r24, r20
    8086:	95 1f       	adc	r25, r21
    8088:	a0 1d       	adc	r26, r0
    808a:	08 95       	ret

0000808c <_exit>:
    808c:	f8 94       	cli

0000808e <__stop_program>:
    808e:	ff cf       	rjmp	.-2      	; 0x808e <__stop_program>
